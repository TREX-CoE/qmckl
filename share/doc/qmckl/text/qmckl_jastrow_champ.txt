                         ______________________

                          CHAMP JASTROW FACTOR

                                TREX CoE
                         ______________________


Table of Contents
_________________

1. Introduction
.. 1. Reformulation of the three-body part
2. Context
.. 1. Data structure
.. 2. Initialization functions
........ 1. Fortran interface
.. 3. Access functions
........ 1. Fortran interface
3. Computation
.. 1. Electron-electron component
..... 1. Asymptotic component
........ 1. Get
........ 2. Compute
..... 2. Electron-electron rescaled distances
........ 1. Get
........ 2. Compute
..... 3. Electron-electron rescaled distance gradients and Laplacian with respect to electron coordinates
........ 1. Get
........ 2. Compute
..... 4. Electron-electron component
........ 1. Get
........ 2. Compute
..... 5. Derivative
........ 1. Get
........ 2. Compute
.. 2. Electron-nucleus component
..... 1. Asymptotic component
........ 1. Get
........ 2. Compute
..... 2. Electron-nucleus rescaled distances
........ 1. Get
........ 2. Compute
..... 3. Electron-electron rescaled distance gradients and Laplacian with respect to electron coordinates
........ 1. Get
........ 2. Compute
..... 4. Electron-nucleus component
........ 1. Get
........ 2. Compute
..... 5. Derivative
........ 1. Get
........ 2. Compute
........ 3. Test
.. 3. Electron-electron-nucleus component
..... 1. Electron-electron rescaled distances in $J_\text{eeN}$
........ 1. Get
........ 2. Compute
........ 3. Test
..... 2. Electron-electron rescaled distances derivatives in $J_\text{eeN}$
........ 1. Get
........ 2. Compute
..... 3. Electron-nucleus rescaled distances in $J_\text{eeN}$
........ 1. Get
........ 2. Compute
..... 4. Electron-nucleus rescaled distances derivatives in $J_\text{eeN}$
........ 1. Get
........ 2. Compute
..... 5. Temporary arrays for electron-electron-nucleus Jastrow $f_{een}$
........ 1. Compute dim_c_vector
........ 2. Get
........ 3. Compute c_vector_full
........ 4. Compute lkpm_combined_index
........ 5. Compute tmp_c
........ 6. Compute dtmp_c
..... 6. Electron-electron-nucleus Jastrow $f_{een}$
........ 1. Get
........ 2. Compute naive
........ 3. Compute
..... 7. Electron-electron-nucleus Jastrow $f_{een}$ derivative
........ 1. Get
........ 2. Compute Naive
........ 3. Compute GL
........ 4. Compute Gradient only
.. 4. Total Jastrow
..... 1. Value
........ 1. Get
........ 2. Compute
..... 2. Derivatives
........ 1. Get
........ 2. Compute GL
........ 3. Compute Gradient only





1 Introduction
==============

  The Jastrow factor depends on the electronic ($\mathbf{r}$) and
  nuclear ($\mathbf{R}$) coordinates. Its defined as
  $\exp(J(\mathbf{r},\mathbf{R}))$, where

  \[ J(\mathbf{r},\mathbf{R}) = J_{\text{eN}}(\mathbf{r},\mathbf{R}) +
    J_{\text{ee}}(\mathbf{r}) + J_{\text{eeN}}(\mathbf{r},\mathbf{R}) \]

  In the following, we use the notations $r_{ij} = |\mathbf{r}_i -
  \mathbf{r}_j|$ and $R_{i\alpha} = |\mathbf{r}_i - \mathbf{R}_\alpha|$.

  $J_{\text{eN}}$ contains electron-nucleus terms:

  \[ J_{\text{eN}}(\mathbf{r},\mathbf{R}) =
    \sum_{\alpha=1}^{N_\text{nucl}} \sum_{i=1}^{N_\text{elec}}
    \frac{a_{1\,\alpha}\, f_\alpha(R_{i\alpha})}{1+a_{2\,\alpha}\,
    f_\alpha(R_{i\alpha})} + \sum_{p=2}^{N_\text{ord}^a}
    a_{p+1\,\alpha}\, [f_\alpha(R_{i\alpha})]^p - J_{\text{eN}}^{\infty
    \alpha} \]

  $J_{\text{ee}}$ contains electron-electron terms: \[
  J_{\text{ee}}(\mathbf{r}) = \sum_{i=1}^{N_\text{elec}}
  \sum_{j=1}^{i-1} \frac{\frac{1}{2}(1+\delta^{\uparrow\downarrow}_{ij})
  b_1\, f_{\text{ee}}(r_{ij})}{1+b_2\, f_{\text{ee}}(r_{ij})} +
  \sum_{p=2}^{N_\text{ord}^b} b_{p+1}\, [f_{\text{ee}}(r_{ij})]^p -
  J_{ee}^\infty \]

  and $J_{\text{eeN}}$ contains electron-electron-Nucleus terms:

  \[ J_{\text{eeN}}(\mathbf{r},\mathbf{R}) =
     \sum_{\alpha=1}^{N_{\text{nucl}}} \sum_{i=1}^{N_{\text{elec}}}
     \sum_{j=1}^{i-1} \sum_{p=2}^{N_{\text{ord}}} \sum_{k=0}^{p-1}
     \sum_{l=0}^{p-k-2\delta_{k,0}} c_{lkp\alpha} \left[
     g_\text{e}({r}_{ij}) \right]^k \left[ \left[
     g_\alpha({R}_{i\alpha}) \right]^l + \left[ g_\alpha({R}_{j\alpha})
     \right]^l \right] \left[ g_\alpha({R}_{i\,\alpha}) \,
     g_\alpha({R}_{j\alpha}) \right]^{(p-k-l)/2} \]

  $c_{lkp\alpha}$ are non-zero only when $p-k-l$ is even.

  $f$ and $g$ are scaling function defined as

  \[ f_\alpha(r) = \frac{1-e^{-\kappa_\alpha\, r}}{\kappa_\alpha} \text{
    and } g_\alpha(r) = e^{-\kappa_\alpha\, r} = 1-\kappa_\alpha
    f_\alpha(r).  \]

  The terms $J_{\text{ee}}^\infty$ and $J_{\text{eN}}^\infty$ are shifts
  to ensure that $J_{\text{ee}}$ and $J_{\text{eN}}$ have an asymptotic
  value of zero.

  The eN and eeN parameters are the same of all identical nuclei.
  Warning: The types of nuclei use zero-based indexing.

  The derivatives are computed with respect to the electron $i$ for \[
  r_{ij} = |r_i - r_j| \]


1.1 Reformulation of the three-body part
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  To accelerate the computation of the three-body part, the Jastrow
  factor is re-expressed as follows, with $m=(p-k)/2 -l/2$:


  \begin{eqnarray*}
     J_{kpl} & = & \sum_{\alpha=1}^{N_{\text{nucl}}}
       \sum_{i=1}^{N_{\text{elec}}}
        \sum_{j=1}^{i-1}
             c_{lkp\alpha} \left[ g_\text{e}({r}_{ij}) \right]^k
               \left[ \left[ g_\alpha({R}_{i\alpha}) \right]^l + \left[ g_\alpha({R}_{j\alpha}) \right]^l \right]
               \left[ g_\alpha({R}_{i\,\alpha}) \,
     g_\alpha({R}_{j\alpha}) \right]^{m} \\
     & = & \frac{1}{2}
      \sum_{\alpha=1}^{N_{\text{nucl}}}
       \sum_{i=1}^{N_{\text{elec}}}
        \sum_{j=1}^{N_{\text{elec}}}
             c_{lkp\alpha} \left[ g_\text{e}({r}_{ij}) \right]^k
               \left[ \left[ g_\alpha({R}_{i\alpha}) \right]^l + \left[ g_\alpha({R}_{j\alpha}) \right]^l \right]
               \left[ g_\alpha({R}_{i\,\alpha}) \, g_\alpha({R}_{j\alpha}) \right]^{m} \\
     & = & \frac{1}{2}
      \sum_{\alpha=1}^{N_{\text{nucl}}}
       \sum_{i=1}^{N_{\text{elec}}}
        \sum_{j=1}^{N_{\text{elec}}}
             c_{lkp\alpha} \left[ g_\text{e}({r}_{ij}) \right]^k
               \left[ \left[ g_\alpha({R}_{i\alpha}) \right]^{l+m} \left[ g_\alpha({R}_{j\alpha}) \right]^{m} +
                      \left[ g_\alpha({R}_{i\alpha}) \right]^{l} \left[
      g_\alpha({R}_{j\alpha}) \right]^{l+m} \right] \\
     & = & 
      \sum_{\alpha=1}^{N_{\text{nucl}}} c_{lkp\alpha}
       \sum_{i=1}^{N_{\text{elec}}}
        \sum_{j=1}^{N_{\text{elec}}} 
               \left[ g_\alpha({R}_{i\alpha}) \right]^{l+m}
               \left[ g_\text{e}({r}_{ij}) \right]^k
               \left[ g_\alpha({R}_{j\alpha}) \right]^{m} \\
     & = & 
      \sum_{\alpha=1}^{N_{\text{nucl}}} c_{lkp\alpha}
       \sum_{i=1}^{N_{\text{elec}}} 
               \left[ g_\alpha({R}_{i\alpha}) \right]^{l+m}
               P_{i\alpha}^{km}, \text{ with }
               P_{i\alpha}^{km} =
        \sum_{j=1}^{N_{\text{elec}}} 
               \left[ g_\text{e}({r}_{ij}) \right]^k
               \left[ g_\alpha({R}_{j\alpha}) \right]^{m}. \\
  J   & = & 
     \sum_{p=2}^{N_{\text{ord}}}
      \sum_{k=0}^{p-1}
       \sum_{l=0}^{p-k-2\delta_{k,0}}
        \sum_{\alpha=1}^{N_{\text{nucl}}} c_{lkp\alpha}
         \sum_{i=1}^{N_{\text{elec}}}
          \left[ g_\alpha({R}_{i\alpha}) \right]^{(p-k+l)/2}
               P_{i\alpha}^{k, (p-k-l)/2}
     \end{eqnarray*}

  The computation of $P$ scales as $\mathcal{O}(N_\text{elec}^2
  N_\text{nucl}n^2)$, and the computation of $J$ scales as
  $\mathcal{O}(N_\text{elec}N_\text{nucl}n^2)$.


2 Context
=========

  The following data stored in the context:

  -------------------------------------------------------------------------------------------------------------------------------------------
   Variable             Type                                   Description                                                                   
  -------------------------------------------------------------------------------------------------------------------------------------------
   `uninitialized'      `int32_t'                              Keeps bits set for uninitialized data                                         
   `rescale_factor_ee'  `double'                               The distance scaling factor                                                   
   `rescale_factor_en'  `double[type_nucl_num]'                The distance scaling factor                                                   
   `aord_num'           `int64_t'                              The number of a coeffecients                                                  
   `bord_num'           `int64_t'                              The number of b coeffecients                                                  
   `cord_num'           `int64_t'                              The number of c coeffecients                                                  
   `type_nucl_num'      `int64_t'                              Number of Nuclei types                                                        
   `type_nucl_vector'   `int64_t[nucl_num]'                    IDs of types of Nuclei. These use 0-based indexing as in C.                   
   `a_vector'           `double[aord_num + 1][type_nucl_num]'  a polynomial coefficients                                                     
   `b_vector'           `double[bord_num + 1]'                 b polynomial coefficients                                                     
   `c_vector'           `double[dim_c_vector][type_nucl_num]'  c polynomial coefficients                                                     
   `c_vector'           `double[dim_c_vector][type_nucl_num]'  c polynomial coefficients                                                     
   `spin_independent'   `int32_t'                              If 1, use same parameters for parallel and anti-parallel spins. Otherwise, 0. 
  -------------------------------------------------------------------------------------------------------------------------------------------

  Computed data:

  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
   Variable                        Type                                                             In/Out                                                                                                  
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
   `dim_c_vector'                  `int64_t'                                                        Number of unique C coefficients                                                                         
   `dim_c_vector_date'             `uint64_t'                                                       Number of unique C coefficients                                                                         
   `asymp_jasa'                    `double[type_nucl_num]'                                          Asymptotic component                                                                                    
   `asymp_jasa_date'               `uint64_t'                                                       Ladt modification of the asymptotic component                                                           
   `asymp_jasb'                    `double[2]'                                                      Asymptotic component (up- or down-spin)                                                                 
   `asymp_jasb_date'               `uint64_t'                                                       Ladt modification of the asymptotic component                                                           
   `c_vector_full'                 `double[dim_c_vector][nucl_num]'                                 vector of non-zero coefficients                                                                         
   `c_vector_full_date'            `uint64_t'                                                       Keep track of changes here                                                                              
   `lkpm_combined_index'           `int64_t[4][dim_c_vector]'                                       Transform l,k,p, and m into consecutive indices                                                         
   `lkpm_combined_index_date'      `uint64_t'                                                       Transform l,k,p, and m into consecutive indices                                                         
   `tmp_c'                         `double[walk_num][cord_num][cord_num+1][nucl_num][elec_num]'     vector of non-zero coefficients                                                                         
   `dtmp_c'                        `double[walk_num][elec_num][4][nucl_num][cord_num+1][cord_num]'  vector of non-zero coefficients                                                                         
   `ee_distance_rescaled'          `double[walk_num][num][num]'                                     Electron-electron rescaled distances                                                                    
   `ee_distance_rescaled_date'     `uint64_t'                                                       Last modification date of the electron-electron distances                                               
   `ee_distance_rescaled_gl'       `double[walk_num][num][num][4]'                                  Electron-electron rescaled distances derivatives                                                        
   `ee_distance_rescaled_gl_date'  `uint64_t'                                                       Last modification date of the electron-electron distance derivatives                                    
   `en_distance_rescaled'          `double[walk_num][nucl_num][num]'                                Electron-nucleus distances                                                                              
   `en_distance_rescaled_date'     `uint64_t'                                                       Last modification date of the electron-electron distances                                               
   `en_distance_rescaled_gl'       `double[walk_num][nucl_num][num][4]'                             Electron-electron rescaled distances derivatives                                                        
   `en_distance_rescaled_gl_date'  `uint64_t'                                                       Last modification date of the electron-electron distance derivatives                                    
   `een_rescaled_n'                `double[walk_num][cord_num+1][nucl_num][elec_num]'               The electron-electron rescaled distances raised to the powers defined by cord                           
   `een_rescaled_n_date'           `uint64_t'                                                       Keep track of the date of creation                                                                      
   `een_rescaled_e_gl'             `double[walk_num][cord_num+1][elec_num][4][elec_num]'            The electron-electron rescaled distances raised to the powers defined by cord derivatives wrt electrons 
   `een_rescaled_e_gl_date'        `uint64_t'                                                       Keep track of the date of creation                                                                      
   `een_rescaled_n_gl'             `double[walk_num][cord_num+1][nucl_num][4][elec_num]'            The electron-electron rescaled distances raised to the powers defined by cord derivatives wrt electrons 
   `een_rescaled_n_gl_date'        `uint64_t'                                                       Keep track of the date of creation                                                                      
   `factor_ee'                     `double[walk_num]'                                               Jastrow factor: electron-electron part                                                                  
   `factor_ee_date'                `uint64_t'                                                       Jastrow factor: electron-electron part                                                                  
   `factor_en'                     `double[walk_num]'                                               Jastrow factor: electron-nucleus  part                                                                  
   `factor_en_date'                `uint64_t'                                                       Jastrow factor: electron-nucleus  part                                                                  
   `factor_een'                    `double[walk_num]'                                               Jastrow factor: electron-electron-nucleus  part                                                         
   `factor_een_date'               `uint64_t'                                                       Jastrow factor: electron-electron-nucleus  part                                                         
   `factor_ee_gl'                  `double[walk_num][4][elec_num]'                                  Derivative of the Jastrow factor: electron-electron-nucleus  part                                       
   `factor_ee_gl_date'             `uint64_t'                                                       Keep track of the date for the derivative                                                               
   `factor_en_gl'                  `double[walk_num][4][elec_num]'                                  Derivative of the Jastrow factor: electron-electron-nucleus  part                                       
   `factor_en_gl_date'             `uint64_t'                                                       Keep track of the date for the en derivative                                                            
   `factor_een_gl'                 `double[walk_num][4][elec_num]'                                  Derivative of the Jastrow factor: electron-electron-nucleus  part                                       
   `factor_een_gl_date'            `uint64_t'                                                       Keep track of the date for the een derivative                                                           
   `factor_een_grad'               `double[walk_num][3][elec_num]'                                  Gradient of the Jastrow factor: electron-electron-nucleus  part                                         
   `factor_een_grad_date'          `uint64_t'                                                       Keep track of the date for the een derivative                                                           
   `value'                         `double[walk_num]'                                               Value of the Jastrow factor                                                                             
   `value_date'                    `uint64_t'                                                       Keep track of the date                                                                                  
   `gl'                            `double[walk_num][4][elec_num]'                                  Gradient and Laplacian of the Jastrow factor                                                            
   `grad'                          `double[walk_num][3][elec_num]'                                  Gradient of the Jastrow factor                                                                          
   `value_date'                    `uint64_t'                                                       Keep track of the date                                                                                  
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


2.1 Data structure
~~~~~~~~~~~~~~~~~~

  ,----
  | typedef struct qmckl_jastrow_champ_struct{
  |   int64_t * restrict lkpm_combined_index;
  |   int64_t * restrict type_nucl_vector;
  |   double  * restrict asymp_jasa;
  |   double             asymp_jasb[2];
  |   double  * restrict a_vector;
  |   double  * restrict b_vector;
  |   double  * restrict c_vector;
  |   double  * restrict c_vector_full;
  |   double  * restrict dtmp_c;
  |   double  * restrict ee_distance_rescaled;
  |   double  * restrict ee_distance_rescaled_gl;
  |   double  * restrict een_rescaled_e;
  |   double  * restrict een_rescaled_e_gl;
  |   double  * restrict een_rescaled_n;
  |   double  * restrict een_rescaled_n_gl;
  |   double  * restrict en_distance_rescaled;
  |   double  * restrict en_distance_rescaled_gl;
  |   double  * restrict factor_ee;
  |   double  * restrict factor_ee_gl;
  |   double  * restrict factor_een;
  |   double  * restrict factor_een_gl;
  |   double  * restrict factor_een_grad;
  |   double  * restrict factor_en;
  |   double  * restrict factor_en_gl;
  |   double  * restrict rescale_factor_en;
  |   double  * restrict tmp_c;
  |   double  * restrict value;
  |   double  * restrict gl;
  |   double  * restrict grad;
  |   int64_t   aord_num;
  |   int64_t   bord_num;
  |   int64_t   cord_num;
  |   int64_t   dim_c_vector;
  |   int64_t   type_nucl_num;
  |   uint64_t  asymp_jasa_date;
  |   uint64_t  asymp_jasb_date;
  |   uint64_t  c_vector_full_date;
  |   uint64_t  dim_c_vector_date;
  |   uint64_t  dtmp_c_date;
  |   uint64_t  ee_distance_rescaled_date;
  |   uint64_t  ee_distance_rescaled_gl_date;
  |   uint64_t  een_rescaled_e_date;
  |   uint64_t  een_rescaled_e_gl_date;
  |   uint64_t  een_rescaled_n_date;
  |   uint64_t  een_rescaled_n_gl_date;
  |   uint64_t  en_distance_rescaled_date;
  |   uint64_t  en_distance_rescaled_gl_date;
  |   uint64_t  factor_ee_date;
  |   uint64_t  factor_ee_gl_date;
  |   uint64_t  factor_een_date;
  |   uint64_t  factor_een_gl_date;
  |   uint64_t  factor_een_grad_date;
  |   uint64_t  factor_en_date;
  |   uint64_t  factor_en_gl_date;
  |   uint64_t  lkpm_combined_index_date;
  |   uint64_t  tmp_c_date;
  |   uint64_t  value_date;
  |   uint64_t  gl_date;
  |   uint64_t  grad_date;
  |   double    rescale_factor_ee;
  |   int32_t   uninitialized;
  |   int32_t   spin_independent;
  |   bool      provided;
  | 
  | } qmckl_jastrow_champ_struct;
  `----

  The `uninitialized' integer contains one bit set to one for each
  initialization function which has not been called. It becomes equal to
  zero after all initialization functions have been called. The struct
  is then initialized and `provided == true'.  Some values are
  initialized by default, and are not concerned by this mechanism.

  ,----
  | qmckl_exit_code qmckl_init_jastrow_champ(qmckl_context context);
  `----

  ,----
  | qmckl_exit_code qmckl_init_jastrow_champ(qmckl_context context) {
  | 
  |   if (qmckl_context_check(context) == QMCKL_NULL_CONTEXT) {
  |     return false;
  |   }
  | 
  |   qmckl_context_struct* const ctx = (qmckl_context_struct*) context;
  |   assert (ctx != NULL);
  | 
  |   ctx->jastrow_champ.uninitialized = (1 << 11) - 1;
  | 
  |   /* Default values */
  |   ctx->jastrow_champ.aord_num = -1;
  |   ctx->jastrow_champ.bord_num = -1;
  |   ctx->jastrow_champ.cord_num = -1;
  |   ctx->jastrow_champ.dim_c_vector = -1;
  |   ctx->jastrow_champ.type_nucl_num = -1;
  |   ctx->jastrow_champ.spin_independent = -1;
  | 
  |   return QMCKL_SUCCESS;
  | }
  `----


2.2 Initialization functions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  To prepare for the Jastrow and its derivative, all the following
  functions need to be called.

  ,----
  | qmckl_exit_code  qmckl_set_jastrow_champ_rescale_factor_ee (qmckl_context context, const double  kappa_ee);
  | qmckl_exit_code  qmckl_set_jastrow_champ_rescale_factor_en (qmckl_context context, const double* kappa_en, const int64_t size_max);
  | qmckl_exit_code  qmckl_set_jastrow_champ_aord_num          (qmckl_context context, const int64_t aord_num);
  | qmckl_exit_code  qmckl_set_jastrow_champ_bord_num          (qmckl_context context, const int64_t bord_num);
  | qmckl_exit_code  qmckl_set_jastrow_champ_cord_num          (qmckl_context context, const int64_t cord_num);
  | qmckl_exit_code  qmckl_set_jastrow_champ_type_nucl_num     (qmckl_context context, const int64_t type_nucl_num);
  | qmckl_exit_code  qmckl_set_jastrow_champ_type_nucl_vector  (qmckl_context context, const int64_t* type_nucl_vector, const int64_t size_max);
  | qmckl_exit_code  qmckl_set_jastrow_champ_a_vector          (qmckl_context context, const double * a_vector, const int64_t size_max);
  | qmckl_exit_code  qmckl_set_jastrow_champ_b_vector          (qmckl_context context, const double * b_vector, const int64_t size_max);
  | qmckl_exit_code  qmckl_set_jastrow_champ_c_vector          (qmckl_context context, const double * c_vector, const int64_t size_max);
  | qmckl_exit_code  qmckl_set_jastrow_champ_spin_independent  (qmckl_context context, const int32_t spin_independent);
  `----

  When the required information is completely entered, other data
  structures are computed to accelerate the calculations. The
  intermediates factors are precontracted using BLAS LEVEL 3 operations.


2.2.0.1 Fortran interface

  ,----
  | interface
  |    integer(qmckl_exit_code) function qmckl_set_jastrow_champ_rescale_factor_ee (context, &
  |         kappa_ee) bind(C)
  |      use, intrinsic :: iso_c_binding
  |      import
  |      implicit none
  |      integer (qmckl_context) , intent(in)  , value :: context
  |      real(c_double),   intent(in), value  :: kappa_ee
  |    end function qmckl_set_jastrow_champ_rescale_factor_ee
  | 
  |    integer(qmckl_exit_code) function qmckl_set_jastrow_champ_rescale_factor_en (context, &
  |         kappa_en, size_max) bind(C)
  |      use, intrinsic :: iso_c_binding
  |      import
  |      implicit none
  |      integer (qmckl_context) , intent(in)  , value :: context
  |      integer(c_int64_t), intent(in), value  :: size_max
  |      real(c_double),   intent(in) :: kappa_en(size_max)
  |    end function qmckl_set_jastrow_champ_rescale_factor_en
  | 
  |    integer(qmckl_exit_code) function qmckl_set_jastrow_champ_aord_num (context, &
  |         aord_num) bind(C)
  |      use, intrinsic :: iso_c_binding
  |      import
  |      implicit none
  |      integer (qmckl_context) , intent(in)  , value :: context
  |      integer(c_int64_t), intent(in), value  :: aord_num
  |    end function qmckl_set_jastrow_champ_aord_num
  | 
  |    integer(qmckl_exit_code) function qmckl_set_jastrow_champ_bord_num (context, &
  |         bord_num) bind(C)
  |      use, intrinsic :: iso_c_binding
  |      import
  |      implicit none
  |      integer (qmckl_context) , intent(in)  , value :: context
  |      integer(c_int64_t), intent(in), value  :: bord_num
  |    end function qmckl_set_jastrow_champ_bord_num
  | 
  |    integer(qmckl_exit_code) function qmckl_set_jastrow_champ_cord_num (context, &
  |         cord_num) bind(C)
  |      use, intrinsic :: iso_c_binding
  |      import
  |      implicit none
  |      integer (qmckl_context) , intent(in)  , value :: context
  |      integer(c_int64_t), intent(in), value  :: cord_num
  |    end function qmckl_set_jastrow_champ_cord_num
  | 
  |    integer(qmckl_exit_code) function qmckl_set_jastrow_champ_type_nucl_num (context, &
  |         type_nucl_num) bind(C)
  |      use, intrinsic :: iso_c_binding
  |      import
  |      implicit none
  |      integer (qmckl_context) , intent(in)  , value :: context
  |      integer(c_int64_t), intent(in), value  :: type_nucl_num
  |    end function qmckl_set_jastrow_champ_type_nucl_num
  | 
  |    integer(qmckl_exit_code) function qmckl_set_jastrow_champ_type_nucl_vector (context, &
  |         type_nucl_vector, size_max) bind(C)
  |      use, intrinsic :: iso_c_binding
  |      import
  |      implicit none
  |      integer (qmckl_context) , intent(in)  , value :: context
  |      integer(c_int64_t), intent(in), value  :: size_max
  |      integer(c_int64_t), intent(in) :: type_nucl_vector(size_max)
  |    end function qmckl_set_jastrow_champ_type_nucl_vector
  | 
  |    integer(qmckl_exit_code) function qmckl_set_jastrow_champ_a_vector(context, &
  |         a_vector, size_max) bind(C)
  |      use, intrinsic :: iso_c_binding
  |      import
  |      implicit none
  |      integer (qmckl_context) , intent(in)  , value :: context
  |      integer(c_int64_t), intent(in), value  :: size_max
  |      real(c_double),   intent(in) :: a_vector(size_max)
  |    end function qmckl_set_jastrow_champ_a_vector
  | 
  |    integer(qmckl_exit_code) function qmckl_set_jastrow_champ_b_vector(context, &
  |         b_vector, size_max) bind(C)
  |      use, intrinsic :: iso_c_binding
  |      import
  |      implicit none
  |      integer (qmckl_context) , intent(in)  , value :: context
  |      integer(c_int64_t), intent(in), value  :: size_max
  |      real(c_double),   intent(in) :: b_vector(size_max)
  |    end function qmckl_set_jastrow_champ_b_vector
  | 
  |    integer(qmckl_exit_code) function qmckl_set_jastrow_champ_c_vector(context, &
  |         c_vector, size_max) bind(C)
  |      use, intrinsic :: iso_c_binding
  |      import
  |      implicit none
  |      integer (qmckl_context) , intent(in)  , value :: context
  |      integer(c_int64_t), intent(in), value  :: size_max
  |      real(c_double),   intent(in) :: c_vector(size_max)
  |    end function qmckl_set_jastrow_champ_c_vector
  | 
  |    integer(qmckl_exit_code) function qmckl_set_jastrow_champ_spin_independent(context, &
  |         spin_independent) bind(C)
  |      use, intrinsic :: iso_c_binding
  |      import
  |      implicit none
  |      integer(qmckl_context) , intent(in)  , value :: context
  |      integer(c_int32_t),    intent(in), value  :: spin_independent
  |    end function qmckl_set_jastrow_champ_spin_independent
  | 
  | end interface
  `----


2.3 Access functions
~~~~~~~~~~~~~~~~~~~~

  Along with these core functions, calculation of the jastrow factor
  requires the following additional information to be set:


  When all the data for the AOs have been provided, the following
  function returns `true'.

  ,----
  | bool      qmckl_jastrow_champ_provided           (const qmckl_context context);
  `----


2.3.0.1 Fortran interface

  ,----
  | interface
  |    integer(qmckl_exit_code) function qmckl_get_jastrow_champ_rescale_factor_ee (context, &
  |         kappa_ee) bind(C)
  |      use, intrinsic :: iso_c_binding
  |      import
  |      implicit none
  |      integer (qmckl_context) , intent(in)  , value :: context
  |      real(c_double),   intent(out) :: kappa_ee
  |    end function qmckl_get_jastrow_champ_rescale_factor_ee
  | 
  |    integer(qmckl_exit_code) function qmckl_get_jastrow_champ_rescale_factor_en (context, &
  |         kappa_en, size_max) bind(C)
  |      use, intrinsic :: iso_c_binding
  |      import
  |      implicit none
  |      integer (qmckl_context) , intent(in), value :: context
  |      integer(c_int64_t), intent(in), value       :: size_max
  |      real(c_double),   intent(out)               :: kappa_en(size_max)
  |    end function qmckl_get_jastrow_champ_rescale_factor_en
  | 
  |    integer(qmckl_exit_code) function qmckl_get_jastrow_champ_aord_num (context, &
  |         aord_num) bind(C)
  |      use, intrinsic :: iso_c_binding
  |      import
  |      implicit none
  |      integer (qmckl_context) , intent(in), value :: context
  |      integer(c_int64_t), intent(out)             :: aord_num
  |    end function qmckl_get_jastrow_champ_aord_num
  | 
  |    integer(qmckl_exit_code) function qmckl_get_jastrow_champ_bord_num (context, &
  |         bord_num) bind(C)
  |      use, intrinsic :: iso_c_binding
  |      import
  |      implicit none
  |      integer (qmckl_context) , intent(in), value :: context
  |      integer(c_int64_t), intent(out)             :: bord_num
  |    end function qmckl_get_jastrow_champ_bord_num
  | 
  |    integer(qmckl_exit_code) function qmckl_get_jastrow_champ_cord_num (context, &
  |         cord_num) bind(C)
  |      use, intrinsic :: iso_c_binding
  |      import
  |      implicit none
  |      integer (qmckl_context) , intent(in), value :: context
  |      integer(c_int64_t), intent(out)             :: cord_num
  |    end function qmckl_get_jastrow_champ_cord_num
  | 
  |    integer(qmckl_exit_code) function qmckl_get_jastrow_champ_type_nucl_num (context, &
  |         type_nucl_num) bind(C)
  |      use, intrinsic :: iso_c_binding
  |      import
  |      implicit none
  |      integer (qmckl_context) , intent(in), value :: context
  |      integer(c_int64_t), intent(out)              :: type_nucl_num
  |    end function qmckl_get_jastrow_champ_type_nucl_num
  | 
  |    integer(qmckl_exit_code) function qmckl_get_jastrow_champ_type_nucl_vector (context, &
  |         type_nucl_vector, size_max) bind(C)
  |      use, intrinsic :: iso_c_binding
  |      import
  |      implicit none
  |      integer (qmckl_context), intent(in), value :: context
  |      integer(c_int64_t), intent(in), value      :: size_max
  |      integer(c_int64_t), intent(out)            :: type_nucl_vector(size_max)
  |    end function qmckl_get_jastrow_champ_type_nucl_vector
  | 
  |    integer(qmckl_exit_code) function qmckl_get_jastrow_champ_a_vector(context, &
  |         a_vector, size_max) bind(C)
  |      use, intrinsic :: iso_c_binding
  |      import
  |      implicit none
  |      integer (qmckl_context) , intent(in), value :: context
  |      integer(c_int64_t), intent(in), value       :: size_max
  |      real(c_double),   intent(out)               :: a_vector(size_max)
  |    end function qmckl_get_jastrow_champ_a_vector
  | 
  |    integer(qmckl_exit_code) function qmckl_get_jastrow_champ_b_vector(context, &
  |         b_vector, size_max) bind(C)
  |      use, intrinsic :: iso_c_binding
  |      import
  |      implicit none
  |      integer (qmckl_context) , intent(in)  , value :: context
  |      integer(c_int64_t), intent(in), value         :: size_max
  |      real(c_double),   intent(out)                 :: b_vector(size_max)
  |    end function qmckl_get_jastrow_champ_b_vector
  | 
  |    integer(qmckl_exit_code) function qmckl_get_jastrow_champ_c_vector(context, &
  |         c_vector, size_max) bind(C)
  |      use, intrinsic :: iso_c_binding
  |      import
  |      implicit none
  |      integer (qmckl_context) , intent(in)  , value :: context
  |      integer(c_int64_t), intent(in), value         :: size_max
  |      real(c_double),   intent(out)                 :: c_vector(size_max)
  |    end function qmckl_get_jastrow_champ_c_vector
  | 
  |    integer(qmckl_exit_code) function qmckl_get_jastrow_champ_spin_independent(context, &
  |         spin_independent) bind(C)
  |      use, intrinsic :: iso_c_binding
  |      import
  |      implicit none
  |      integer(qmckl_context) , intent(in)  , value :: context
  |      integer(c_int32_t),   intent(out)                :: spin_independent
  |    end function qmckl_get_jastrow_champ_spin_independent
  | 
  | end interface
  `----


3 Computation
=============

  The computed data is stored in the context so that it can be reused by
  different kernels. To ensure that the data is valid, for each computed
  data the date of the context is stored when it is computed.  To know
  if some data needs to be recomputed, we check if the date of the
  dependencies are more recent than the date of the data to compute. If
  it is the case, then the data is recomputed and the current date is
  stored.


3.1 Electron-electron component
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

3.1.1 Asymptotic component
--------------------------

  Calculate the asymptotic component `asymp_jasb' to be subtracted from
  the electron-electron jastrow factor \(J_{\text{ee}}\). Two values are
  computed. The first one is for parallel spin pairs, and the second one
  for antiparallel spin pairs.  If the `spin_independent' variable is
  set to `1', then $\delta^{\uparrow \downarrow}$ is always equal to
  one.

  \[ J_{\text{ee}}^{\infty} = \frac{\frac{1}{2}(1+\delta^{\uparrow
     \downarrow})\,b_1 \kappa_\text{ee}^{-1}}{1 + b_2\,
     \kappa_\text{ee}^{-1}} + \sum_{p=2}^{N_\text{ord}^b} b_{p+1}\,
     \kappa_\text{ee}^{-p} \]


3.1.1.1 Get

  ,----
  | qmckl_exit_code
  | qmckl_get_jastrow_champ_asymp_jasb(qmckl_context context,
  |                              double* const asymp_jasb,
  |                              const int64_t size_max);
  `----


* 3.1.1.1.1 Fortran interface

  ,----
  | interface
  |    integer(qmckl_exit_code) function qmckl_get_jastrow_champ_asymp_jasb(context, &
  |         asymp_jasb, size_max) bind(C)
  |      use, intrinsic :: iso_c_binding
  |      import
  |      implicit none
  |      integer (qmckl_context) , intent(in), value :: context
  |      integer(c_int64_t), intent(in), value       :: size_max
  |      real(c_double),   intent(out)               :: asymp_jasb(size_max)
  |    end function qmckl_get_jastrow_champ_asymp_jasb
  | end interface
  `----


3.1.1.2 Compute

  ---------------------------------------------------------------------------------------------------------------
   Variable             Type                  In/Out  Description                                                
  ---------------------------------------------------------------------------------------------------------------
   `context'            `qmckl_context'       in      Global state                                               
   `bord_num'           `int64_t'             in      Order of the polynomial                                    
   `b_vector'           `double[bord_num+1]'  in      Values of b                                                
   `rescale_factor_ee'  `double'              in      Electron coordinates                                       
   `spin_independent'   `int32_t'             in      If 1, same parameters for parallel and anti-parallel pairs 
   `asymp_jasb'         `double[2]'           out     Asymptotic value                                           
  ---------------------------------------------------------------------------------------------------------------

  ,----
  | function qmckl_compute_jastrow_champ_asymp_jasb_doc(context, &
  |      bord_num, b_vector, rescale_factor_ee, spin_independent, asymp_jasb) &
  |      bind(C) result(info)
  |   use qmckl
  |   implicit none
  | 
  |   integer (qmckl_context) , intent(in)  , value :: context
  |   integer (c_int64_t) , intent(in)  , value :: bord_num
  |   real    (c_double ) , intent(in)          :: b_vector(bord_num+1)
  |   real    (c_double ) , intent(in)  , value :: rescale_factor_ee
  |   integer (c_int32_t) , intent(in)  , value :: spin_independent
  |   real    (c_double ) , intent(out)         :: asymp_jasb(2)
  |   integer(qmckl_exit_code)                  :: info
  | 
  |   integer*8 :: i, p
  |   double precision   :: kappa_inv, x, asym_one
  |   kappa_inv = 1.0d0 / rescale_factor_ee
  | 
  |   info = QMCKL_SUCCESS
  | 
  |   if (context == QMCKL_NULL_CONTEXT) then
  |      info = QMCKL_INVALID_CONTEXT
  |      return
  |   endif
  | 
  |   if (bord_num < 0) then
  |      info = QMCKL_INVALID_ARG_2
  |      return
  |   endif
  | 
  |   asym_one = b_vector(1) * kappa_inv / (1.0d0 + b_vector(2) * kappa_inv)
  |   if (spin_independent == 1) then
  |      asymp_jasb(:) = (/asym_one, asym_one/)
  |   else
  |      asymp_jasb(:) = (/0.5d0*asym_one, asym_one/)
  |   end if
  | 
  |   x = kappa_inv
  |   do p = 2, bord_num
  |      x = x * kappa_inv
  |      do i = 1, 2
  |         asymp_jasb(i) = asymp_jasb(i) + b_vector(p + 1) * x
  |      end do
  |   end do
  | 
  | end function qmckl_compute_jastrow_champ_asymp_jasb_doc
  `----

  ,----
  | qmckl_exit_code
  | qmckl_compute_jastrow_champ_asymp_jasb_hpc (const qmckl_context context,
  |                                             const int64_t bord_num,
  |                                             const double* b_vector,
  |                                             const double rescale_factor_ee,
  |                                             const int32_t spin_independent,
  |                                             double* const asymp_jasb )
  | {
  | 
  |   if (context == QMCKL_NULL_CONTEXT) {
  |     return QMCKL_INVALID_CONTEXT;
  |   }
  | 
  |   if (bord_num < 0) {
  |     return QMCKL_INVALID_ARG_2;
  |   }
  | 
  |   const double kappa_inv = 1.0 / rescale_factor_ee;
  |   const double asym_one = b_vector[0] * kappa_inv / (1.0 + b_vector[1] * kappa_inv);
  | 
  |   double f = 0.;
  |   double x = kappa_inv;
  |   for (int k = 2; k <= bord_num; ++k) {
  |     x *= kappa_inv;
  |     f = f + b_vector[k]*x;
  |   }
  | 
  |   asymp_jasb[0] = spin_independent == 1 ? asym_one + f : 0.5 * asym_one + f;
  |   asymp_jasb[1] = asym_one + f;
  | 
  |   return QMCKL_SUCCESS;
  | }
  `----


  ,----
  | qmckl_exit_code qmckl_compute_jastrow_champ_asymp_jasb (const qmckl_context context,
  |                                                         const int64_t bord_num,
  |                                                         const double* b_vector,
  |                                                         const double rescale_factor_ee,
  |                                                         const int32_t spin_independent,
  |                                                         double* const asymp_jasb )
  | {
  | #ifdef HAVE_HPC
  |   return qmckl_compute_jastrow_champ_asymp_jasb_hpc
  | #else
  |   return qmckl_compute_jastrow_champ_asymp_jasb_doc
  | #endif
  |     (context, bord_num, b_vector, rescale_factor_ee, spin_independent, asymp_jasb);
  | }
  `----


3.1.2 Electron-electron rescaled distances
------------------------------------------

  `ee_distance_rescaled' stores the matrix of the rescaled distances
  between all pairs of electrons:

  \[ C_{ij} = \frac{ 1 - e^{-\kappa r_{ij}}}{\kappa} \]

  where \(r_{ij}\) is the matrix of electron-electron distances.


3.1.2.1 Get

  ,----
  | qmckl_exit_code qmckl_get_jastrow_champ_ee_distance_rescaled(qmckl_context context,
  |                                                              double* const distance_rescaled,
  |                                                              int64_t const size_max);
  `----


3.1.2.2 Compute

  -----------------------------------------------------------------------------------------------------------
   Variable             Type                                    In/Out  Description                          
  -----------------------------------------------------------------------------------------------------------
   `context'            `qmckl_context'                         in      Global state                         
   `elec_num'           `int64_t'                               in      Number of electrons                  
   `rescale_factor_ee'  `double'                                in      Factor to rescale ee distances       
   `walk_num'           `int64_t'                               in      Number of walkers                    
   `coord'              `double[3][walk_num][elec_num]'         in      Electron coordinates                 
   `ee_distance'        `double[walk_num][elec_num][elec_num]'  out     Electron-electron rescaled distances 
  -----------------------------------------------------------------------------------------------------------

  ,----
  | function qmckl_compute_ee_distance_rescaled_doc(context, &
  |      elec_num, rescale_factor_ee, walk_num, &
  |      coord, ee_distance_rescaled) &
  |      bind(C) result(info)
  |   use qmckl
  |   implicit none
  | 
  |   integer(qmckl_context), intent(in), value :: context
  |   integer (c_int64_t) , intent(in)  , value :: elec_num
  |   real    (c_double ) , intent(in)  , value :: rescale_factor_ee
  |   integer (c_int64_t) , intent(in)  , value :: walk_num
  |   real    (c_double ) , intent(in)          :: coord(elec_num,walk_num,3)
  |   real    (c_double ) , intent(out)         :: ee_distance_rescaled(elec_num,elec_num,walk_num)
  |   integer(qmckl_exit_code)                  :: info
  | 
  |   integer*8 :: k
  | 
  |   info = QMCKL_SUCCESS
  | 
  |   if (context == QMCKL_NULL_CONTEXT) then
  |      info = QMCKL_INVALID_CONTEXT
  |      return
  |   endif
  | 
  |   if (elec_num <= 0) then
  |      info = QMCKL_INVALID_ARG_2
  |      return
  |   endif
  | 
  |   if (walk_num <= 0) then
  |      info = QMCKL_INVALID_ARG_3
  |      return
  |   endif
  | 
  |   do k=1,walk_num
  |      info = qmckl_distance_rescaled(context, 'T', 'T', elec_num, elec_num, &
  |           coord(1,k,1), elec_num * walk_num, &
  |           coord(1,k,1), elec_num * walk_num, &
  |           ee_distance_rescaled(1,1,k), elec_num, rescale_factor_ee)
  |      if (info /= QMCKL_SUCCESS) then
  |         exit
  |      endif
  |   end do
  | 
  | end function qmckl_compute_ee_distance_rescaled_doc
  `----


3.1.3 Electron-electron rescaled distance gradients and Laplacian with respect to electron coordinates
------------------------------------------------------------------------------------------------------

  The rescaled distances, represented by $C_{ij} = (1 -
  e^{-\kappa_\text{e} r_{ij}})/\kappa_\text{e}$ are differentiated with
  respect to the electron coordinates.  This information is stored in
  the tensor `ee_distance_rescaled_gl'. The initial three sequential
  elements of this three-dimensional tensor provide the $x$, $y$, and
  $z$ direction derivatives, while the fourth index corresponds to the
  Laplacian.


3.1.3.1 Get

  ,----
  | qmckl_exit_code qmckl_get_jastrow_champ_ee_distance_rescaled_gl(qmckl_context context,
  |                                                                 double* const distance_rescaled_gl,
  |                                                                 const int64_t size_max);
  `----


3.1.3.2 Compute

  -------------------------------------------------------------------------------------------------------------------------------
   Variable                   Type                                       In/Out  Description                                     
  -------------------------------------------------------------------------------------------------------------------------------
   `context'                  `qmckl_context'                            in      Global state                                    
   `elec_num'                 `int64_t'                                  in      Number of electrons                             
   `rescale_factor_ee'        `double'                                   in      Factor to rescale ee distances                  
   `walk_num'                 `int64_t'                                  in      Number of walkers                               
   `coord'                    `double[3][walk_num][elec_num]'            in      Electron coordinates                            
   `ee_distance_rescaled_gl'  `double[walk_num][elec_num][elec_num][4]'  out     Electron-electron rescaled distance derivatives 
  -------------------------------------------------------------------------------------------------------------------------------

  ,----
  | function qmckl_compute_ee_distance_rescaled_gl_doc(context,  &
  |      elec_num, rescale_factor_ee, walk_num, coord, ee_distance_rescaled_gl) &
  |      bind(C) result(info)
  |   use qmckl
  |   implicit none
  | 
  |   integer(qmckl_context), intent(in), value :: context
  |   integer (c_int64_t) , intent(in)  , value :: elec_num
  |   real    (c_double ) , intent(in)  , value :: rescale_factor_ee
  |   integer (c_int64_t) , intent(in)  , value :: walk_num
  |   real    (c_double ) , intent(in)          :: coord(elec_num,walk_num,3)
  |   real    (c_double ) , intent(out)         :: ee_distance_rescaled_gl(4,elec_num,elec_num,walk_num)
  |   integer(qmckl_exit_code)                  :: info
  | 
  |   integer*8 :: k
  | 
  |   info = QMCKL_SUCCESS
  | 
  |   if (context == QMCKL_NULL_CONTEXT) then
  |      info = QMCKL_INVALID_CONTEXT
  |      return
  |   endif
  | 
  |   if (elec_num <= 0) then
  |      info = QMCKL_INVALID_ARG_2
  |      return
  |   endif
  | 
  |   if (walk_num <= 0) then
  |      info = QMCKL_INVALID_ARG_3
  |      return
  |   endif
  | 
  |   do k=1,walk_num
  |      info = qmckl_distance_rescaled_gl(context, 'T', 'T', elec_num, elec_num, &
  |           coord(1,k,1), elec_num*walk_num, &
  |           coord(1,k,1), elec_num*walk_num, &
  |           ee_distance_rescaled_gl(1,1,1,k), elec_num, rescale_factor_ee)
  |      if (info /= QMCKL_SUCCESS) then
  |         exit
  |      endif
  |   end do
  | 
  | end function qmckl_compute_ee_distance_rescaled_gl_doc
  `----


3.1.4 Electron-electron component
---------------------------------

  Calculate the electron-electron jastrow component `factor_ee' using
  the `asymp_jasb' component and the electron-electron rescaled
  distances `ee_distance_rescaled'.  If the `spin_independent' variable
  is set to `1', then $\delta^{\uparrow \downarrow}$ is always equal to
  one.

  \[ f_\text{ee} = \sum_{i,j<i} \left[
       \frac{\delta_{ij}^{\uparrow\downarrow} B_0\, C_{ij}}{1 + B_1\,
       C_{ij}} + \sum_{k=2}^{n_\text{ord}} B_k\, C_{ij}^k -
       {J_{\text{ee}}^{\infty}}_{ij} \right] \]

  $\delta$ is the spin factor, $B$ is the vector of $b$ parameters, $C$
  is the array of rescaled distances.

  $f_{\text{ee}}$ can be rewritten as:

  \[ f_\text{ee} = \frac{1}{2} \left[ \sum_{i,j}
       \frac{\delta_{ij}^{\uparrow\downarrow} B_0\, C_{ij}}{1 + B_1\,
       C_{ij}} + \sum_{i,j} \sum_{k=2}^{n_\text{ord}} B_k\, C_{ij}^k
       \right] - \left[ \frac{n_\uparrow (n_\uparrow-1) + n_\downarrow
       (n_\downarrow-1)}{2}\, J_{\text{ee}}^{\infty}}_{\uparrow
       \uparrow} + n_\uparrow\,n_\downarrow\,
       J_{\text{ee}}^{\infty}}_{\uparrow \downarrow} \right] \]


3.1.4.1 Get

  ,----
  | qmckl_exit_code
  | qmckl_get_jastrow_champ_factor_ee(qmckl_context context,
  |                             double* const factor_ee,
  |                             const int64_t size_max);
  `----


* 3.1.4.1.1 Fortran interface

  ,----
  | interface
  |    integer(qmckl_exit_code) function qmckl_get_jastrow_champ_factor_ee (context, &
  |         factor_ee, size_max) bind(C)
  |      use, intrinsic :: iso_c_binding
  |      import
  |      implicit none
  |      integer (qmckl_context) , intent(in), value :: context
  |      integer(c_int64_t), intent(in), value       :: size_max
  |      real(c_double),   intent(out)               :: factor_ee(size_max)
  |    end function qmckl_get_jastrow_champ_factor_ee
  | end interface
  `----


3.1.4.2 Compute

  ---------------------------------------------------------------------------------------------------------
   Variable                Type                                    In/Out  Description                     
  ---------------------------------------------------------------------------------------------------------
   `context'               `qmckl_context'                         in      Global state                    
   `walk_num'              `int64_t'                               in      Number of walkers               
   `elec_num'              `int64_t'                               in      Number of electrons             
   `up_num'                `int64_t'                               in      Number of alpha electrons       
   `bord_num'              `int64_t'                               in      Number of coefficients          
   `b_vector'              `double[bord_num+1]'                    in      List of coefficients            
   `ee_distance_rescaled'  `double[walk_num][elec_num][elec_num]'  in      Electron-electron distances     
   `asymp_jasb'            `double[2]'                             in      Asymptotic value of the Jastrow 
   `factor_ee'             `double[walk_num]'                      out     $f_{ee}$                        
  ---------------------------------------------------------------------------------------------------------

  ,----
  | function qmckl_compute_jastrow_champ_factor_ee_doc(context, &
  |      walk_num, elec_num, up_num, bord_num, b_vector, &
  |      ee_distance_rescaled, asymp_jasb, spin_independent, factor_ee) &
  |      bind(C) result(info)
  |   use qmckl
  |   implicit none
  | 
  |   integer (qmckl_context), intent(in), value :: context
  |   integer (c_int64_t)    , intent(in), value :: walk_num
  |   integer (c_int64_t)    , intent(in), value :: elec_num
  |   integer (c_int64_t)    , intent(in), value :: up_num
  |   integer (c_int64_t)    , intent(in), value :: bord_num
  |   real    (c_double )    , intent(in)        :: b_vector(bord_num+1)
  |   real    (c_double )    , intent(in)        :: ee_distance_rescaled(elec_num,elec_num,walk_num)
  |   real    (c_double )    , intent(in)        :: asymp_jasb(2)
  |   integer (c_int32_t)    , intent(in), value :: spin_independent
  |   real    (c_double )    , intent(out)       :: factor_ee(walk_num)
  |   integer(qmckl_exit_code)                   :: info
  | 
  |   integer*8 :: i, j, k, nw
  |   double precision   :: x, xk
  | 
  |   info = QMCKL_SUCCESS
  | 
  |   if (context == QMCKL_NULL_CONTEXT) then
  |      info = QMCKL_INVALID_CONTEXT
  |      return
  |   endif
  | 
  |   if (walk_num <= 0) then
  |      info = QMCKL_INVALID_ARG_2
  |      return
  |   endif
  | 
  |   if (elec_num <= 0) then
  |      info = QMCKL_INVALID_ARG_3
  |      return
  |   endif
  | 
  |   if (bord_num < 0) then
  |      info = QMCKL_INVALID_ARG_4
  |      return
  |   endif
  | 
  | 
  | 
  |   do nw =1, walk_num
  | 
  |      factor_ee(nw) = 0.0d0
  |      do j=1,elec_num
  |         do i=1,j-1
  |            x = ee_distance_rescaled(i,j,nw)
  |            if (spin_independent == 1) then
  |               factor_ee(nw) = factor_ee(nw) + b_vector(1) * x / (1.d0 + b_vector(2) * x) - asymp_jasb(2)
  |            else
  |               if ( (j <= up_num).or.(i > up_num) ) then
  |                  factor_ee(nw) = factor_ee(nw) + 0.5d0 * b_vector(1) * x / (1.d0 + b_vector(2) * x) - asymp_jasb(1)
  |               else
  |                  factor_ee(nw) = factor_ee(nw) + b_vector(1) * x / (1.d0 + b_vector(2) * x) - asymp_jasb(2)
  |               endif
  |            endif
  | 
  |            xk = x
  |            do k=2,bord_num
  |               xk = xk * x
  |               factor_ee(nw) = factor_ee(nw) + b_vector(k+1)* xk
  |            end do
  |         end do
  |      end do
  | 
  |   end do
  | 
  | end function qmckl_compute_jastrow_champ_factor_ee_doc
  `----

  ,----
  | qmckl_exit_code
  | qmckl_compute_jastrow_champ_factor_ee_hpc (const qmckl_context context,
  |                                            const int64_t walk_num,
  |                                            const int64_t elec_num,
  |                                            const int64_t up_num,
  |                                            const int64_t bord_num,
  |                                            const double* b_vector,
  |                                            const double* ee_distance_rescaled,
  |                                            const double* asymp_jasb,
  |                                            const int32_t spin_independent,
  |                                            double* const factor_ee )
  | {
  | 
  |   if (context == QMCKL_NULL_CONTEXT) {
  |     return QMCKL_INVALID_CONTEXT;
  |   }
  | 
  |   if (walk_num <= 0) {
  |     return QMCKL_INVALID_ARG_2;
  |   }
  | 
  |   if (elec_num <= 0) {
  |     return QMCKL_INVALID_ARG_3;
  |   }
  | 
  |   if (bord_num < 0) {
  |     return QMCKL_INVALID_ARG_4;
  |   }
  | 
  |   const int64_t dn_num = elec_num - up_num;
  |   const double fshift = 0.5 * (double) ((dn_num-1)*dn_num + (up_num-1)*up_num) * asymp_jasb[0] +
  |     (float) (up_num*dn_num) * asymp_jasb[1];
  | 
  | #ifdef HAVE_OPENMP
  |   #pragma omp parallel
  | #endif
  |   for (int nw = 0; nw < walk_num; ++nw) {
  |     double result = 0.;
  | 
  |     size_t ishift = nw * elec_num * elec_num;
  | 
  |     if (spin_independent == 1) {
  | 
  |       for (int j = 0; j < elec_num; ++j ) {
  |         const double* xj = &(ee_distance_rescaled[j * elec_num + ishift]);
  |         for (int i = 0; i < j ; ++i) {
  |           result = result + b_vector[0]*xj[i] / (1. + b_vector[1]*xj[i]);
  |         }
  |       }
  | 
  |     } else {
  | 
  |       for (int j = 0; j < up_num; ++j ) {
  |         const double* xj = &(ee_distance_rescaled[j * elec_num + ishift]);
  |         for (int i = 0; i < j ; ++i) {
  |           result = result + 0.5 * b_vector[0]*xj[i] / (1. + b_vector[1]*xj[i]);
  |         }
  |       }
  | 
  |       for (int j = up_num ; j < elec_num; ++j ) {
  |         const double* xj = &(ee_distance_rescaled[j * elec_num + ishift]);
  |         for (int i = 0; i < up_num; ++i) {
  |           result = result + b_vector[0]*xj[i] / (1. + b_vector[1]*xj[i]);
  |         }
  |         for (int i = up_num ; i < j ; ++i) {
  |           result = result + 0.5 * b_vector[0]*xj[i] / (1. + b_vector[1]*xj[i]);
  |         }
  | 
  |       }
  |     }
  | 
  |     result = result - fshift;
  | 
  |     for (int j=0; j < elec_num; ++j ) {
  |       const double* xj = &(ee_distance_rescaled[j * elec_num + ishift]);
  |       for (int i=0; i < j ; ++i) {
  |         const double x = xj[i];
  |         double xk = x;
  |         for (int k = 2; k <= bord_num; ++k) {
  |           xk *= x;
  |           result = result + b_vector[k] * xk;
  |         }
  | 
  |       }
  |     }
  |     factor_ee[nw] = result;
  |   }
  | 
  |   return QMCKL_SUCCESS;
  | }
  `----

  ,----
  | qmckl_exit_code
  | qmckl_compute_jastrow_champ_factor_ee (const qmckl_context context,
  |                                        const int64_t walk_num,
  |                                        const int64_t elec_num,
  |                                        const int64_t up_num,
  |                                        const int64_t bord_num,
  |                                        const double* b_vector,
  |                                        const double* ee_distance_rescaled,
  |                                        const double* asymp_jasb,
  |                                        const int32_t spin_independent,
  |                                        double* const factor_ee )
  | {
  | 
  | #ifdef HAVE_HPC
  |   return qmckl_compute_jastrow_champ_factor_ee_hpc
  | #else
  |   return qmckl_compute_jastrow_champ_factor_ee_doc
  | #endif
  |     (context, walk_num, elec_num, up_num, bord_num, b_vector,
  |      ee_distance_rescaled, asymp_jasb, spin_independent, factor_ee);
  | }
  `----


3.1.5 Derivative
----------------

  The derivative of `factor_ee' is computed using the
  `ee_distance_rescaled' and the electron-electron rescaled distances
  derivatives `ee_distance_rescaled_gl'.  There are four components, the
  gradient which has 3 components in the \(x, y, z\) directions and the
  laplacian as the last component.

  \[ \nabla_i f_\text{ee} = \sum_{j\ne i}
   \left[\frac{\delta_{ij}^{\uparrow\downarrow} B_0\, \nabla_i
   C_{ij}}{(1 + B_1\, C_{ij})^2} + \sum^{n_\text{ord}}_{k=2} B_k\, k\,
   C_{ij}^{k-1} \nabla C_{ij} \right] \]

  \[ \Delta_i f_\text{ee} = \sum_{j \ne i} \left[
   \delta_{ij}^{\uparrow\downarrow} B_0 \left(\frac{ \Delta_i C_{ij}}{(1
   + B_1\, C_{ij})^2} -\frac{2\,B_1 \left(\nabla_i C_{ij}\right)^2 }{(1
   + B_1\, C_{ij})^3} \right) + \sum^{n_\text{ord}}_{k=2} B_k\, k\,
   \left((k-1)\, C_{ij}^{k-2} \left(\nabla_i C_{ij}\right)^2 +
   C_{ij}^{k-1} \Delta_i C_{ij} \right) \right] \]


3.1.5.1 Get

  ,----
  | qmckl_exit_code
  | qmckl_get_jastrow_champ_factor_ee_gl(qmckl_context context,
  |                                     double* const factor_ee_gl,
  |                                     const int64_t size_max);
  `----


* 3.1.5.1.1 Fortran interface

  ,----
  | interface
  |    integer(qmckl_exit_code) function qmckl_get_jastrow_champ_factor_ee_gl (context, &
  |         factor_ee_gl, size_max) bind(C)
  |      use, intrinsic :: iso_c_binding
  |      import
  |      implicit none
  |      integer (qmckl_context) , intent(in), value :: context
  |      integer(c_int64_t), intent(in), value       :: size_max
  |      real(c_double),   intent(out)               :: factor_ee_gl(size_max)
  |    end function qmckl_get_jastrow_champ_factor_ee_gl
  | end interface
  `----


3.1.5.2 Compute

  -----------------------------------------------------------------------------------------------------------------------------------------
   Variable                   Type                                       In/Out  Description                                               
  -----------------------------------------------------------------------------------------------------------------------------------------
   `context'                  `qmckl_context'                            in      Global state                                              
   `walk_num'                 `int64_t'                                  in      Number of walkers                                         
   `elec_num'                 `int64_t'                                  in      Number of electrons                                       
   `up_num'                   `int64_t'                                  in      Number of alpha electrons                                 
   `bord_num'                 `int64_t'                                  in      Number of coefficients                                    
   `b_vector'                 `double[bord_num+1]'                       in      List of coefficients                                      
   `ee_distance_rescaled'     `double[walk_num][elec_num][elec_num]'     in      Electron-electron distances                               
   `ee_distance_rescaled_gl'  `double[walk_num][elec_num][elec_num][4]'  in      Electron-electron distances                               
   `spin_independent'         `int32_t'                                  in      If 1, same parameters for parallel and antiparallel spins 
   `factor_ee_gl'             `double[walk_num][4][elec_num]'            out     Electron-electron distances                               
  -----------------------------------------------------------------------------------------------------------------------------------------

  ,----
  | function qmckl_compute_jastrow_champ_factor_ee_gl_doc( &
  |      context, walk_num, elec_num, up_num, bord_num, &
  |      b_vector, ee_distance_rescaled, ee_distance_rescaled_gl,  &
  |      spin_independent, factor_ee_gl) &
  |      bind(C) result(info)
  |   use qmckl
  |   implicit none
  | 
  |   integer (qmckl_context), intent(in), value :: context
  |   integer (c_int64_t) , intent(in)  , value :: walk_num
  |   integer (c_int64_t) , intent(in)  , value :: elec_num
  |   integer (c_int64_t) , intent(in)  , value :: up_num
  |   integer (c_int64_t) , intent(in)  , value :: bord_num
  |   real    (c_double ) , intent(in)          :: b_vector(bord_num+1)
  |   real    (c_double ) , intent(in)          :: ee_distance_rescaled(elec_num,elec_num,walk_num)
  |   real    (c_double ) , intent(in)          :: ee_distance_rescaled_gl(4,elec_num,elec_num,walk_num)
  |   integer (c_int32_t) , intent(in)  , value :: spin_independent
  |   real    (c_double ) , intent(out)         :: factor_ee_gl(elec_num,4,walk_num)
  |   integer(qmckl_exit_code)                  :: info
  | 
  |   integer*8 :: i, j, k, nw, ii
  |   double precision   :: x, x1, kf
  |   double precision   :: denom, invdenom, invdenom2, f
  |   double precision   :: grad_c2
  |   double precision   :: dx(4)
  | 
  |   info = QMCKL_SUCCESS
  | 
  |   if (context == QMCKL_NULL_CONTEXT) then
  |      info = QMCKL_INVALID_CONTEXT
  |      return
  |   endif
  | 
  |   if (walk_num <= 0) then
  |      info = QMCKL_INVALID_ARG_2
  |      return
  |   endif
  | 
  |   if (elec_num <= 0) then
  |      info = QMCKL_INVALID_ARG_3
  |      return
  |   endif
  | 
  |   if (bord_num < 0) then
  |      info = QMCKL_INVALID_ARG_4
  |      return
  |   endif
  | 
  |   if ((spin_independent < 0).or.(spin_independent > 1)) then
  |      info = QMCKL_INVALID_ARG_8
  |      return
  |   endif
  | 
  |   do nw =1, walk_num
  |      factor_ee_gl(:,:,nw) = 0.0d0
  | 
  |      do j = 1, elec_num
  |         do i = 1, elec_num
  |            if (i == j) cycle
  | 
  |            x = ee_distance_rescaled(i,j,nw)
  | 
  |            denom         = 1.0d0 + b_vector(2) * x
  |            invdenom      = 1.0d0 / denom
  |            invdenom2     = invdenom * invdenom
  | 
  |            dx(1) = ee_distance_rescaled_gl(1, i, j, nw)
  |            dx(2) = ee_distance_rescaled_gl(2, i, j, nw)
  |            dx(3) = ee_distance_rescaled_gl(3, i, j, nw)
  |            dx(4) = ee_distance_rescaled_gl(4, i, j, nw)
  | 
  |            grad_c2 = dx(1)*dx(1) + dx(2)*dx(2) + dx(3)*dx(3)
  | 
  |            if (spin_independent == 1) then
  |               f = b_vector(1) * invdenom2
  |            else
  |               if((i <= up_num .and. j <= up_num ) .or. (i >  up_num .and. j >  up_num)) then
  |                  f = 0.5d0 * b_vector(1) * invdenom2
  |               else
  |                  f = b_vector(1) * invdenom2
  |               end if
  |            end if
  | 
  |            factor_ee_gl(i,1,nw) = factor_ee_gl(i,1,nw) + f * dx(1)
  |            factor_ee_gl(i,2,nw) = factor_ee_gl(i,2,nw) + f * dx(2)
  |            factor_ee_gl(i,3,nw) = factor_ee_gl(i,3,nw) + f * dx(3)
  |            factor_ee_gl(i,4,nw) = factor_ee_gl(i,4,nw) &
  |                 + f * (dx(4) - 2.d0 * b_vector(2) * grad_c2 * invdenom)
  | 
  | 
  |            kf = 2.d0
  |            x1 = x
  |            x = 1.d0
  |            do k=2, bord_num
  |               f = b_vector(k+1) * kf * x
  |               factor_ee_gl(i,1,nw) = factor_ee_gl(i,1,nw) + f * x1 * dx(1)
  |               factor_ee_gl(i,2,nw) = factor_ee_gl(i,2,nw) + f * x1 * dx(2)
  |               factor_ee_gl(i,3,nw) = factor_ee_gl(i,3,nw) + f * x1 * dx(3)
  |               factor_ee_gl(i,4,nw) = factor_ee_gl(i,4,nw) &
  |                    + f * (x1 * dx(4) + (kf-1.d0) * grad_c2)
  |               x = x*x1
  |               kf = kf + 1.d0
  |            end do
  | 
  |         end do
  |      end do
  | 
  |   end do
  | 
  | end function qmckl_compute_jastrow_champ_factor_ee_gl_doc
  `----

  ,----
  | qmckl_exit_code
  | qmckl_compute_jastrow_champ_factor_ee_gl_hpc(const qmckl_context context,
  |                                              const int64_t walk_num,
  |                                              const int64_t elec_num,
  |                                              const int64_t up_num,
  |                                              const int64_t bord_num,
  |                                              const double* b_vector,
  |                                              const double* ee_distance_rescaled,
  |                                              const double* ee_distance_rescaled_gl,
  |                                              const int32_t spin_independent,
  |                                              double* const factor_ee_gl )
  | {
  | 
  |   if (context == QMCKL_NULL_CONTEXT) return QMCKL_INVALID_CONTEXT;
  |   if (walk_num <= 0) return QMCKL_INVALID_ARG_2;
  |   if (elec_num <= 0) return QMCKL_INVALID_ARG_3;
  |   if (up_num <= 0) return QMCKL_INVALID_ARG_4;
  |   if (bord_num < 0) return QMCKL_INVALID_ARG_5;
  |   if (b_vector == NULL) return QMCKL_INVALID_ARG_6;
  |   if (ee_distance_rescaled == NULL) return QMCKL_INVALID_ARG_7;
  |   if (ee_distance_rescaled_gl == NULL) return QMCKL_INVALID_ARG_8;
  |   if (spin_independent & (int32_t) (-2)) return QMCKL_INVALID_ARG_8;
  |   if (factor_ee_gl == NULL) return QMCKL_INVALID_ARG_9;
  | 
  |   double kf[bord_num+1];
  |   for (int k=0 ; k<=bord_num ; ++k) {
  |     kf[k] = (double) k;
  |   }
  | 
  | #ifdef HAVE_OPENMP
  | #pragma omp parallel for
  | #endif
  |   for (int nw = 0; nw < walk_num; ++nw) {
  |     double xk[bord_num+1];
  |     bool touched = false;
  | 
  |     for (int j = 0; j < elec_num; ++j) {
  |       const double* dxj = &ee_distance_rescaled_gl[4*elec_num*(j+nw*elec_num)];
  |       const double*  xj = &ee_distance_rescaled   [  elec_num*(j+nw*elec_num)];
  | 
  |       double * restrict factor_ee_gl_0 = &(factor_ee_gl[nw*elec_num*4]);
  |       double * restrict factor_ee_gl_1 = factor_ee_gl_0 + elec_num;
  |       double * restrict factor_ee_gl_2 = factor_ee_gl_1 + elec_num;
  |       double * restrict factor_ee_gl_3 = factor_ee_gl_2 + elec_num;
  | 
  |       for (int i = 0; i < elec_num; ++i) {
  |         if (j == i) {
  |           if (j == 0) {
  |             factor_ee_gl_0[i] = 0.0;
  |             factor_ee_gl_1[i] = 0.0;
  |             factor_ee_gl_2[i] = 0.0;
  |             factor_ee_gl_3[i] = 0.0;
  |           }
  |           continue;
  |         }
  | 
  |         double x = xj[i];
  | 
  |         const double denom      = 1.0 + b_vector[1]*x;
  |         const double invdenom   = 1.0  / denom;
  |         const double invdenom2  = invdenom * invdenom;
  | 
  |         const double* restrict dx = dxj + 4*i;
  | 
  |         const double grad_c2 = dx[0]*dx[0] + dx[1]*dx[1] + dx[2]*dx[2];
  | 
  |         double f = b_vector[0] * invdenom2;
  |         if ((spin_independent == 0) && (
  |             ((i <  up_num) && (j <  up_num)) ||
  |             ((i >= up_num) && (j >= up_num))) ) {
  |           f *= 0.5;
  |         }
  | 
  |         if (touched) {
  |           factor_ee_gl_0[i] = factor_ee_gl_0[i] + f*dx[0];
  |           factor_ee_gl_1[i] = factor_ee_gl_1[i] + f*dx[1];
  |           factor_ee_gl_2[i] = factor_ee_gl_2[i] + f*dx[2];
  |           factor_ee_gl_3[i] = factor_ee_gl_3[i] + f*dx[3];
  |         } else {
  |           factor_ee_gl_0[i] = f*dx[0];
  |           factor_ee_gl_1[i] = f*dx[1];
  |           factor_ee_gl_2[i] = f*dx[2];
  |           factor_ee_gl_3[i] = f*dx[3];
  |         }
  |         factor_ee_gl_3[i] = factor_ee_gl_3[i] - f*grad_c2*invdenom*2.0 * b_vector[1];
  | 
  |         xk[0] = 1.0;
  |         for (int k=1 ; k<= bord_num ; ++k) {
  |           xk[k] = xk[k-1]*x;
  |         }
  | 
  |         for (int k=2 ; k<= bord_num ; ++k) {
  |           const double f1 = b_vector[k] * kf[k] * xk[k-2];
  |           const double f2 = f1*xk[1];
  |           factor_ee_gl_0[i] = factor_ee_gl_0[i] + f2*dx[0];
  |           factor_ee_gl_1[i] = factor_ee_gl_1[i] + f2*dx[1];
  |           factor_ee_gl_2[i] = factor_ee_gl_2[i] + f2*dx[2];
  |           factor_ee_gl_3[i] = factor_ee_gl_3[i] + f2*dx[3];
  |           factor_ee_gl_3[i] = factor_ee_gl_3[i] + f1*kf[k-1]*grad_c2;
  |         }
  |       }
  |       touched = true;
  |     }
  |     if (!touched) {
  |       memset(&(factor_ee_gl[nw*4*elec_num]), 0, elec_num*4*sizeof(double));
  |     }
  |   }
  | 
  |   return QMCKL_SUCCESS;
  | }
  `----


  ,----
  | qmckl_exit_code
  | qmckl_compute_jastrow_champ_factor_ee_gl_hpc (const qmckl_context context,
  |                                               const int64_t walk_num,
  |                                               const int64_t elec_num,
  |                                               const int64_t up_num,
  |                                               const int64_t bord_num,
  |                                               const double* b_vector,
  |                                               const double* ee_distance_rescaled,
  |                                               const double* ee_distance_rescaled_gl,
  |                                               const int32_t spin_independent,
  |                                               double* const factor_ee_gl );
  | 
  `----

  ,----
  | qmckl_exit_code
  | qmckl_compute_jastrow_champ_factor_ee_gl_doc (const qmckl_context context,
  |                                               const int64_t walk_num,
  |                                               const int64_t elec_num,
  |                                               const int64_t up_num,
  |                                               const int64_t bord_num,
  |                                               const double* b_vector,
  |                                               const double* ee_distance_rescaled,
  |                                               const double* ee_distance_rescaled_gl,
  |                                               const int32_t spin_independent,
  |                                               double* const factor_ee_gl );
  `----


  ,----
  | qmckl_exit_code
  | qmckl_compute_jastrow_champ_factor_ee_gl (const qmckl_context context,
  |                                           const int64_t walk_num,
  |                                           const int64_t elec_num,
  |                                           const int64_t up_num,
  |                                           const int64_t bord_num,
  |                                           const double* b_vector,
  |                                           const double* ee_distance_rescaled,
  |                                           const double* ee_distance_rescaled_gl,
  |                                           const int32_t spin_independent,
  |                                           double* const factor_ee_gl )
  | {
  | #ifdef HAVE_HPC
  |   return qmckl_compute_jastrow_champ_factor_ee_gl_hpc
  | #else
  |     return qmckl_compute_jastrow_champ_factor_ee_gl_doc
  | #endif
  |     (context, walk_num, elec_num, up_num, bord_num, b_vector,
  |      ee_distance_rescaled, ee_distance_rescaled_gl, spin_independent, factor_ee_gl );
  | }
  `----


3.2 Electron-nucleus component
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

3.2.1 Asymptotic component
--------------------------

  Calculate the asymptotic component `asymp_jasa' to be subtracted from
  the final electron-nucleus jastrow factor \(J_{\text{eN}}\). The
  asymptotic component is calculated via the `a_vector' and the
  electron-nucleus rescale factors `rescale_factor_en'.

  \[ J_{\text{en}}^{\infty \alpha} = -\frac{a_1 \kappa_\alpha^{-1}}{1 +
     a_2 \kappa_\alpha^{-1}} \]


3.2.1.1 Get

  ,----
  | qmckl_exit_code
  | qmckl_get_jastrow_champ_asymp_jasa(qmckl_context context,
  |                                    double* const asymp_jasa,
  |                                    const int64_t size_max);
  `----


* 3.2.1.1.1 Fortran interface

  ,----
  | interface
  |    integer(qmckl_exit_code) function qmckl_get_jastrow_champ_asymp_jasa(context, &
  |         asymp_jasa, size_max) bind(C)
  |      use, intrinsic :: iso_c_binding
  |      import
  |      implicit none
  |      integer (qmckl_context) , intent(in), value :: context
  |      integer(c_int64_t), intent(in), value       :: size_max
  |      real(c_double),   intent(out)               :: asymp_jasa(size_max)
  |    end function qmckl_get_jastrow_champ_asymp_jasa
  | end interface
  `----


3.2.1.2 Compute

  ----------------------------------------------------------------------------------------------
   Variable             Type                                 In/Out  Description                
  ----------------------------------------------------------------------------------------------
   `context'            `qmckl_context'                      in      Global state               
   `aord_num'           `int64_t'                            in      Order of the polynomial    
   `type_nucl_num'      `int64_t'                            in      Number of nucleus types    
   `a_vector'           `double[type_nucl_num][aord_num+1]'  in      Values of a                
   `rescale_factor_en'  `double[type_nucl_num]'              in      Electron nucleus distances 
   `asymp_jasa'         `double[type_nucl_num]'              out     Asymptotic value           
  ----------------------------------------------------------------------------------------------

  ,----
  | function qmckl_compute_jastrow_champ_asymp_jasa(context, aord_num, type_nucl_num, a_vector, &
  |      rescale_factor_en, asymp_jasa) &
  |      result(info) bind(C)
  |   use, intrinsic :: iso_c_binding
  |   use qmckl
  |   implicit none
  |   integer(qmckl_context), intent(in), value :: context
  |   integer (c_int64_t) , intent(in)  , value :: aord_num
  |   integer (c_int64_t) , intent(in)  , value :: type_nucl_num
  |   real    (c_double ) , intent(in)          :: a_vector(aord_num+1,type_nucl_num)
  |   real    (c_double ) , intent(in)          :: rescale_factor_en(type_nucl_num)
  |   real    (c_double ) , intent(out)         :: asymp_jasa(type_nucl_num)
  |   integer(qmckl_exit_code)                  :: info
  | 
  |   integer*8 :: i, j, p
  |   double precision   :: kappa_inv, x, asym_one
  | 
  |   info = QMCKL_SUCCESS
  | 
  |   if (context == QMCKL_NULL_CONTEXT) then
  |      info = QMCKL_INVALID_CONTEXT
  |      return
  |   endif
  | 
  |   if (aord_num < 0) then
  |      info = QMCKL_INVALID_ARG_2
  |      return
  |   endif
  | 
  |   do i=1,type_nucl_num
  | 
  |      kappa_inv = 1.0d0 / rescale_factor_en(i)
  | 
  |      asymp_jasa(i) = a_vector(1,i) * kappa_inv / (1.0d0 + a_vector(2,i) * kappa_inv)
  | 
  |      x = kappa_inv
  |      do p = 2, aord_num
  |         x = x * kappa_inv
  |         asymp_jasa(i) = asymp_jasa(i) + a_vector(p+1, i) * x
  |      end do
  | 
  |   end do
  | 
  | end function qmckl_compute_jastrow_champ_asymp_jasa
  `----

  ,----
  | qmckl_exit_code qmckl_compute_jastrow_champ_asymp_jasa (
  |       Type Variable,
  |       const qmckl_context context,
  |       const int64_t aord_num,
  |       const int64_t type_nucl_num,
  |       const double* a_vector,
  |       const double* rescale_factor_en,
  |       double* const asymp_jasa ); 
  `----


3.2.2 Electron-nucleus rescaled distances
-----------------------------------------

  `en_distance_rescaled' stores the matrix of the rescaled distances
  between electrons and nuclei.

  \[ C_{i\alpha} = \frac{ 1 - e^{-\kappa_\alpha
      R_{i\alpha}}}{\kappa_\alpha} \]

  where \(R_{i\alpha}\) is the matrix of electron-nucleus distances.


3.2.2.1 Get

  ,----
  | qmckl_exit_code
  | qmckl_get_jastrow_champ_en_distance_rescaled(qmckl_context context,
  |                                              double* const distance_rescaled,
  |                                              const int64_t size_max);
  `----


3.2.2.2 Compute

  -----------------------------------------------------------------------------------------------------------
   Variable                Type                                    In/Out  Description                       
  -----------------------------------------------------------------------------------------------------------
   `context'               `qmckl_context'                         in      Global state                      
   `elec_num'              `int64_t'                               in      Number of electrons               
   `nucl_num'              `int64_t'                               in      Number of nuclei                  
   `type_nucl_num'         `int64_t'                               in      Number of types of nuclei         
   `type_nucl_vector'      `int64_t[nucl_num]'                     in      Number of types of nuclei         
   `rescale_factor_en'     `double[type_nucl_num]'                 in      The factor for rescaled distances 
   `walk_num'              `int64_t'                               in      Number of walkers                 
   `elec_coord'            `double[3][walk_num][elec_num]'         in      Electron coordinates              
   `nucl_coord'            `double[3][nucl_num]'                   in      Nuclear coordinates               
   `en_distance_rescaled'  `double[walk_num][nucl_num][elec_num]'  out     Electron-nucleus distances        
  -----------------------------------------------------------------------------------------------------------

  ,----
  | function qmckl_compute_en_distance_rescaled_doc(context, &
  |      elec_num, nucl_num, type_nucl_num, &
  |      type_nucl_vector, rescale_factor_en, walk_num, elec_coord, &
  |      nucl_coord, en_distance_rescaled) &
  |      bind(C) result(info)
  |   use qmckl
  |   implicit none
  |   integer (qmckl_context), intent(in), value :: context
  |   integer (c_int64_t) , intent(in)  , value :: elec_num
  |   integer (c_int64_t) , intent(in)  , value :: nucl_num
  |   integer (c_int64_t) , intent(in)  , value :: type_nucl_num
  |   integer (c_int64_t) , intent(in)          :: type_nucl_vector(nucl_num)
  |   real    (c_double ) , intent(in)          :: rescale_factor_en(type_nucl_num)
  |   integer (c_int64_t) , intent(in)  , value :: walk_num
  |   real    (c_double ) , intent(in)          :: elec_coord(elec_num,walk_num,3)
  |   real    (c_double ) , intent(in)          :: nucl_coord(nucl_num,3)
  |   real    (c_double ) , intent(out)         :: en_distance_rescaled(elec_num,nucl_num,walk_num)
  |   integer(qmckl_exit_code)                  :: info
  | 
  |   integer*8 :: i, k
  |   double precision      :: coord(3)
  | 
  |   info = QMCKL_SUCCESS
  | 
  |   if (context == QMCKL_NULL_CONTEXT) then
  |      info = QMCKL_INVALID_CONTEXT
  |      return
  |   endif
  | 
  |   if (elec_num <= 0) then
  |      info = QMCKL_INVALID_ARG_2
  |      return
  |   endif
  | 
  |   if (nucl_num <= 0) then
  |      info = QMCKL_INVALID_ARG_3
  |      return
  |   endif
  | 
  |   if (walk_num <= 0) then
  |      info = QMCKL_INVALID_ARG_5
  |      return
  |   endif
  | 
  |   do i=1, nucl_num
  |      coord(1:3) = nucl_coord(i,1:3)
  |      do k=1,walk_num
  |         info = qmckl_distance_rescaled(context, 'T', 'N', elec_num, 1_8, &
  |              elec_coord(1,k,1), elec_num*walk_num, coord, 3_8, &
  |              en_distance_rescaled(1,i,k), elec_num, rescale_factor_en(type_nucl_vector(i)+1))
  |         if (info /= QMCKL_SUCCESS) then
  |            return
  |         endif
  |      end do
  |   end do
  | 
  | end function qmckl_compute_en_distance_rescaled_doc
  `----


3.2.3 Electron-electron rescaled distance gradients and Laplacian with respect to electron coordinates
------------------------------------------------------------------------------------------------------

  The rescaled distances, represented by $C_{i\alpha} = (1 -
  e^{-\kappa_\alpha R_{i\alpha}})/\kappa$ are differentiated with
  respect to the electron coordinates.  This information is stored in
  the tensor `en_distance_rescaled_gl'. The initial three sequential
  elements of this three-index tensor provide the $x$, $y$, and $z$
  direction derivatives, while the fourth index corresponds to the
  Laplacian.


3.2.3.1 Get

  ,----
  | qmckl_exit_code
  | qmckl_get_jastrow_champ_en_distance_rescaled_gl(qmckl_context context,
  |                                                 double* const distance_rescaled_gl,
  |                                                 const int64_t size_max);
  `----


3.2.3.2 Compute

  ---------------------------------------------------------------------------------------------------------------------
   Variable                   Type                                       In/Out  Description                           
  ---------------------------------------------------------------------------------------------------------------------
   `context'                  `qmckl_context'                            in      Global state                          
   `elec_num'                 `int64_t'                                  in      Number of electrons                   
   `nucl_num'                 `int64_t'                                  in      Number of nuclei                      
   `type_nucl_num'            `int64_t'                                  in      Number of nucleus types               
   `type_nucl_vector'         `int64_t[nucl_num]'                        in      Array of nucleus types                
   `rescale_factor_en'        `double[nucl_num]'                         in      The factors for rescaled distances    
   `walk_num'                 `int64_t'                                  in      Number of walkers                     
   `elec_coord'               `double[3][walk_num][elec_num]'            in      Electron coordinates                  
   `nucl_coord'               `double[3][nucl_num]'                      in      Nuclear coordinates                   
   `en_distance_rescaled_gl'  `double[walk_num][nucl_num][elec_num][4]'  out     Electron-nucleus distance derivatives 
  ---------------------------------------------------------------------------------------------------------------------

  ,----
  | function qmckl_compute_en_distance_rescaled_gl_doc(context, elec_num, nucl_num, &
  |      type_nucl_num, type_nucl_vector, rescale_factor_en, walk_num, elec_coord, &
  |      nucl_coord, en_distance_rescaled_gl) &
  |      result(info) bind(C)
  |   use, intrinsic :: iso_c_binding
  |   use qmckl
  |   implicit none
  |   integer(qmckl_context), intent(in)  :: context
  |   integer (c_int64_t) , intent(in)  , value :: elec_num
  |   integer (c_int64_t) , intent(in)  , value :: nucl_num
  |   integer (c_int64_t) , intent(in)  , value :: type_nucl_num
  |   integer (c_int64_t) , intent(in)          :: type_nucl_vector(nucl_num)
  |   real    (c_double ) , intent(in)          :: rescale_factor_en(nucl_num)
  |   integer (c_int64_t) , intent(in)  , value :: walk_num
  |   real    (c_double ) , intent(in)          :: elec_coord(elec_num,walk_num,3)
  |   real    (c_double ) , intent(in)          :: nucl_coord(nucl_num,3)
  |   real    (c_double ) , intent(out)         :: en_distance_rescaled_gl(4,elec_num,nucl_num,walk_num)
  | 
  |   integer(qmckl_exit_code)                  :: info
  |   integer*8 :: i, k
  |   double precision :: coord(3)
  | 
  |   info = QMCKL_SUCCESS
  | 
  |   if (context == QMCKL_NULL_CONTEXT) then
  |      info = QMCKL_INVALID_CONTEXT
  |      return
  |   endif
  | 
  |   if (elec_num <= 0) then
  |      info = QMCKL_INVALID_ARG_2
  |      return
  |   endif
  | 
  |   if (nucl_num <= 0) then
  |      info = QMCKL_INVALID_ARG_3
  |      return
  |   endif
  | 
  |   if (walk_num <= 0) then
  |      info = QMCKL_INVALID_ARG_5
  |      return
  |   endif
  | 
  |   do i=1, nucl_num
  |      coord(1:3) = nucl_coord(i,1:3)
  |      do k=1,walk_num
  |         info = qmckl_distance_rescaled_gl(context, 'T', 'T', elec_num, 1_8, &
  |              elec_coord(1,k,1), elec_num*walk_num, coord, 1_8, &
  |              en_distance_rescaled_gl(1,1,i,k), elec_num, rescale_factor_en(type_nucl_vector(i)+1))
  |         if (info /= QMCKL_SUCCESS) then
  |            return
  |         endif
  |      end do
  |   end do
  | 
  | end function qmckl_compute_en_distance_rescaled_gl_doc
  `----


3.2.4 Electron-nucleus component
--------------------------------

  Calculate the electron-electron jastrow component `factor_en' using
  the `a_vector' coeffecients and the electron-nucleus rescaled
  distances `en_distance_rescaled'.

  \[ f_{\alpha}(R_{i\alpha}) = - \sum_{i,j<i} \left[ \frac{ A_0
   C_{ij}}{1 + A_1 C_{ij}} + \sum_{k=2}^{N^\alpha_{\text{ord}}}A_k
   C_{ij}^k \right] \]


3.2.4.1 Get

  ,----
  | qmckl_exit_code
  | qmckl_get_jastrow_champ_factor_en(qmckl_context context,
  |                             double* const factor_en,
  |                             const int64_t size_max);
  `----


* 3.2.4.1.1 Fortran interface

  ,----
  | interface
  |    integer(qmckl_exit_code) function qmckl_get_jastrow_champ_factor_en (context, &
  |         factor_en, size_max) bind(C)
  |      use, intrinsic :: iso_c_binding
  |      import
  |      implicit none
  |      integer (qmckl_context) , intent(in), value :: context
  |      integer(c_int64_t), intent(in), value       :: size_max
  |      real(c_double),   intent(out)               :: factor_en(size_max)
  |    end function qmckl_get_jastrow_champ_factor_en
  | end interface
  `----


3.2.4.2 Compute

  ----------------------------------------------------------------------------------------------------
   Variable                Type                                    In/Out  Description                
  ----------------------------------------------------------------------------------------------------
   `context'               `qmckl_context'                         in      Global state               
   `walk_num'              `int64_t'                               in      Number of walkers          
   `elec_num'              `int64_t'                               in      Number of electrons        
   `nucl_num'              `int64_t'                               in      Number of nuclei           
   `type_nucl_num'         `int64_t'                               in      Number of unique nuclei    
   `type_nucl_vector'      `int64_t[nucl_num]'                     in      IDs of unique nuclei       
   `aord_num'              `int64_t'                               in      Number of coefficients     
   `a_vector'              `double[type_nucl_num][aord_num+1]'     in      List of coefficients       
   `en_distance_rescaled'  `double[walk_num][nucl_num][elec_num]'  in      Electron-nucleus distances 
   `asymp_jasa'            `double[type_nucl_num]'                 in      Type of nuclei             
   `factor_en'             `double[walk_num]'                      out     Electron-nucleus jastrow   
  ----------------------------------------------------------------------------------------------------

  ,----
  | function qmckl_compute_jastrow_champ_factor_en_doc( &
  |      context, walk_num, elec_num, nucl_num, type_nucl_num, &
  |      type_nucl_vector, aord_num, a_vector, &
  |      en_distance_rescaled, asymp_jasa, factor_en) &
  |      bind(C) result(info)
  |   use qmckl
  |   implicit none
  | 
  |   integer (qmckl_context), intent(in), value :: context
  |   integer (c_int64_t) , intent(in)  , value :: walk_num
  |   integer (c_int64_t) , intent(in)  , value :: elec_num
  |   integer (c_int64_t) , intent(in)  , value :: nucl_num
  |   integer (c_int64_t) , intent(in)  , value :: type_nucl_num
  |   integer (c_int64_t) , intent(in)          :: type_nucl_vector(nucl_num)
  |   integer (c_int64_t) , intent(in)  , value :: aord_num
  |   real    (c_double ) , intent(in)          :: a_vector(aord_num+1,type_nucl_num)
  |   real    (c_double ) , intent(in)          :: en_distance_rescaled(elec_num,nucl_num,walk_num)
  |   real    (c_double ) , intent(in)          :: asymp_jasa(type_nucl_num)
  |   real    (c_double ) , intent(out)         :: factor_en(walk_num)
  |   integer(qmckl_exit_code)                  :: info
  | 
  |   integer*8 :: i, a, p, nw
  |   double precision   :: x, power_ser
  | 
  |   info = QMCKL_SUCCESS
  | 
  |   if (context == QMCKL_NULL_CONTEXT) then
  |      info = QMCKL_INVALID_CONTEXT
  |      return
  |   endif
  | 
  |   if (walk_num <= 0) then
  |      info = QMCKL_INVALID_ARG_2
  |      return
  |   endif
  | 
  |   if (elec_num <= 0) then
  |      info = QMCKL_INVALID_ARG_3
  |      return
  |   endif
  | 
  |   if (nucl_num <= 0) then
  |      info = QMCKL_INVALID_ARG_4
  |      return
  |   endif
  | 
  |   if (type_nucl_num <= 0) then
  |      info = QMCKL_INVALID_ARG_4
  |      return
  |   endif
  | 
  |   if (aord_num < 0) then
  |      info = QMCKL_INVALID_ARG_7
  |      return
  |   endif
  | 
  | 
  |   do nw =1, walk_num
  |      factor_en(nw) = 0.0d0
  |      do a = 1, nucl_num
  |         do i = 1, elec_num
  |            x = en_distance_rescaled(i, a, nw)
  | 
  |            factor_en(nw) = factor_en(nw) + a_vector(1, type_nucl_vector(a)+1) * x / &
  |                 (1.0d0 + a_vector(2, type_nucl_vector(a)+1) * x) - asymp_jasa(type_nucl_vector(a)+1)
  | 
  |            do p = 2, aord_num
  |               x = x * en_distance_rescaled(i, a, nw)
  |               factor_en(nw) = factor_en(nw) + a_vector(p + 1, type_nucl_vector(a)+1) * x
  |            end do
  | 
  |         end do
  |      end do
  |   end do
  | 
  | end function qmckl_compute_jastrow_champ_factor_en_doc
  `----

  ,----
  | qmckl_exit_code qmckl_compute_jastrow_champ_factor_en_doc (
  |       Type Variable,
  |       const qmckl_context context,
  |       const int64_t walk_num,
  |       const int64_t elec_num,
  |       const int64_t nucl_num,
  |       const int64_t type_nucl_num,
  |       const int64_t* type_nucl_vector,
  |       const int64_t aord_num,
  |       const double* a_vector,
  |       const double* en_distance_rescaled,
  |       const double* asymp_jasa,
  |       double* const factor_en ); 
  `----

  ,----
  | qmckl_exit_code qmckl_compute_jastrow_champ_factor_en (
  |          const qmckl_context context,
  |          const int64_t walk_num,
  |          const int64_t elec_num,
  |          const int64_t nucl_num,
  |          const int64_t type_nucl_num,
  |          const int64_t* type_nucl_vector,
  |          const int64_t aord_num,
  |          const double* a_vector,
  |          const double* en_distance_rescaled,
  |          const double* asymp_jasa,
  |          double* const factor_en )
  | {
  | #ifdef HAVE_HPC
  |   return qmckl_compute_jastrow_champ_factor_en_hpc
  | #else
  |   return qmckl_compute_jastrow_champ_factor_en_doc
  | #endif
  |     (context, walk_num, elec_num, nucl_num, type_nucl_num,
  |      type_nucl_vector, aord_num, a_vector, en_distance_rescaled,
  |      asymp_jasa, factor_en );
  | }
  `----


3.2.5 Derivative
----------------

  Calculate the electron-electron jastrow component `factor_en_gl'
  derivative with respect to the electron coordinates using the
  `en_distance_rescaled' and `en_distance_rescaled_gl' which are already
  calculated previously.

  The derivative is calculated in the function
  `qmckl_compute_jastrow_champ_factor_en_gl'.  The formula is given by:
  \[ \nabla_i f_{\alpha}(R_{i\alpha}) = \sum_{j=1}^{N_\text{elec}}
  \left[ \frac{ A_0\, \nabla_i C_{ij} }{(1 + A_1 C_{ij})^2} +
  \sum_{k=2}^{N^\alpha_{\text{ord}}} A_k\, k\, C_{ij}^{k-1}\,\nabla_i
  C_{ij} \right] \]

  \[ \Delta_i f_{\alpha}(R_{i\alpha}) = \sum_{j=1}^{N_\text{elec}}
  \left[ \frac{ A_0\, \Delta_i C_{ij} }{(1 + A_1 C_{ij})^2} - \frac{ 2
  A_0\, A_1 (\nabla_i C_{ij})^2}{(1 + A_1 C_{ij})^3} +
  \sum_{k=2}^{N^\alpha_{\text{ord}}} A_k\, k\, C_{ij}^{k-1} C_{ij}^{k-2}
  \left[ \Delta_i C_{ij} + (k-1)(\nabla_i C_{ij})^2 \right] \right] \]


3.2.5.1 Get

  ,----
  | qmckl_exit_code
  | qmckl_get_jastrow_champ_factor_en_gl(qmckl_context context,
  |                                     double* const factor_en_gl,
  |                                     const int64_t size_max);
  `----


* 3.2.5.1.1 Fortran interface

  ,----
  | interface
  |    integer(qmckl_exit_code) function qmckl_get_jastrow_champ_factor_en_gl (context, &
  |         factor_en_gl, size_max) bind(C)
  |      use, intrinsic :: iso_c_binding
  |      import
  |      implicit none
  |      integer (qmckl_context) , intent(in), value :: context
  |      integer(c_int64_t), intent(in), value       :: size_max
  |      real(c_double),   intent(out)               :: factor_en_gl(size_max)
  |    end function qmckl_get_jastrow_champ_factor_en_gl
  | end interface
  `----


3.2.5.2 Compute

  ---------------------------------------------------------------------------------------------------------------------
   Variable                   Type                                       In/Out  Description                           
  ---------------------------------------------------------------------------------------------------------------------
   `context'                  `qmckl_context'                            in      Global state                          
   `walk_num'                 `int64_t'                                  in      Number of walkers                     
   `elec_num'                 `int64_t'                                  in      Number of electrons                   
   `nucl_num'                 `int64_t'                                  in      Number of nuclei                      
   `type_nucl_num'            `int64_t'                                  in      Number of unique nuclei               
   `type_nucl_vector'         `int64_t[nucl_num]'                        in      IDs of unique nuclei                  
   `aord_num'                 `int64_t'                                  in      Number of coefficients                
   `a_vector'                 `double[type_nucl_num][aord_num+1]'        in      List of coefficients                  
   `en_distance_rescaled'     `double[walk_num][nucl_num][elec_num]'     in      Electron-nucleus distances            
   `en_distance_rescaled_gl'  `double[walk_num][nucl_num][elec_num][4]'  in      Electron-nucleus distance derivatives 
   `factor_en_gl'             `double[walk_num][4][elec_num]'            out     Electron-nucleus jastrow              
  ---------------------------------------------------------------------------------------------------------------------

  ,----
  | function qmckl_compute_jastrow_champ_factor_en_gl_doc( &
  |      context, walk_num, elec_num, nucl_num, type_nucl_num, &
  |      type_nucl_vector, aord_num, a_vector, &
  |      en_distance_rescaled, en_distance_rescaled_gl, factor_en_gl) &
  |      bind(C) result(info)
  |   use qmckl
  |   implicit none
  | 
  |   integer (qmckl_context), intent(in), value :: context
  |   integer (c_int64_t) , intent(in)  , value :: walk_num
  |   integer (c_int64_t) , intent(in)  , value :: elec_num
  |   integer (c_int64_t) , intent(in)  , value :: nucl_num
  |   integer (c_int64_t) , intent(in)  , value :: type_nucl_num
  |   integer (c_int64_t) , intent(in)          :: type_nucl_vector(nucl_num)
  |   integer (c_int64_t) , intent(in)  , value :: aord_num
  |   real    (c_double ) , intent(in)          :: a_vector(aord_num+1,type_nucl_num)
  |   real    (c_double ) , intent(in)          :: en_distance_rescaled(elec_num,nucl_num,walk_num)
  |   real    (c_double ) , intent(in)          :: en_distance_rescaled_gl(4, elec_num,nucl_num,walk_num)
  |   real    (c_double ) , intent(out)         :: factor_en_gl(elec_num,4,walk_num)
  |   integer(qmckl_exit_code)                  :: info
  | 
  |   integer*8 :: i, a, k, nw, ii
  |   double precision   :: x, x1, kf
  |   double precision   :: denom, invdenom, invdenom2, f
  |   double precision   :: grad_c2
  |   double precision   :: dx(4)
  | 
  |   info = QMCKL_SUCCESS
  | 
  |   if (context == QMCKL_NULL_CONTEXT) then
  |      info = QMCKL_INVALID_CONTEXT
  |      return
  |   endif
  | 
  |   if (walk_num <= 0) then
  |      info = QMCKL_INVALID_ARG_2
  |      return
  |   endif
  | 
  |   if (elec_num <= 0) then
  |      info = QMCKL_INVALID_ARG_3
  |      return
  |   endif
  | 
  |   if (nucl_num <= 0) then
  |      info = QMCKL_INVALID_ARG_4
  |      return
  |   endif
  | 
  |   if (aord_num < 0) then
  |      info = QMCKL_INVALID_ARG_7
  |      return
  |   endif
  | 
  |   do nw =1, walk_num
  |      factor_en_gl(:,:,nw) = 0.0d0
  |      do a = 1, nucl_num
  |         do i = 1, elec_num
  | 
  |            x = en_distance_rescaled(i,a,nw)
  |            if(abs(x) < 1.d-12) continue
  | 
  |            denom = 1.0d0 + a_vector(2, type_nucl_vector(a)+1) * x
  |            invdenom = 1.0d0 / denom
  |            invdenom2 = invdenom*invdenom
  | 
  |            dx(1) = en_distance_rescaled_gl(1,i,a,nw)
  |            dx(2) = en_distance_rescaled_gl(2,i,a,nw)
  |            dx(3) = en_distance_rescaled_gl(3,i,a,nw)
  |            dx(4) = en_distance_rescaled_gl(4,i,a,nw)
  | 
  |            f = a_vector(1, type_nucl_vector(a)+1) * invdenom2
  |            grad_c2 = dx(1)*dx(1) + dx(2)*dx(2) + dx(3)*dx(3)
  | 
  |            factor_en_gl(i,1,nw) = factor_en_gl(i,1,nw) + f * dx(1)
  |            factor_en_gl(i,2,nw) = factor_en_gl(i,2,nw) + f * dx(2)
  |            factor_en_gl(i,3,nw) = factor_en_gl(i,3,nw) + f * dx(3)
  |            factor_en_gl(i,4,nw) = factor_en_gl(i,4,nw) &
  |                 + f * (dx(4) - 2.d0 * a_vector(2, type_nucl_vector(a)+1) * grad_c2 * invdenom)
  | 
  | 
  |            kf = 2.d0
  |            x1 = x
  |            x = 1.d0
  |            do k=2, aord_num
  |               f = a_vector(k+1,type_nucl_vector(a)+1) * kf * x
  |               factor_en_gl(i,1,nw) = factor_en_gl(i,1,nw) + f * x1 * dx(1)
  |               factor_en_gl(i,2,nw) = factor_en_gl(i,2,nw) + f * x1 * dx(2)
  |               factor_en_gl(i,3,nw) = factor_en_gl(i,3,nw) + f * x1 * dx(3)
  |               factor_en_gl(i,4,nw) = factor_en_gl(i,4,nw) &
  |                    + f * (x1 * dx(4) + (kf-1.d0) * grad_c2)
  |               x = x*x1
  |               kf = kf + 1.d0
  |            end do
  | 
  |         end do
  |      end do
  |   end do
  | 
  | end function qmckl_compute_jastrow_champ_factor_en_gl_doc
  `----


3.2.5.3 Test

  ,----
  | /* Check if Jastrow is properly initialized */
  | assert(qmckl_jastrow_champ_provided(context));
  | 
  | {
  |   printf("factor_en_gl\n");
  |   double fd[walk_num][4][elec_num];
  |   double delta_x = 0.001;
  | 
  |   // Finite difference coefficients for gradients
  |   double coef[9] = { 1.0/280.0, -4.0/105.0,  1.0/5.0, -4.0/5.0,         0.0, 4.0/5.0, -1.0/5.0, 4.0/105.0, -1.0/280.0 };
  | 
  |   // Finite difference coefficients for Laplacian
  |   double coef2[9]= {-1.0/560.0,	 8.0/315.0, -1.0/5.0,  8.0/5.0, -205.0/72.0, 8.0/5.0, -1.0/5.0,	8.0/315.0, -1.0/560.0 };
  | 
  |   qmckl_exit_code rc;
  | 
  |   int64_t walk_num;
  |   rc = qmckl_get_electron_walk_num(context, &walk_num);
  |   if (rc != QMCKL_SUCCESS) {
  |     return rc;
  |   }
  | 
  |   int64_t elec_num;
  |   rc = qmckl_get_electron_num(context, &elec_num);
  |   if (rc != QMCKL_SUCCESS) {
  |     return rc;
  |   }
  | 
  |   double elec_coord[walk_num][elec_num][3];
  |   rc = qmckl_get_electron_coord (context, 'N', &(elec_coord[0][0][0]), 3*walk_num*elec_num);
  | 
  |   double temp_coord[walk_num][elec_num][3];
  |   memcpy(&(temp_coord[0][0][0]), &(elec_coord[0][0][0]), sizeof(temp_coord));
  | 
  |   double function_values[walk_num];
  | 
  |   memset(&(fd[0][0][0]), 0, sizeof(fd));
  | 
  |   for (int64_t i = 0; i < elec_num; i++) {
  |     for (int64_t k = 0; k < 3; k++) {
  |       for (int64_t m = -4; m <= 4; m++) {          // Apply finite difference displacement
  | 
  |         for (int64_t nw=0 ; nw<walk_num ; nw++) {
  |           temp_coord[nw][i][k] = elec_coord[nw][i][k] + (double) m * delta_x;
  |         }
  | 
  |         // Update coordinates in the context
  |         rc = qmckl_set_electron_coord (context, 'N', walk_num, &(temp_coord[0][0][0]), walk_num*3*elec_num);
  |         assert(rc == QMCKL_SUCCESS);
  | 
  |         // Call the provided function
  |         rc = qmckl_get_jastrow_champ_factor_en(context, &(function_values[0]), walk_num);
  |         assert(rc == QMCKL_SUCCESS);
  | 
  |         // Accumulate derivative using finite-difference coefficients
  |         for (int64_t nw=0 ; nw<walk_num ; nw++) {
  |           fd[nw][k][i] += coef [m + 4] * function_values[nw];
  |           fd[nw][3][i] += coef2[m + 4] * function_values[nw];
  |         }
  |       }
  |       for (int64_t nw=0 ; nw<walk_num ; nw++) {
  |         temp_coord[nw][i][k] = elec_coord[nw][i][k];
  |       }
  |     }
  |   }
  | 
  |   // Reset coordinates in the context
  |   rc = qmckl_set_electron_coord (context, 'N', walk_num, &(elec_coord[0][0][0]), walk_num*3*elec_num);
  |   assert(rc == QMCKL_SUCCESS);
  | 
  |   // Normalize by the step size
  |   for (int64_t nw=0 ; nw<walk_num ; nw++) {
  |     for (int64_t k = 0; k < 4; k++) {
  |       for (int64_t i = 0; i < elec_num; i++) {
  |           fd[nw][k][i] /= delta_x;
  |       }
  |     }
  |     for (int64_t i = 0; i < elec_num; i++) {
  |       fd[nw][3][i] /= delta_x;
  |     }
  |   }
  | 
  | 
  |   double factor_en_gl[walk_num][4][elec_num];
  |   rc = qmckl_check(context,
  |                    qmckl_get_jastrow_champ_factor_en_gl(context,
  |                                                         &(factor_en_gl[0][0][0]),
  |                                                         walk_num*4*elec_num)
  |                    );
  | 
  |   assert(rc == QMCKL_SUCCESS);
  | 
  |   for (int nw = 0; nw < walk_num; nw++){
  |     for (int i = 0; i < elec_num; i++) {
  |       for (int k = 0; k < 3; k++){
  |         printf("%.10f\t", fd[nw][k][i]);
  |         printf("%.10f\n", factor_en_gl[nw][k][i]);
  |         fflush(stdout);
  |         assert(fabs(fd[nw][k][i] - factor_en_gl[nw][k][i]) < 1.e-8);
  |       }
  |       int k=3;
  |       if (fabs(fd[nw][k][i] - factor_en_gl[nw][k][i]) > 1.e-5) {
  |         printf("i=%d doc=%f hpc=%f\n", i, fd[nw][k][i], factor_en_gl[nw][k][i]);
  |         fflush(stdout);
  |       }
  |       assert(fabs(fd[nw][k][i] - factor_en_gl[nw][k][i]) < 1.e-5);
  |     }
  |   }
  |   printf("OK\n");
  | }
  | 
  | {
  |   printf("factor_en_gl_hpc\n");
  | 
  |   double en_distance_rescaled[walk_num][nucl_num][elec_num];
  |   rc = qmckl_get_jastrow_champ_en_distance_rescaled(context,
  |                                                     &(en_distance_rescaled[0][0][0]),
  |                                                     walk_num*nucl_num*elec_num);
  |   assert(rc == QMCKL_SUCCESS);
  | 
  |   double en_distance_rescaled_gl[walk_num][4][elec_num][nucl_num];
  |   rc = qmckl_get_jastrow_champ_en_distance_rescaled_gl(context,
  |                                                        &(en_distance_rescaled_gl[0][0][0][0]),
  |                                                        walk_num*4*elec_num*nucl_num);
  |   assert(rc == QMCKL_SUCCESS);
  | 
  |   double factor_en_gl_doc[walk_num*4*elec_num];
  |   memset(&(factor_en_gl_doc[0]), 0, sizeof(factor_en_gl_doc));
  |   rc = qmckl_compute_jastrow_champ_factor_en_gl_doc(context, walk_num, elec_num,
  |        nucl_num, type_nucl_num, type_nucl_vector, aord_num, &(a_vector[0]),
  |        &(en_distance_rescaled[0][0][0]), &(en_distance_rescaled_gl[0][0][0][0]), &(factor_en_gl_doc[0]));
  |   assert(rc == QMCKL_SUCCESS);
  | 
  |   double factor_en_gl_hpc[walk_num*4*elec_num];
  |   memset(&(factor_en_gl_hpc[0]), 0, sizeof(factor_en_gl_hpc));
  |   rc = qmckl_compute_jastrow_champ_factor_en_gl_hpc(context, walk_num, elec_num,
  |        nucl_num, type_nucl_num, type_nucl_vector, aord_num, &(a_vector[0]),
  |        &(en_distance_rescaled[0][0][0]), &(en_distance_rescaled_gl[0][0][0][0]), &(factor_en_gl_hpc[0]));
  |   assert(rc == QMCKL_SUCCESS);
  | 
  |   for (int64_t i = 0; i < walk_num*4*elec_num; i++) {
  |     if (fabs(factor_en_gl_doc[i] - factor_en_gl_hpc[i]) > 1.e-12) {
  |       printf("i=%ld doc=%f hpc=%f\n", i, factor_en_gl_doc[i], factor_en_gl_hpc[i]);
  |       fflush(stdout);
  |     }
  |     assert(fabs(factor_en_gl_doc[i] - factor_en_gl_hpc[i]) < 1.e-8);
  |   }
  | }
  `----


3.3 Electron-electron-nucleus component
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

3.3.1 Electron-electron rescaled distances in $J_\text{eeN}$
------------------------------------------------------------

  `een_rescaled_e' stores the table of the rescaled distances between
  all pairs of electrons and raised to the power \(p\) defined by
  `cord_num':

  \[ [g_e(r)_{ij}]^p = \begin{cases} \exp\left(-p\,\kappa_\text{e}\,
      r_{ij}\right) & \text{for } i \ne j \\ 0 & \text{for } i = j \]

  where \(r_{ij}\) is the matrix of electron-electron distances.


3.3.1.1 Get

  ,----
  | qmckl_exit_code
  | qmckl_get_jastrow_champ_een_rescaled_e(qmckl_context context,
  |                                                 double* const een_rescaled_e,
  |                                                 const int64_t size_max);
  `----


3.3.1.2 Compute

  ---------------------------------------------------------------------------------------------------------------------------------------
   Variable             Type                                                In/Out  Description                                          
  ---------------------------------------------------------------------------------------------------------------------------------------
   `context'            `qmckl_context'                                     in      Global state                                         
   `walk_num'           `int64_t'                                           in      Number of walkers                                    
   `elec_num'           `int64_t'                                           in      Number of electrons                                  
   `cord_num'           `int64_t'                                           in      Order of polynomials                                 
   `rescale_factor_ee'  `double'                                            in      Factor to rescale ee distances                       
   `ee_distance'        `double[walk_num][elec_num][elec_num]'              in      Electron-electron distances for each walker          
   `een_rescaled_e'     `double[walk_num][0:cord_num][elec_num][elec_num]'  out     Electron-electron rescaled distances for each walker 
  ---------------------------------------------------------------------------------------------------------------------------------------

  ,----
  | function qmckl_compute_een_rescaled_e_doc( &
  |      context, walk_num, elec_num, cord_num, rescale_factor_ee,  &
  |      ee_distance, een_rescaled_e) &
  |      result(info) bind(C)
  |   use, intrinsic :: iso_c_binding
  |   use qmckl
  |   implicit none
  |   integer(qmckl_context), intent(in), value :: context
  |   integer (c_int64_t) , intent(in)  , value :: walk_num
  |   integer (c_int64_t) , intent(in)  , value :: elec_num
  |   integer (c_int64_t) , intent(in)  , value :: cord_num
  |   real    (c_double ) , intent(in)  , value :: rescale_factor_ee
  |   real    (c_double ) , intent(in)          :: ee_distance(elec_num,elec_num,walk_num)
  |   real    (c_double ) , intent(out)         :: een_rescaled_e(elec_num,elec_num,0:cord_num,walk_num)
  |   integer(qmckl_exit_code)                  :: info
  | 
  |   double precision                    :: x
  |   integer*8                           :: i, j, k, l, nw
  | 
  |   info = QMCKL_SUCCESS
  | 
  |   if (context == QMCKL_NULL_CONTEXT) then
  |      info = QMCKL_INVALID_CONTEXT
  |      return
  |   endif
  | 
  |   if (walk_num <= 0) then
  |      info = QMCKL_INVALID_ARG_2
  |      return
  |   endif
  | 
  |   if (elec_num <= 0) then
  |      info = QMCKL_INVALID_ARG_3
  |      return
  |   endif
  | 
  |   if (cord_num < 0) then
  |      info = QMCKL_INVALID_ARG_4
  |      return
  |   endif
  | 
  |   do nw = 1, walk_num
  |      do l = 0, cord_num
  |         do j = 1, elec_num
  |            do i = 1, elec_num
  |               een_rescaled_e(i, j, l, nw) = dexp(-rescale_factor_ee * ee_distance(i, j, nw))**l
  |            end do
  |            een_rescaled_e(j, j, l, nw) = 0.d0
  |         end do
  |      end do
  |   end do
  | 
  | end function qmckl_compute_een_rescaled_e_doc
  `----

  ,----
  | qmckl_exit_code qmckl_compute_een_rescaled_e_hpc (const qmckl_context context,
  |                                                   const int64_t walk_num,
  |                                                   const int64_t elec_num,
  |                                                   const int64_t cord_num,
  |                                                   const double rescale_factor_ee,
  |                                                   const double* ee_distance,
  |                                                   double* const een_rescaled_e ) {
  | 
  | return qmckl_compute_een_rescaled_e_doc (context,
  |                                                   walk_num,
  |                                                   elec_num,
  |                                                   cord_num,
  |                                                   rescale_factor_ee,
  |                                                   ee_distance,
  |                                                   een_rescaled_e ) ;
  |   if (context == QMCKL_NULL_CONTEXT) {
  |     return QMCKL_INVALID_CONTEXT;
  |   }
  | 
  |   if (walk_num <= 0) {
  |     return QMCKL_INVALID_ARG_2;
  |   }
  | 
  |   if (elec_num <= 0) {
  |     return QMCKL_INVALID_ARG_3;
  |   }
  | 
  |   if (cord_num < 0) {
  |     return QMCKL_INVALID_ARG_4;
  |   }
  | 
  |   // Prepare table of exponentiated distances raised to appropriate power
  |   // init
  | 
  |   const size_t elec_pairs = (size_t) (elec_num * (elec_num - 1)) / 2;
  |   const size_t len_een_ij = (size_t) elec_pairs * (cord_num + 1);
  | 
  |   // number of elements for the een_rescaled_e_ij[N_e*(N_e-1)/2][cord+1]
  |   // probably in C is better [cord+1, Ne*(Ne-1)/2]
  |   // elec_pairs = (elec_num * (elec_num - 1)) / 2;
  |   // len_een_ij = elec_pairs * (cord_num + 1);
  |   const size_t e2 = elec_num*elec_num;
  | 
  | #ifdef HAVE_OPENMP
  | #pragma omp parallel
  | #endif
  |   {
  |     double* restrict een_rescaled_e_ij = calloc(len_een_ij,sizeof(double));
  | 
  |     for (size_t kk = 0; kk < elec_pairs ; ++kk) {
  |       een_rescaled_e_ij[kk]= 1.0;
  |     }
  | 
  | #ifdef HAVE_OPENMP
  | #pragma omp for
  | #endif
  |   for (size_t nw = 0; nw < (size_t) walk_num; ++nw) {
  | 
  |     size_t kk = 0;
  |     for (size_t i = 0; i < (size_t) elec_num; ++i) {
  |       double* restrict ee1 = &een_rescaled_e_ij[kk + elec_pairs];
  |       const double* restrict ee2 = &ee_distance[i*elec_num + nw*e2];
  | #ifdef HAVE_OPENMP
  | #pragma omp simd
  | #endif
  |       for (size_t j = 0; j < i; ++j) {
  |         ee1[j] = -rescale_factor_ee * ee2[j];
  |       }
  |       ee1[i] = 0.;
  |       kk += i;
  |     }
  | 
  | #ifdef HAVE_OPENMP
  | #pragma omp simd
  | #endif
  |     for (size_t k = elec_pairs; k < 2*elec_pairs; ++k) {
  |         een_rescaled_e_ij[k] = exp(een_rescaled_e_ij[k]);
  |     }
  | 
  | 
  |     const double* const ee3 = &een_rescaled_e_ij[elec_pairs];
  |     for (size_t l = 2; l < (size_t) (cord_num+1); ++l) {
  |       double* restrict ee1 = &een_rescaled_e_ij[l*elec_pairs];
  |       const double* restrict ee2 = &een_rescaled_e_ij[(l-1)*elec_pairs];
  | #ifdef HAVE_OPENMP
  | #pragma omp simd
  | #endif
  |       for (size_t k = 0; k < elec_pairs; ++k) {
  |         // een_rescaled_e_ij(k, l + 1) = een_rescaled_e_ij(k, l + 1 - 1) * een_rescaled_e_ij(k, 2)
  | 
  |         // een_rescaled_e_ij[k+l*elec_pairs] = een_rescaled_e_ij[k + (l - 1)*elec_pairs] *
  |         //  een_rescaled_e_ij[k + elec_pairs];
  |         ee1[k] = ee2[k] * ee3[k];
  |       }
  |     }
  | 
  | 
  |     double* restrict const een_rescaled_e_ = &(een_rescaled_e[nw*(cord_num+1)*e2]);
  | 
  |     // prepare the actual een table
  | #ifdef HAVE_OPENMP
  | #pragma omp simd
  | #endif
  |     for (size_t i = 0; i < e2; ++i){
  |         een_rescaled_e_[i] = 1.0;
  |     }
  | 
  |     for ( size_t l = 1; l < (size_t) (cord_num+1); ++l) {
  |       double* x = een_rescaled_e_ij + l*elec_pairs;
  |       double* const een_rescaled_e__ = &(een_rescaled_e_[l*e2]);
  |       double* een_rescaled_e_i = een_rescaled_e__;
  |       for (size_t i = 0; i < (size_t) elec_num; ++i) {
  |         for (size_t j = 0; j < i; ++j) {
  |           een_rescaled_e_i[j] = *x;
  |           een_rescaled_e__[i + j*elec_num] = *x;
  |           x += 1;
  |         }
  |         een_rescaled_e_i += elec_num;
  |       }
  |     }
  | 
  |     double* const x0 = &(een_rescaled_e[nw*e2*(cord_num+1)]);
  |     for (size_t l = 0; l < (size_t) (cord_num + 1); ++l) {
  |       double* x1 = &(x0[l*e2]);
  |       for (size_t j = 0; j < (size_t) elec_num; ++j) {
  |         *x1 = 0.0;
  |         x1 += 1+elec_num;
  |       }
  |     }
  | 
  |   }
  |   free(een_rescaled_e_ij);
  |   } // OpenMP
  | 
  |   return QMCKL_SUCCESS;
  | }
  `----

  ,----
  | qmckl_exit_code qmckl_compute_een_rescaled_e_doc (
  |       const qmckl_context context,
  |       const int64_t walk_num,
  |       const int64_t elec_num,
  |       const int64_t cord_num,
  |       const double rescale_factor_ee,
  |       const double* ee_distance,
  |       double* const een_rescaled_e );
  `----

  ,----
  | qmckl_exit_code qmckl_compute_een_rescaled_e_hpc (
  |       const qmckl_context context,
  |       const int64_t walk_num,
  |       const int64_t elec_num,
  |       const int64_t cord_num,
  |       const double rescale_factor_ee,
  |       const double* ee_distance,
  |       double* const een_rescaled_e );
  `----

  ,----
  |     qmckl_exit_code qmckl_compute_een_rescaled_e (
  |           const qmckl_context context,
  |           const int64_t walk_num,
  |           const int64_t elec_num,
  |           const int64_t cord_num,
  |           const double rescale_factor_ee,
  |           const double* ee_distance,
  |           double* const een_rescaled_e ) {
  | 
  | #ifdef HAVE_HPC
  |     return qmckl_compute_een_rescaled_e_hpc
  | #else
  |     return qmckl_compute_een_rescaled_e_doc
  | #endif
  |       (context, walk_num, elec_num, cord_num, rescale_factor_ee, ee_distance, een_rescaled_e);
  |     }
  `----


3.3.1.3 Test

  ,----
  | assert(qmckl_electron_provided(context));
  | {
  | 
  |   double een_rescaled_e[walk_num][(cord_num + 1)][elec_num][elec_num];
  |   rc = qmckl_get_jastrow_champ_een_rescaled_e(context, &(een_rescaled_e[0][0][0][0]),elec_num*elec_num*(cord_num+1)*walk_num);
  | 
  |   assert( fabs(een_rescaled_e[0][0][0][0] - (0.0)) < 1.e-10 );
  |   assert( fabs(een_rescaled_e[0][0][0][1] - (1.0)) < 1.e-10 );
  |   assert( fabs(een_rescaled_e[0][0][0][2] - (1.0)) < 1.e-10 );
  |   assert( fabs(een_rescaled_e[0][0][1][0] - (1.0)) < 1.e-10 );
  |   assert( fabs(een_rescaled_e[0][0][1][1] - (0.0)) < 1.e-10 );
  |   assert( fabs(een_rescaled_e[0][0][1][2] - (1.0)) < 1.e-10 );
  |   assert( fabs(een_rescaled_e[0][0][2][0] - (1.0)) < 1.e-10 );
  |   assert( fabs(een_rescaled_e[0][0][2][1] - (1.0)) < 1.e-10 );
  |   assert( fabs(een_rescaled_e[0][0][2][2] - (0.0)) < 1.e-10 );
  |   assert( fabs(een_rescaled_e[0][1][0][0] - (0.0)) < 1.e-10 );
  |   assert( fabs(een_rescaled_e[0][1][0][1] - (0.6191495547586775)) < 1.e-10 );
  |   assert( fabs(een_rescaled_e[0][1][0][2] - (0.2211015082992776)) < 1.e-10 );
  |   assert( fabs(een_rescaled_e[0][1][1][0] - (0.6191495547586775)) < 1.e-10 );
  |   assert( fabs(een_rescaled_e[0][1][1][1] - (0.0)) < 1.e-10 );
  |   assert( fabs(een_rescaled_e[0][1][1][2] - (0.1891080158548495)) < 1.e-10 );
  |   assert( fabs(een_rescaled_e[0][1][2][0] - (0.2211015082992776)) < 1.e-10 );
  |   assert( fabs(een_rescaled_e[0][1][2][1] - (0.1891080158548495)) < 1.e-10 );
  |   assert( fabs(een_rescaled_e[0][1][2][2] - (0.0)) < 1.e-10 );
  |   assert( fabs(een_rescaled_e[0][2][0][0] - (0.0)) < 1.e-10 );
  |   assert( fabs(een_rescaled_e[0][2][0][1] - (0.38334617115786856)) < 1.e-10 );
  |   assert( fabs(een_rescaled_e[0][2][0][2] - (0.048885876972215525)) < 1.e-10 );
  |   assert( fabs(een_rescaled_e[0][2][1][0] - (0.38334617115786856)) < 1.e-10 );
  |   assert( fabs(een_rescaled_e[0][2][1][1] - (0.0)) < 1.e-10 );
  |   assert( fabs(een_rescaled_e[0][2][1][2] - (0.03576184166055801)) < 1.e-10 );
  |   assert( fabs(een_rescaled_e[0][2][2][0] - (0.048885876972215525)) < 1.e-10 );
  |   assert( fabs(een_rescaled_e[0][2][2][1] - (0.03576184166055801)) < 1.e-10 );
  |   assert( fabs(een_rescaled_e[0][2][2][2] - (0.0)) < 1.e-10 );
  |   assert( fabs(een_rescaled_e[0][3][0][0] - (0.0)) < 1.e-10 );
  |   assert( fabs(een_rescaled_e[0][3][0][1] - (0.23734861119083814)) < 1.e-10 );
  |   assert( fabs(een_rescaled_e[0][3][0][2] - (0.010808741133089782)) < 1.e-10 );
  |   assert( fabs(een_rescaled_e[0][3][1][0] - (0.23734861119083814)) < 1.e-10 );
  |   assert( fabs(een_rescaled_e[0][3][1][1] - (0.0)) < 1.e-10 );
  |   assert( fabs(een_rescaled_e[0][3][1][2] - (0.006762850919743422)) < 1.e-10 );
  |   assert( fabs(een_rescaled_e[0][3][2][0] - (0.010808741133089782)) < 1.e-10 );
  |   assert( fabs(een_rescaled_e[0][3][2][1] - (0.006762850919743422)) < 1.e-10 );
  |   assert( fabs(een_rescaled_e[0][3][2][2] - (0.0)) < 1.e-10 );
  |   assert( fabs(een_rescaled_e[0][4][0][0] - (0.0)) < 1.e-10 );
  |   assert( fabs(een_rescaled_e[0][4][0][1] - (0.14695428694139787)) < 1.e-10 );
  |   assert( fabs(een_rescaled_e[0][4][0][2] - (0.002389828967342592)) < 1.e-10 );
  |   assert( fabs(een_rescaled_e[0][4][1][0] - (0.14695428694139787)) < 1.e-10 );
  |   assert( fabs(een_rescaled_e[0][4][1][1] - (0.0)) < 1.e-10 );
  |   assert( fabs(een_rescaled_e[0][4][1][2] - (0.0012789093189548221)) < 1.e-10 );
  |   assert( fabs(een_rescaled_e[0][4][2][0] - (0.002389828967342592)) < 1.e-10 );
  |   assert( fabs(een_rescaled_e[0][4][2][1] - (0.0012789093189548221)) < 1.e-10 );
  |   assert( fabs(een_rescaled_e[0][4][2][2] - (0.0)) < 1.e-10 );
  |   assert( fabs(een_rescaled_e[0][5][0][0] - (0.0)) < 1.e-10 );
  |   assert( fabs(een_rescaled_e[0][5][0][1] - (0.09098668132964542)) < 1.e-10 );
  |   assert( fabs(een_rescaled_e[0][5][0][2] - (0.0005283947892567522)) < 1.e-10 );
  |   assert( fabs(een_rescaled_e[0][5][1][0] - (0.09098668132964542)) < 1.e-10 );
  |   assert( fabs(een_rescaled_e[0][5][1][1] - (0.0)) < 1.e-10 );
  |   assert( fabs(een_rescaled_e[0][5][1][2] - (0.0002418520037658232)) < 1.e-10 );
  |   assert( fabs(een_rescaled_e[0][5][2][0] - (0.0005283947892567522)) < 1.e-10 );
  |   assert( fabs(een_rescaled_e[0][5][2][1] - (0.0002418520037658232)) < 1.e-10 );
  |   assert( fabs(een_rescaled_e[0][5][2][2] - (0.0)) < 1.e-10 );
  | }
  | 
  | {
  |   printf("een_rescaled_e_hpc\n");
  |   double ee_distance[walk_num * elec_num * elec_num];
  |   rc = qmckl_get_electron_ee_distance(context, &(ee_distance[0]), walk_num*elec_num*elec_num);
  |   assert(rc == QMCKL_SUCCESS);
  | 
  |   double een_rescaled_e_doc[walk_num][cord_num+1][elec_num][elec_num];
  |   memset(&(een_rescaled_e_doc[0][0][0][0]), 0, sizeof(een_rescaled_e_doc));
  |   rc = qmckl_compute_een_rescaled_e(context, walk_num, elec_num, cord_num,
  |                                     rescale_factor_ee, &(ee_distance[0]), &(een_rescaled_e_doc[0][0][0][0]));
  |   assert(rc == QMCKL_SUCCESS);
  | 
  |   double een_rescaled_e_hpc[walk_num][cord_num+1][elec_num][elec_num];
  |   memset(&(een_rescaled_e_hpc[0][0][0][0]), 0, sizeof(een_rescaled_e_hpc));
  |   rc = qmckl_compute_een_rescaled_e_hpc(context, walk_num, elec_num, cord_num,
  |                                         rescale_factor_ee, &(ee_distance[0]), &(een_rescaled_e_hpc[0][0][0][0]));
  |   assert(rc == QMCKL_SUCCESS);
  | 
  |   for (int64_t i = 0; i < walk_num; i++) {
  |     for (int64_t j = 0; j < cord_num+1; j++) {
  |       for (int64_t k = 0; k < elec_num; k++) {
  |         for (int64_t l = 0; l < elec_num; l++) {
  |           if (fabs(een_rescaled_e_doc[i][j][k][l] - een_rescaled_e_hpc[i][j][k][l]) > 1.e-12) {
  |             printf("i=%ld j=%ld k=%ld l=%ld doc=%f hpc=%f\n", i, j, k, l, een_rescaled_e_doc[i][j][k][l], een_rescaled_e_hpc[i][j][k][l]);
  |             fflush(stdout);
  |           }
  |           assert(fabs(een_rescaled_e_doc[i][j][k][l] - een_rescaled_e_hpc[i][j][k][l]) < 1.e-8);
  |         }
  |       }
  |     }
  |   }
  | }
  `----


3.3.2 Electron-electron rescaled distances derivatives in $J_\text{eeN}$
------------------------------------------------------------------------

  `een_rescaled_e_gl' stores the table of the derivatives of the
  rescaled distances between all pairs of electrons and raised to the
  power $p$ defined by `cord_num'.  Here we take its derivatives
  required for the een jastrow_champ.

  \[ \frac{\partial}{\partial x} \left[ {g_\text{e}(r)}\right]^p =
  -\frac{x}{r} \kappa_\text{e}\, p\,\left[ {g_\text{e}(r)}\right]^p \]

  \[ \Delta \left[ {g_\text{e}(r)}\right]^p = \kappa_\text{e}\,
      p\,\left[ - \frac{2}{r} + \kappa_\text{e}\, p \right] \left[
      {g_\text{e}(r)} \right]^p \]

  Derivatives are set to zero at $r_{ii}$ to avoid NaNs.


3.3.2.1 Get

  ,----
  | qmckl_exit_code
  | qmckl_get_jastrow_champ_een_rescaled_e_gl(qmckl_context context,
  |                                           double* const een_rescaled_e_gl,
  |                                           const int64_t size_max);
  `----


3.3.2.2 Compute

  --------------------------------------------------------------------------------------------------------------------------
   Variable             Type                                                   In/Out  Description                          
  --------------------------------------------------------------------------------------------------------------------------
   `context'            `qmckl_context'                                        in      Global state                         
   `walk_num'           `int64_t'                                              in      Number of walkers                    
   `elec_num'           `int64_t'                                              in      Number of electrons                  
   `cord_num'           `int64_t'                                              in      Order of polynomials                 
   `rescale_factor_ee'  `double'                                               in      Factor to rescale ee distances       
   `coord_ee'           `double[3][walk_num][elec_num]'                        in      Electron coordinates                 
   `ee_distance'        `double[walk_num][elec_num][elec_num]'                 in      Electron-electron distances          
   `een_rescaled_e'     `double[walk_num][0:cord_num][elec_num][elec_num]'     in      Electron-electron distances          
   `een_rescaled_e_gl'  `double[walk_num][0:cord_num][elec_num][4][elec_num]'  out     Electron-electron rescaled distances 
  --------------------------------------------------------------------------------------------------------------------------

  ,----
  | function qmckl_compute_jastrow_champ_factor_een_rescaled_e_gl_doc( &
  |      context, walk_num, elec_num, cord_num, rescale_factor_ee,  &
  |      coord_ee, ee_distance, een_rescaled_e, een_rescaled_e_gl) &
  |      result(info) bind(C)
  |   use, intrinsic :: iso_c_binding
  |   use qmckl
  |   implicit none
  |   integer(qmckl_context), intent(in), value  :: context
  |   integer(c_int64_t)    , intent(in), value  :: walk_num
  |   integer(c_int64_t)    , intent(in), value  :: elec_num
  |   integer(c_int64_t)    , intent(in), value  :: cord_num
  |   real(c_double)        , intent(in), value  :: rescale_factor_ee
  |   real(c_double)        , intent(in)  :: coord_ee(elec_num,walk_num,3)
  |   real(c_double)        , intent(in)  :: ee_distance(elec_num,elec_num,walk_num)
  |   real(c_double)        , intent(in)  :: een_rescaled_e(elec_num,elec_num,0:cord_num,walk_num)
  |   real(c_double)        , intent(out) :: een_rescaled_e_gl(elec_num,4,elec_num,0:cord_num,walk_num)
  |   integer(qmckl_exit_code)            :: info
  | 
  |   double precision, allocatable       :: elec_dist_gl(:,:,:)
  |   double precision                    :: x, kappa_l
  |   integer*8                           :: i, j, k, l, nw, ii
  | 
  |   double precision  :: rij_inv(elec_num)
  | 
  | 
  |   allocate(elec_dist_gl(elec_num, 4, elec_num))
  |   elec_dist_gl = 0.d0
  |   een_rescaled_e_gl = 0.d0
  | 
  |   info = QMCKL_SUCCESS
  | 
  |   if (context == QMCKL_NULL_CONTEXT) then
  |      info = QMCKL_INVALID_CONTEXT
  |      return
  |   endif
  | 
  |   if (walk_num <= 0) then
  |      info = QMCKL_INVALID_ARG_2
  |      return
  |   endif
  | 
  |   if (elec_num <= 0) then
  |      info = QMCKL_INVALID_ARG_3
  |      return
  |   endif
  | 
  |   if (cord_num < 0) then
  |      info = QMCKL_INVALID_ARG_4
  |      return
  |   endif
  | 
  |   do nw = 1, walk_num
  | 
  |      ! Prepare table of exponentiated distances raised to appropriate power
  |      do j = 1, elec_num
  |         do i = 1, j-1
  |            rij_inv(i) = 1.0d0 / ee_distance(i, j, nw)
  |         enddo
  |         rij_inv(j) = 0.0d0
  |         do i = j+1, elec_num
  |            rij_inv(i) = 1.0d0 / ee_distance(i, j, nw)
  |         enddo
  |         do i = 1, elec_num
  |            do ii = 1, 3
  |               elec_dist_gl(i, ii, j) = (coord_ee(i, nw, ii) - coord_ee(j, nw, ii)) * rij_inv(i)
  |            end do
  |            elec_dist_gl(i, 4, j) = 2.0d0 * rij_inv(i)
  |         end do
  |      end do
  | 
  |      !   Not necessary: should be set to zero by qmckl_malloc
  |      een_rescaled_e_gl(:,:,:,0,nw) = 0.d0
  | 
  |      do l = 1, cord_num
  |         kappa_l = -dble(l) * rescale_factor_ee
  |         do j = 1, elec_num
  |            do i = 1, elec_num
  |               if (i /= j) then
  |                  een_rescaled_e_gl(i, 1, j, l, nw) = kappa_l *  elec_dist_gl(i, 1, j) * een_rescaled_e(i,j,l,nw)
  |                  een_rescaled_e_gl(i, 2, j, l, nw) = kappa_l *  elec_dist_gl(i, 2, j) * een_rescaled_e(i,j,l,nw)
  |                  een_rescaled_e_gl(i, 3, j, l, nw) = kappa_l *  elec_dist_gl(i, 3, j) * een_rescaled_e(i,j,l,nw)
  |                  een_rescaled_e_gl(i, 4, j, l, nw) = kappa_l * (elec_dist_gl(i, 4, j) + kappa_l) * een_rescaled_e(i,j,l,nw)
  |               else
  |                  een_rescaled_e_gl(i, 1, j, l, nw) = 0.d0
  |                  een_rescaled_e_gl(i, 2, j, l, nw) = 0.d0
  |                  een_rescaled_e_gl(i, 3, j, l, nw) = 0.d0
  |                  een_rescaled_e_gl(i, 4, j, l, nw) = 0.d0
  |               end if
  |            end do
  |         end do
  |      end do
  |   end do
  | 
  | end function qmckl_compute_jastrow_champ_factor_een_rescaled_e_gl_doc
  `----

  ,----
  | qmckl_exit_code
  | qmckl_compute_jastrow_champ_factor_een_rescaled_e_gl_hpc (const qmckl_context context,
  |                                                           const int64_t walk_num,
  |                                                           const int64_t elec_num,
  |                                                           const int64_t cord_num,
  |                                                           const double rescale_factor_ee,
  |                                                           const double* coord_ee,
  |                                                           const double* ee_distance,
  |                                                           const double* een_rescaled_e,
  |                                                           double* const een_rescaled_e_gl )
  | {
  |   if (context == QMCKL_NULL_CONTEXT) return QMCKL_INVALID_CONTEXT;
  |   if (walk_num <= 0) return QMCKL_INVALID_ARG_2;
  |   if (elec_num <= 0) return QMCKL_INVALID_ARG_3;
  |   if (cord_num < 0) return QMCKL_INVALID_ARG_4;
  | 
  | #ifdef HAVE_OPENMP
  | #pragma omp parallel
  | #endif
  |   {
  | 
  |     double* restrict elec_dist_gl0 = (double*) calloc(elec_num * elec_num, sizeof(double));
  |     double* restrict elec_dist_gl1 = (double*) calloc(elec_num * elec_num, sizeof(double));
  |     double* restrict elec_dist_gl2 = (double*) calloc(elec_num * elec_num, sizeof(double));
  |     double* restrict elec_dist_gl3 = (double*) calloc(elec_num * elec_num, sizeof(double));
  |     assert (elec_dist_gl0 != NULL);
  |     assert (elec_dist_gl1 != NULL);
  |     assert (elec_dist_gl2 != NULL);
  |     assert (elec_dist_gl3 != NULL);
  | 
  | #ifdef HAVE_OPENMP
  | #pragma omp for
  | #endif
  |     for (int64_t nw = 0; nw < walk_num; ++nw) {
  | 
  |       for (int64_t j=0; j<elec_num; ++j) {
  | 
  |         double rij_inv[elec_num];
  | 
  | #ifdef HAVE_OPENMP
  | #pragma omp simd
  | #endif
  |         for (int64_t i = 0; i < elec_num ; ++i) {
  |           rij_inv[i] = ee_distance[i+j*elec_num+nw*elec_num*elec_num];
  |         }
  | 
  |         rij_inv[j] = 1.0;
  | #ifdef HAVE_OPENMP
  | #pragma omp simd
  | #endif
  |         for (int64_t i = 0; i < elec_num ; ++i) {
  |           rij_inv[i] = 1.0/rij_inv[i];
  |         }
  |         rij_inv[j] = 0.0;
  | 
  |         const double xj = coord_ee[j+elec_num*nw];
  |         const double yj = coord_ee[j+elec_num*(nw+walk_num) ];
  |         const double zj = coord_ee[j+elec_num*(nw+walk_num*2)];
  | 
  | #ifdef HAVE_OPENMP
  | #pragma omp simd
  | #endif
  |         for (int64_t i = 0; i < elec_num ; ++i) {
  | 
  |           const double xi = coord_ee[i+elec_num*nw];
  |           const double yi = coord_ee[i+elec_num*(nw+walk_num) ];
  |           const double zi = coord_ee[i+elec_num*(nw+walk_num*2)];
  | 
  |           elec_dist_gl0[i + j * elec_num] = rij_inv[i] * (xi-xj);
  |           elec_dist_gl1[i + j * elec_num] = rij_inv[i] * (yi-yj);
  |           elec_dist_gl2[i + j * elec_num] = rij_inv[i] * (zi-zj);
  |           elec_dist_gl3[i + j * elec_num] = rij_inv[i] + rij_inv[i];
  |         }
  |       }
  | 
  |       double* restrict eegl = &een_rescaled_e_gl[elec_num*4*elec_num*(cord_num+1)*nw];
  |       memset(eegl, 0, 4*elec_num*elec_num*sizeof(double));
  | 
  |       for (int64_t l=1; l<=cord_num; ++l) {
  | 
  |         const double kappa_l  = -rescale_factor_ee * (double) l;
  | 
  |         for (int64_t j=0; j<elec_num; ++j) {
  | 
  |           double* restrict eegl =
  |             &een_rescaled_e_gl[elec_num*4*(j+elec_num*(l+(cord_num+1)*nw))];
  | 
  |           const double* restrict ee =
  |             &een_rescaled_e[elec_num*(j+elec_num*(l+(cord_num+1)*nw))];
  | 
  | #ifdef HAVE_OPENMP
  | #pragma omp simd
  | #endif
  |           for (int64_t i=0; i<elec_num; ++i) {
  |             eegl[i           ] = kappa_l * ee[i] *  elec_dist_gl0[i+j*elec_num];
  |             eegl[i+elec_num  ] = kappa_l * ee[i] *  elec_dist_gl1[i+j*elec_num];
  |             eegl[i+elec_num*2] = kappa_l * ee[i] *  elec_dist_gl2[i+j*elec_num];
  |             eegl[i+elec_num*3] = kappa_l * ee[i] * (elec_dist_gl3[i+j*elec_num] + kappa_l);
  |           }
  |           eegl[j           ] = 0.0;
  |           eegl[j+elec_num  ] = 0.0;
  |           eegl[j+elec_num*2] = 0.0;
  |           eegl[j+elec_num*3] = 0.0;
  |         }
  |       }
  |     }
  | 
  |     free(elec_dist_gl0);
  |     free(elec_dist_gl1);
  |     free(elec_dist_gl2);
  |     free(elec_dist_gl3);
  |   }
  | 
  |   return QMCKL_SUCCESS;
  | }
  `----

  ,----
  | qmckl_exit_code qmckl_compute_jastrow_champ_factor_een_rescaled_e_gl (
  |          const qmckl_context context,
  |          const int64_t walk_num,
  |          const int64_t elec_num,
  |          const int64_t cord_num,
  |          const double rescale_factor_ee,
  |          const double* coord_ee,
  |          const double* ee_distance,
  |          const double* een_rescaled_e,
  |          double* const een_rescaled_e_gl )
  | {
  | #ifdef HAVE_HPC
  |   return qmckl_compute_jastrow_champ_factor_een_rescaled_e_gl_hpc
  | #else
  |   return qmckl_compute_jastrow_champ_factor_een_rescaled_e_gl_doc
  | #endif
  |     (context, walk_num, elec_num, cord_num, rescale_factor_ee,
  |     coord_ee, ee_distance, een_rescaled_e, een_rescaled_e_gl );
  | }
  `----


3.3.3 Electron-nucleus rescaled distances in $J_\text{eeN}$
-----------------------------------------------------------

  `een_rescaled_n' stores the table of the rescaled distances between
  electrons and nuclei raised to the power \(p\) defined by `cord_num':

  \[ [g_{\alpha}(R_{i\alpha})]^p = \exp\left(-p\, \kappa_\alpha\,
      R_{i\alpha}\right) \]

  where \(R_{i\alpha}\) is the matrix of electron-nucleus distances.


3.3.3.1 Get

  ,----
  | qmckl_exit_code
  | qmckl_get_jastrow_champ_een_rescaled_n(qmckl_context context,
  |                                  double* const een_rescaled_n,
  |                                  const int64_t size_max);
  `----


3.3.3.2 Compute

  ----------------------------------------------------------------------------------------------------------------------
   Variable             Type                                                In/Out  Description                         
  ----------------------------------------------------------------------------------------------------------------------
   `context'            `qmckl_context'                                     in      Global state                        
   `walk_num'           `int64_t'                                           in      Number of walkers                   
   `elec_num'           `int64_t'                                           in      Number of electrons                 
   `nucl_num'           `int64_t'                                           in      Number of atoms                     
   `type_nucl_num'      `int64_t'                                           in      Number of atom types                
   `type_nucl_vector'   `int64_t[nucl_num]'                                 in      Types of atoms                      
   `cord_num'           `int64_t'                                           in      Order of polynomials                
   `rescale_factor_en'  `double[nucl_num]'                                  in      Factor to rescale ee distances      
   `en_distance'        `double[walk_num][elec_num][nucl_num]'              in      Electron-nucleus distances          
   `een_rescaled_n'     `double[walk_num][0:cord_num][nucl_num][elec_num]'  out     Electron-nucleus rescaled distances 
  ----------------------------------------------------------------------------------------------------------------------

  ,----
  | function qmckl_compute_een_rescaled_n( &
  |      context, walk_num, elec_num, nucl_num, &
  |      type_nucl_num, type_nucl_vector, cord_num, rescale_factor_en,  &
  |      en_distance, een_rescaled_n) &
  |      result(info) bind(C)
  |   use, intrinsic :: iso_c_binding
  |   use qmckl
  |   implicit none
  |   integer(qmckl_context), intent(in), value :: context
  |   integer (c_int64_t) , intent(in)  , value :: walk_num
  |   integer (c_int64_t) , intent(in)  , value :: elec_num
  |   integer (c_int64_t) , intent(in)  , value :: nucl_num
  |   integer (c_int64_t) , intent(in)  , value :: type_nucl_num
  |   integer (c_int64_t) , intent(in)          :: type_nucl_vector(nucl_num)
  |   integer (c_int64_t) , intent(in)  , value :: cord_num
  |   real    (c_double ) , intent(in)          :: rescale_factor_en(nucl_num)
  |   real    (c_double ) , intent(in)          :: en_distance(nucl_num,elec_num,walk_num)
  |   real    (c_double ) , intent(out)         :: een_rescaled_n(elec_num,nucl_num,0:cord_num,walk_num)
  |   integer(qmckl_exit_code)                  :: info
  | 
  |   double precision                    :: x
  |   integer*8                           :: i, a, k, l, nw
  | 
  |   info = QMCKL_SUCCESS
  | 
  |   if (context == QMCKL_NULL_CONTEXT) then
  |      info = QMCKL_INVALID_CONTEXT
  |      return
  |   endif
  | 
  |   if (walk_num <= 0) then
  |      info = QMCKL_INVALID_ARG_2
  |      return
  |   endif
  | 
  |   if (elec_num <= 0) then
  |      info = QMCKL_INVALID_ARG_3
  |      return
  |   endif
  | 
  |   if (nucl_num <= 0) then
  |      info = QMCKL_INVALID_ARG_4
  |      return
  |   endif
  | 
  |   if (cord_num < 0) then
  |      info = QMCKL_INVALID_ARG_5
  |      return
  |   endif
  | 
  |   do nw = 1, walk_num
  | 
  |      ! prepare the actual een table
  |      een_rescaled_n(:, :, 0, nw) = 1.0d0
  | 
  |      do a = 1, nucl_num
  |         do i = 1, elec_num
  |            een_rescaled_n(i, a, 1, nw) = dexp(-rescale_factor_en(type_nucl_vector(a)+1) * en_distance(a, i, nw))
  |         end do
  |      end do
  | 
  |      do l = 2, cord_num
  |         do a = 1, nucl_num
  |            do i = 1, elec_num
  |               een_rescaled_n(i, a, l, nw) = een_rescaled_n(i, a, l - 1, nw) * een_rescaled_n(i, a, 1, nw)
  |            end do
  |         end do
  |      end do
  | 
  |   end do
  | 
  | end function qmckl_compute_een_rescaled_n
  `----

  ,----
  | /*
  | qmckl_exit_code qmckl_compute_een_rescaled_n_hpc (
  |       const qmckl_context context,
  |       const int64_t walk_num,
  |       const int64_t elec_num,
  |       const int64_t nucl_num,
  |       const int64_t type_nucl_num,
  |       int64_t* const type_nucl_vector,
  |       const int64_t cord_num,
  |       const double* rescale_factor_en,
  |       const double* en_distance,
  |       double* const een_rescaled_n ) {
  | 
  | 
  |   if (context == QMCKL_NULL_CONTEXT) {
  |     return QMCKL_INVALID_CONTEXT;
  |   }
  | 
  |   if (walk_num <= 0) {
  |     return QMCKL_INVALID_ARG_2;
  |   }
  | 
  |   if (elec_num <= 0) {
  |     return QMCKL_INVALID_ARG_3;
  |   }
  | 
  |   if (nucl_num <= 0) {
  |     return QMCKL_INVALID_ARG_4;
  |   }
  | 
  |   if (cord_num < 0) {
  |     return QMCKL_INVALID_ARG_5;
  |   }
  | 
  |   // Prepare table of exponentiated distances raised to appropriate power
  |   for (int i = 0; i < (walk_num*(cord_num+1)*nucl_num*elec_num); ++i) {
  |     een_rescaled_n[i] = 1.0;
  |   }
  | 
  |   for (int nw = 0; nw < walk_num; ++nw) {
  |     for (int a = 0; a < nucl_num; ++a) {
  |       for (int i = 0; i < elec_num; ++i) {
  |         een_rescaled_n[i + a*elec_num + nw * elec_num*nucl_num*(cord_num+1)] = 1.0;
  |         een_rescaled_n[i + a*elec_num + elec_num*nucl_num + nw*elec_num*nucl_num*(cord_num+1)] =
  |           exp(-rescale_factor_en[type_nucl_vector[a]] * en_distance[a + i*nucl_num + nw*elec_num*nucl_num]);
  |       }
  |     }
  | 
  |     for (int l = 2; l < (cord_num+1); ++l){
  |       for (int a = 0; a < nucl_num; ++a) {
  |         for (int i = 0; i < elec_num; ++i) {
  |           een_rescaled_n[i + a*elec_num + l*elec_num*nucl_num + nw*elec_num*nucl_num*(cord_num+1)] =
  |             een_rescaled_n[i + a*elec_num + (l-1)*elec_num*nucl_num + nw*elec_num*nucl_num*(cord_num+1)] *
  |             een_rescaled_n[i + a*elec_num +       elec_num*nucl_num + nw*elec_num*nucl_num*(cord_num+1)];
  |         }
  |       }
  |     }
  | 
  |   }
  | 
  |   return QMCKL_SUCCESS;
  | }
  | */
  `----


3.3.4 Electron-nucleus rescaled distances derivatives in $J_\text{eeN}$
-----------------------------------------------------------------------

  `een_rescaled_n_gl' stores the table of the derivatives of the
  rescaled distances between all electron-nucleus pairs and raised to
  the power $p$ defined by `cord_num'.  Here we take its derivatives
  required for the een jastrow_champ.

  \[ \frac{\partial}{\partial x} \left[ {g_\alpha(R_{i\alpha})}\right]^p
  = -\frac{x}{R_{i\alpha}} \kappa_\alpha\, p\,\left[
  {g_\alpha(R_{i\alpha})}\right]^p \] \[ \Delta \left[
  {g_\alpha(R_{i\alpha})}\right]^p = \frac{2}{R_{i\alpha}}
  \kappa_\alpha\, p\,\left[ {g_\alpha(R_{i\alpha})}\right]^p \right] +
  \left(\frac{\partial}{\partial x}\left[
  {g_\alpha(R_{i\alpha})}\right]^p \right)^2 +
  \left(\frac{\partial}{\partial y}\left[
  {g_\alpha(R_{i\alpha})}\right]^p \right)^2 +
  \left(\frac{\partial}{\partial z}\left[
  {g_\alpha(R_{i\alpha})}\right]^p \right)^2 \]


3.3.4.1 Get

  ,----
  | qmckl_exit_code
  | qmckl_get_jastrow_champ_een_rescaled_n_gl(qmckl_context context,
  |                                          double* const een_rescaled_n_gl,
  |                                          const int64_t size_max);
  `----


3.3.4.2 Compute

  -------------------------------------------------------------------------------------------------------------------------
   Variable             Type                                                   In/Out  Description                         
  -------------------------------------------------------------------------------------------------------------------------
   `context'            `qmckl_context'                                        in      Global state                        
   `walk_num'           `int64_t'                                              in      Number of walkers                   
   `elec_num'           `int64_t'                                              in      Number of electrons                 
   `nucl_num'           `int64_t'                                              in      Number of atoms                     
   `type_nucl_num'      `int64_t'                                              in      Number of atom types                
   `type_nucl_vector'   `int64_t[nucl_num]'                                    in      Types of atoms                      
   `cord_num'           `int64_t'                                              in      Order of polynomials                
   `rescale_factor_en'  `double[nucl_num]'                                     in      Factor to rescale ee distances      
   `coord_ee'           `double[3][walk_num][elec_num]'                        in      Electron coordinates                
   `coord_n'            `double[3][nucl_num]'                                  in      Nuclear coordinates                 
   `en_distance'        `double[walk_num][elec_num][nucl_num]'                 in      Electron-nucleus distances          
   `een_rescaled_n'     `double[walk_num][0:cord_num][nucl_num][elec_num]'     in      Electron-nucleus distances          
   `een_rescaled_n_gl'  `double[walk_num][0:cord_num][nucl_num][4][elec_num]'  out     Electron-nucleus rescaled distances 
  -------------------------------------------------------------------------------------------------------------------------

  ,----
  | function qmckl_compute_jastrow_champ_factor_een_rescaled_n_gl( &
  |      context, walk_num, elec_num, nucl_num, type_nucl_num, type_nucl_vector, &
  |      cord_num, rescale_factor_en, &
  |      coord_ee, coord_n, en_distance, een_rescaled_n, een_rescaled_n_gl) &
  |      result(info) bind(C)
  |   use, intrinsic :: iso_c_binding
  |   use qmckl
  |   implicit none
  |   integer(qmckl_context), intent(in), value :: context
  |   integer (c_int64_t) , intent(in)  , value :: walk_num
  |   integer (c_int64_t) , intent(in)  , value :: elec_num
  |   integer (c_int64_t) , intent(in)  , value :: nucl_num
  |   integer (c_int64_t) , intent(in)  , value :: type_nucl_num
  |   integer (c_int64_t) , intent(in)          :: type_nucl_vector(nucl_num)
  |   integer (c_int64_t) , intent(in)  , value :: cord_num
  |   real    (c_double ) , intent(in)          :: rescale_factor_en(nucl_num)
  |   real    (c_double ) , intent(in)          :: coord_ee(elec_num,walk_num,3)
  |   real    (c_double ) , intent(in)          :: coord_n(nucl_num,3)
  |   real    (c_double ) , intent(in)          :: en_distance(nucl_num,elec_num,walk_num)
  |   real    (c_double ) , intent(in)          :: een_rescaled_n(elec_num,nucl_num,0:cord_num,walk_num)
  |   real    (c_double ) , intent(out)         :: een_rescaled_n_gl(elec_num,4,nucl_num,0:cord_num,walk_num)
  |   integer(qmckl_exit_code)                  :: info
  | 
  |   double precision,allocatable        :: elnuc_dist_gl(:,:,:)
  |   double precision                    :: x, ria_inv, kappa_l
  |   integer*8                           :: i, a, k, l, nw, ii
  | 
  |   allocate(elnuc_dist_gl(elec_num, 4, nucl_num))
  | 
  |   info = QMCKL_SUCCESS
  | 
  |   if (context == QMCKL_NULL_CONTEXT) then
  |      info = QMCKL_INVALID_CONTEXT
  |      return
  |   endif
  | 
  |   if (walk_num <= 0) then
  |      info = QMCKL_INVALID_ARG_2
  |      return
  |   endif
  | 
  |   if (elec_num <= 0) then
  |      info = QMCKL_INVALID_ARG_3
  |      return
  |   endif
  | 
  |   if (nucl_num <= 0) then
  |      info = QMCKL_INVALID_ARG_4
  |      return
  |   endif
  | 
  |   if (cord_num < 0) then
  |      info = QMCKL_INVALID_ARG_5
  |      return
  |   endif
  | 
  |   ! Prepare table of exponentiated distances raised to appropriate power
  |   een_rescaled_n_gl             = 0.0d0
  |   do nw = 1, walk_num
  | 
  |      ! prepare the actual een table
  |      do a = 1, nucl_num
  |         do i = 1, elec_num
  |            ria_inv = 1.0d0 / en_distance(a, i, nw)
  |            do ii = 1, 3
  |               elnuc_dist_gl(i, ii, a) = (coord_ee(i, nw, ii) - coord_n(a, ii)) * ria_inv
  |            end do
  |            elnuc_dist_gl(i, 4, a) = 2.0d0 * ria_inv
  |         end do
  |      end do
  | 
  |      do l = 0, cord_num
  |         do a = 1, nucl_num
  |            kappa_l = - dble(l) * rescale_factor_en(type_nucl_vector(a)+1)
  |            do i = 1, elec_num
  |               een_rescaled_n_gl(i, 1, a, l, nw) = kappa_l * elnuc_dist_gl(i, 1, a)
  |               een_rescaled_n_gl(i, 2, a, l, nw) = kappa_l * elnuc_dist_gl(i, 2, a)
  |               een_rescaled_n_gl(i, 3, a, l, nw) = kappa_l * elnuc_dist_gl(i, 3, a)
  |               een_rescaled_n_gl(i, 4, a, l, nw) = kappa_l * elnuc_dist_gl(i, 4, a)
  | 
  |               een_rescaled_n_gl(i, 4, a, l, nw) = een_rescaled_n_gl(i, 4, a, l, nw)           &
  |                    + een_rescaled_n_gl(i, 1, a, l, nw) * een_rescaled_n_gl(i, 1, a, l, nw) &
  |                    + een_rescaled_n_gl(i, 2, a, l, nw) * een_rescaled_n_gl(i, 2, a, l, nw) &
  |                    + een_rescaled_n_gl(i, 3, a, l, nw) * een_rescaled_n_gl(i, 3, a, l, nw)
  | 
  |               een_rescaled_n_gl(i, 1, a, l, nw) = een_rescaled_n_gl(i, 1, a, l, nw) * &
  |                    een_rescaled_n(i, a, l, nw)
  |               een_rescaled_n_gl(i, 2, a, l, nw) = een_rescaled_n_gl(i, 2, a, l, nw) * &
  |                    een_rescaled_n(i, a, l, nw)
  |               een_rescaled_n_gl(i, 3, a, l, nw) = een_rescaled_n_gl(i, 3, a, l, nw) * &
  |                    een_rescaled_n(i, a, l, nw)
  |               een_rescaled_n_gl(i, 4, a, l, nw) = een_rescaled_n_gl(i, 4, a, l, nw) * &
  |                    een_rescaled_n(i, a, l, nw)
  |            end do
  |         end do
  |      end do
  |   end do
  | 
  | end function qmckl_compute_jastrow_champ_factor_een_rescaled_n_gl
  `----


3.3.5 Temporary arrays for electron-electron-nucleus Jastrow $f_{een}$
----------------------------------------------------------------------

  Prepare `c_vector_full' and `lkpm_combined_index' tables required for
  the calculation of the three-body jastrow `factor_een' and its
  derivative `factor_een_gl'.

  The array `tmp_c' corresponds to the tensor $P$ defined at the
  beginning of this section:

  \[ P_{i\alpha}^{km} = \sum_{j=1}^{N_{\text{elec}}} \left[
        g_\text{e}({r}_{ij}) \right]^k \left[ g_\alpha({R}_{j\alpha})
        \right]^{m} \]

  \[ \nabla_i P_{i\alpha}^{km} = \sum_{j=1}^{N_{\text{elec}}} \nabla_i
        \left[ g_\text{e}({r}_{ij}) \right]^k \left[
        g_\alpha({R}_{j\alpha}) \right]^{m} \]


3.3.5.1 Compute dim_c_vector

  Computes the dimension of the vector of parameters.

   $N_{ord}$  Number of parameters 
                                 
           1                     0 
           2                     2 
           3                     6 
           4                    13 
           5                    23 
           6                    37 
           7                    55 
           8                    78 
           9                   106 
          10                   140 

  -----------------------------------------------------------------------------
   Variable        Type             In/Out  Description                        
  -----------------------------------------------------------------------------
   `context'       `qmckl_context'  in      Global state                       
   `cord_num'      `int64_t'        in      Order of polynomials               
   `dim_c_vector'  `int64_t'        out     Number of parameters per atom type 
  -----------------------------------------------------------------------------

  ,----
  | function qmckl_compute_dim_c_vector_doc( &
  |      context, cord_num, dim_c_vector) &
  |      result(info) bind(C)
  |   use, intrinsic :: iso_c_binding
  |   use qmckl
  |   implicit none
  |   integer(qmckl_context), intent(in), value :: context
  |   integer (c_int64_t) , intent(in)  , value :: cord_num
  |   integer (c_int64_t) , intent(out)         :: dim_c_vector
  |   integer(qmckl_exit_code)                  :: info
  | 
  |   double precision                    :: x
  |   integer*8                           :: i, a, k, l, p, lmax
  | 
  |   info = QMCKL_SUCCESS
  | 
  |   if (context == QMCKL_NULL_CONTEXT) then
  |      info = QMCKL_INVALID_CONTEXT
  |      return
  |   endif
  | 
  |   if (cord_num < 0) then
  |      info = QMCKL_INVALID_ARG_2
  |      return
  |   endif
  | 
  |   dim_c_vector = 0
  | 
  |   do p = 2, cord_num
  |     do k = p - 1, 0, -1
  |       if (k .ne. 0) then
  |         lmax = p - k
  |       else
  |         lmax = p - k - 2
  |       endif
  |       do l = lmax, 0, -1
  |         if (iand(p - k - l, 1_8) == 1) cycle
  |         dim_c_vector = dim_c_vector + 1
  |       end do
  |     end do
  |   end do
  | 
  | end function qmckl_compute_dim_c_vector_doc
  `----


3.3.5.2 Get

  ,----
  | qmckl_exit_code
  | qmckl_get_jastrow_champ_tmp_c(qmckl_context context,
  |                               double* const tmp_c,
  |                               const int64_t size_max);
  | 
  | qmckl_exit_code
  | qmckl_get_jastrow_champ_dtmp_c(qmckl_context context,
  |                                double* const dtmp_c,
  |                                const int64_t size_max);
  `----


3.3.5.3 Compute c_vector_full

  -------------------------------------------------------------------------------------------------
   Variable            Type                                   In/Out  Description                  
  -------------------------------------------------------------------------------------------------
   `context'           `qmckl_context'                        in      Global state                 
   `nucl_num'          `int64_t'                              in      Number of atoms              
   `dim_c_vector'      `int64_t'                              in      dimension of cord full table 
   `type_nucl_num'     `int64_t'                              in      dimension of cord full table 
   `type_nucl_vector'  `int64_t[nucl_num]'                    in      dimension of cord full table 
   `c_vector'          `double[dim_c_vector][type_nucl_num]'  in      dimension of cord full table 
   `c_vector_full'     `double[dim_c_vector][nucl_num]'       out     Full list of coefficients    
  -------------------------------------------------------------------------------------------------

  ,----
  | function qmckl_compute_c_vector_full_doc( &
  |      context, nucl_num, dim_c_vector, type_nucl_num,  &
  |      type_nucl_vector, c_vector, c_vector_full) &
  |      result(info) bind(C)
  |   use, intrinsic :: iso_c_binding
  |   use qmckl
  |   implicit none
  |   integer(qmckl_context), intent(in), value :: context
  |   integer (c_int64_t) , intent(in)  , value :: nucl_num
  |   integer (c_int64_t) , intent(in)  , value :: dim_c_vector
  |   integer (c_int64_t) , intent(in)  , value :: type_nucl_num
  |   integer (c_int64_t) , intent(in)          :: type_nucl_vector(nucl_num)
  |   real    (c_double ) , intent(in)          :: c_vector(dim_c_vector, type_nucl_num)
  |   real    (c_double ) , intent(out)         :: c_vector_full(nucl_num,dim_c_vector)
  |   integer(qmckl_exit_code)                  :: info
  | 
  |   double precision                    :: x
  |   integer*8                           :: i, a, k, l, nw
  | 
  |   info = QMCKL_SUCCESS
  | 
  |   if (context == QMCKL_NULL_CONTEXT) info = QMCKL_INVALID_CONTEXT
  |   if (nucl_num <= 0)                 info = QMCKL_INVALID_ARG_2
  |   if (dim_c_vector < 0)              info = QMCKL_INVALID_ARG_3
  |   if (type_nucl_num <= 0)            info = QMCKL_INVALID_ARG_4
  |   if (info /= QMCKL_SUCCESS)         return
  | 
  |   do a = 1, nucl_num
  |     c_vector_full(a,1:dim_c_vector) = c_vector(1:dim_c_vector, type_nucl_vector(a)+1)
  |   end do
  | 
  | end function qmckl_compute_c_vector_full_doc
  `----

  ,----
  | qmckl_exit_code qmckl_compute_c_vector_full_hpc (
  |           const qmckl_context context,
  |           const int64_t nucl_num,
  |           const int64_t dim_c_vector,
  |           const int64_t type_nucl_num,
  |           const int64_t* type_nucl_vector,
  |           const double* c_vector,
  |           double* const c_vector_full ) {
  | 
  |   if (context == QMCKL_NULL_CONTEXT) return QMCKL_INVALID_CONTEXT;
  |   if (nucl_num <= 0)                 return QMCKL_INVALID_ARG_2;
  |   if (dim_c_vector < 0)              return QMCKL_INVALID_ARG_3;
  |   if (type_nucl_num <= 0)            return QMCKL_INVALID_ARG_4;
  |   if (type_nucl_vector == NULL)      return QMCKL_INVALID_ARG_5;
  |   if (c_vector == NULL)              return QMCKL_INVALID_ARG_6;
  |   if (c_vector_full == NULL)         return QMCKL_INVALID_ARG_7;
  | 
  |   for (int i=0; i < dim_c_vector; ++i) {
  |     for (int a=0; a < nucl_num; ++a){
  |       c_vector_full[a + i*nucl_num] = c_vector[i + type_nucl_vector[a]*dim_c_vector];
  |     }
  |   }
  | 
  |   return QMCKL_SUCCESS;
  | }
  `----


  ,----
  | qmckl_exit_code qmckl_compute_c_vector_full_doc (
  |       const qmckl_context context,
  |       const int64_t nucl_num,
  |       const int64_t dim_c_vector,
  |       const int64_t type_nucl_num,
  |       const int64_t* type_nucl_vector,
  |       const double* c_vector,
  |       double* const c_vector_full );
  `----

  ,----
  | qmckl_exit_code qmckl_compute_c_vector_full_hpc (
  |       const qmckl_context context,
  |       const int64_t nucl_num,
  |       const int64_t dim_c_vector,
  |       const int64_t type_nucl_num,
  |       const int64_t* type_nucl_vector,
  |       const double* c_vector,
  |       double* const c_vector_full );
  `----

  ,----
  | qmckl_exit_code qmckl_compute_c_vector_full (
  |           const qmckl_context context,
  |           const int64_t nucl_num,
  |           const int64_t dim_c_vector,
  |           const int64_t type_nucl_num,
  |           const int64_t* type_nucl_vector,
  |           const double* c_vector,
  |           double* const c_vector_full ) {
  | 
  | #ifdef HAVE_HPC
  |       return qmckl_compute_c_vector_full_hpc
  | #else
  |       return qmckl_compute_c_vector_full_doc
  | #endif
  | (context, nucl_num, dim_c_vector, type_nucl_num, type_nucl_vector, c_vector, c_vector_full);
  |     }
  `----


3.3.5.4 Compute lkpm_combined_index

  ------------------------------------------------------------------------------------------
   Variable               Type                        In/Out  Description                   
  ------------------------------------------------------------------------------------------
   `context'              `qmckl_context'             in      Global state                  
   `cord_num'             `int64_t'                   in      Order of polynomials          
   `dim_c_vector'         `int64_t'                   in      dimension of cord full table  
   `lkpm_combined_index'  `int64_t[4][dim_c_vector]'  out     Full list of combined indices 
  ------------------------------------------------------------------------------------------

  ,----
  | function qmckl_compute_lkpm_combined_index_doc( &
  |      context, cord_num, dim_c_vector,  lkpm_combined_index) &
  |      result(info) bind(C)
  |   use, intrinsic :: iso_c_binding
  |   use qmckl
  |   implicit none
  |   integer(qmckl_context), intent(in), value :: context
  |   integer (c_int64_t) , intent(in)  , value :: cord_num
  |   integer (c_int64_t) , intent(in)  , value :: dim_c_vector
  |   integer (c_int64_t) , intent(out)         :: lkpm_combined_index(dim_c_vector,4)
  |   integer(qmckl_exit_code)                  :: info
  | 
  |   double precision                    :: x
  |   integer*8                           :: i, a, k, l, kk, p, lmax, m
  | 
  |   info = QMCKL_SUCCESS
  | 
  |   if (context == QMCKL_NULL_CONTEXT) info = QMCKL_INVALID_CONTEXT
  |   if (cord_num < 0)                  info = QMCKL_INVALID_ARG_2
  |   if (dim_c_vector < 0)              info = QMCKL_INVALID_ARG_3
  |   if (info /= QMCKL_SUCCESS)         return
  | 
  |   kk = 0
  |   do p = 2, cord_num
  |     do k = p - 1, 0, -1
  |       if (k /= 0) then
  |         lmax = p - k
  |       else
  |         lmax = p - k - 2
  |       end if
  |       do l = lmax, 0, -1
  |         if (iand(p - k - l, 1_8) .eq. 1_8) cycle
  |         m = (p - k - l)/2
  |         kk = kk + 1
  |         lkpm_combined_index(kk, 1) = l
  |         lkpm_combined_index(kk, 2) = k
  |         lkpm_combined_index(kk, 3) = p
  |         lkpm_combined_index(kk, 4) = m
  |       end do
  |     end do
  |   end do
  | 
  | end function qmckl_compute_lkpm_combined_index_doc
  `----

  ,----
  | qmckl_exit_code qmckl_compute_lkpm_combined_index_hpc (
  |       const qmckl_context context,
  |       const int64_t cord_num,
  |       const int64_t dim_c_vector,
  |       int64_t* const lkpm_combined_index ) {
  | 
  |   int kk, lmax, m;
  | 
  |   if (context == QMCKL_NULL_CONTEXT) return QMCKL_INVALID_CONTEXT;
  |   if (cord_num < 0) return QMCKL_INVALID_ARG_2;
  |   if (dim_c_vector < 0) return QMCKL_INVALID_ARG_3;
  | 
  |   kk = 0;
  |   for (int p = 2; p <= cord_num; ++p) {
  |     for (int k=(p-1); k >= 0; --k) {
  |       if (k != 0) {
  |         lmax = p - k;
  |       } else {
  |         lmax = p - k - 2;
  |       }
  |       for (int l=lmax; l >= 0; --l) {
  |         if (((p - k - l) & 1) == 1) continue;
  |         m = (p - k - l)/2;
  |         lkpm_combined_index[kk                 ] = l;
  |         lkpm_combined_index[kk +   dim_c_vector] = k;
  |         lkpm_combined_index[kk + 2*dim_c_vector] = p;
  |         lkpm_combined_index[kk + 3*dim_c_vector] = m;
  |         kk = kk + 1;
  |       }
  |     }
  |   }
  | 
  |   return QMCKL_SUCCESS;
  | }
  `----


  ,----
  | qmckl_exit_code qmckl_compute_lkpm_combined_index (
  |       const qmckl_context context,
  |       const int64_t cord_num,
  |       const int64_t dim_c_vector,
  |       int64_t* const lkpm_combined_index ) {
  | 
  |     #ifdef HAVE_HPC
  |       return qmckl_compute_lkpm_combined_index_hpc
  |     #else
  |       return qmckl_compute_lkpm_combined_index_doc
  |     #endif
  |         (context, cord_num, dim_c_vector, lkpm_combined_index);
  | }
  `----


  ,----
  | qmckl_exit_code qmckl_compute_lkpm_combined_index (
  |       Type Variable,
  |       const qmckl_context context,
  |       const int64_t cord_num,
  |       const int64_t dim_c_vector,
  |       int64_t* const lkpm_combined_index ); 
  `----

  ,----
  | qmckl_exit_code qmckl_compute_lkpm_combined_index_doc (
  |       Type Variable,
  |       const qmckl_context context,
  |       const int64_t cord_num,
  |       const int64_t dim_c_vector,
  |       int64_t* const lkpm_combined_index ); 
  `----

  ,----
  | qmckl_exit_code qmckl_compute_lkpm_combined_index_hpc (
  |       Type Variable,
  |       const qmckl_context context,
  |       const int64_t cord_num,
  |       const int64_t dim_c_vector,
  |       int64_t* const lkpm_combined_index ); 
  `----

  ,----
  | qmckl_exit_code qmckl_compute_lkpm_combined_index (
  |       Type Variable,
  |       const qmckl_context context,
  |       const int64_t cord_num,
  |       const int64_t dim_c_vector,
  |       int64_t* const lkpm_combined_index ); 
  `----


3.3.5.5 Compute tmp_c

  -------------------------------------------------------------------------------------------------------------------------------
   Variable          Type                                                              In/Out  Description                       
  -------------------------------------------------------------------------------------------------------------------------------
   `context'         `qmckl_context'                                                   in      Global state                      
   `cord_num'        `int64_t'                                                         in      Order of polynomials              
   `elec_num'        `int64_t'                                                         in      Number of electrons               
   `nucl_num'        `int64_t'                                                         in      Number of nuclei                  
   `walk_num'        `int64_t'                                                         in      Number of walkers                 
   `een_rescaled_e'  `double[walk_num][0:cord_num][elec_num][elec_num]'                in      Electron-electron rescaled factor 
   `een_rescaled_n'  `double[walk_num][0:cord_num][nucl_num][elec_num]'                in      Electron-nucleus rescaled factor  
   `tmp_c'           `double[walk_num][0:cord_num-1][0:cord_num][nucl_num][elec_num]'  out     vector of non-zero coefficients   
  -------------------------------------------------------------------------------------------------------------------------------

  ,----
  | qmckl_exit_code qmckl_compute_tmp_c (const qmckl_context context,
  |                                      const int64_t cord_num,
  |                                      const int64_t elec_num,
  |                                      const int64_t nucl_num,
  |                                      const int64_t walk_num,
  |                                      const double* een_rescaled_e,
  |                                      const double* een_rescaled_n,
  |                                      double* const tmp_c )
  | {
  | #ifdef HAVE_HPC
  |   return qmckl_compute_tmp_c_hpc
  | #else
  |   return qmckl_compute_tmp_c_doc
  | #endif
  |     (context, cord_num, elec_num, nucl_num, walk_num,
  |      een_rescaled_e, een_rescaled_n, tmp_c);
  | }
  `----

  ,----
  | function qmckl_compute_tmp_c_doc( &
  |      context, cord_num, elec_num, nucl_num, &
  |      walk_num, een_rescaled_e, een_rescaled_n, tmp_c) &
  |      result(info) bind(C)
  |   use, intrinsic :: iso_c_binding
  |   use qmckl
  |   implicit none
  |   integer(qmckl_context), intent(in), value  :: context
  |   integer (c_int64_t) , intent(in)  , value :: cord_num
  |   integer (c_int64_t) , intent(in)  , value :: elec_num
  |   integer (c_int64_t) , intent(in)  , value :: nucl_num
  |   integer (c_int64_t) , intent(in)  , value :: walk_num
  |   real    (c_double ) , intent(in)          :: een_rescaled_e(elec_num,elec_num,0:cord_num,walk_num)
  |   real    (c_double ) , intent(in)          :: een_rescaled_n(elec_num,nucl_num,0:cord_num,walk_num)
  |   real    (c_double ) , intent(out)         :: tmp_c(elec_num,nucl_num,0:cord_num,0:cord_num-1,walk_num)
  |   integer(qmckl_exit_code)                  :: info
  | 
  |   double precision                    :: x
  |   integer*8                           :: i, j, a, l, kk, p, lmax, nw
  |   character                           :: TransA, TransB
  |   double precision                    :: alpha, beta
  |   integer*8                           :: M, N, K, LDA, LDB, LDC
  | 
  |   TransA = 'N'
  |   TransB = 'N'
  |   alpha = 1.0d0
  |   beta  = 0.0d0
  | 
  |   info = QMCKL_SUCCESS
  | 
  |   if (context == QMCKL_NULL_CONTEXT) info = QMCKL_INVALID_CONTEXT
  |   if (cord_num <  0)                 info = QMCKL_INVALID_ARG_2
  |   if (elec_num <= 0)                 info = QMCKL_INVALID_ARG_3
  |   if (nucl_num <= 0)                 info = QMCKL_INVALID_ARG_4
  |   if (walk_num <= 0)                 info = QMCKL_INVALID_ARG_5
  |   if (info /= QMCKL_SUCCESS)         return
  | 
  | 
  |   M = elec_num
  |   N = nucl_num*(cord_num + 1)
  |   K = elec_num
  |   LDA = size(een_rescaled_e,1)
  |   LDB = size(een_rescaled_n,1)
  |   LDC = size(tmp_c,1)
  | 
  |   do nw=1, walk_num
  |     do i=0, cord_num-1
  |       info = qmckl_dgemm(context, TransA, TransB, M, N, K, alpha,     &
  |                          een_rescaled_e(1,1,i,nw),LDA*1_8,                     &
  |                          een_rescaled_n(1,1,0,nw),LDB*1_8,                     &
  |                          beta,                                       &
  |                          tmp_c(1,1,0,i,nw),LDC)
  |     end do
  |   end do
  | 
  | end function qmckl_compute_tmp_c_doc
  `----

  ,----
  | qmckl_exit_code qmckl_compute_tmp_c_doc (
  |           const qmckl_context context,
  |           const int64_t cord_num,
  |           const int64_t elec_num,
  |           const int64_t nucl_num,
  |           const int64_t walk_num,
  |           const double* een_rescaled_e,
  |           const double* een_rescaled_n,
  |           double* const tmp_c );
  `----


3.3.5.6 Compute dtmp_c

  -------------------------------------------------------------------------------------------------------------------------------------------------
   Variable             Type                                                                 In/Out  Description                                   
  -------------------------------------------------------------------------------------------------------------------------------------------------
   `context'            `qmckl_context'                                                      in      Global state                                  
   `cord_num'           `int64_t'                                                            in      Order of polynomials                          
   `elec_num'           `int64_t'                                                            in      Number of electrons                           
   `nucl_num'           `int64_t'                                                            in      Number of nuclei                              
   `walk_num'           `int64_t'                                                            in      Number of walkers                             
   `een_rescaled_e_gl'  `double[walk_num][0:cord_num][elec_num][4][elec_num]'                in      Electron-electron rescaled factor derivatives 
   `een_rescaled_n'     `double[walk_num][0:cord_num][nucl_num][elec_num]'                   in      Electron-nucleus rescaled factor              
   `dtmp_c'             `double[walk_num][0:cord_num-1][0:cord_num][nucl_num][4][elec_num]'  out     vector of non-zero coefficients               
  -------------------------------------------------------------------------------------------------------------------------------------------------


  ,----
  | qmckl_exit_code
  | qmckl_compute_dtmp_c (const qmckl_context context,
  |                       const int64_t cord_num,
  |                       const int64_t elec_num,
  |                       const int64_t nucl_num,
  |                       const int64_t walk_num,
  |                       const double* een_rescaled_e_gl,
  |                       const double* een_rescaled_n,
  |                       double* const dtmp_c )
  | {
  | #ifdef HAVE_HPC
  |   return qmckl_compute_dtmp_c_hpc
  | #else
  |   return qmckl_compute_dtmp_c_doc
  | #endif
  |     (context, cord_num, elec_num, nucl_num, walk_num, een_rescaled_e_gl,
  |      een_rescaled_n, dtmp_c );
  | }
  `----

  ,----
  | function qmckl_compute_dtmp_c_doc( &
  |      context, cord_num, elec_num, nucl_num, &
  |      walk_num, een_rescaled_e_gl, een_rescaled_n, dtmp_c) &
  |      result(info) bind(C)
  |   use, intrinsic :: iso_c_binding
  |   use qmckl
  |   implicit none
  |   integer(qmckl_context), intent(in), value :: context
  |   integer (c_int64_t) , intent(in)  , value :: cord_num
  |   integer (c_int64_t) , intent(in)  , value :: elec_num
  |   integer (c_int64_t) , intent(in)  , value :: nucl_num
  |   integer (c_int64_t) , intent(in)  , value :: walk_num
  |   real    (c_double ) , intent(in)          :: een_rescaled_e_gl(elec_num,4,elec_num,0:cord_num,walk_num)
  |   real    (c_double ) , intent(in)          :: een_rescaled_n(elec_num,nucl_num,0:cord_num,walk_num)
  |   real    (c_double ) , intent(out)         :: dtmp_c(elec_num,4,nucl_num,0:cord_num,0:cord_num-1,walk_num)
  |   integer(qmckl_exit_code)                  :: info
  | 
  |   double precision                    :: x
  |   integer*8                           :: i, j, a, l, kk, p, lmax, nw, ii
  |   character                           :: TransA, TransB
  |   double precision                    :: alpha, beta
  |   integer*8                           :: M, N, K, LDA, LDB, LDC
  | 
  |   info = QMCKL_SUCCESS
  | 
  |   if (context == QMCKL_NULL_CONTEXT) info = QMCKL_INVALID_CONTEXT
  |   if (cord_num <  0)                 info = QMCKL_INVALID_ARG_2
  |   if (elec_num <= 0)                 info = QMCKL_INVALID_ARG_3
  |   if (nucl_num <= 0)                 info = QMCKL_INVALID_ARG_4
  |   if (walk_num <= 0)                 info = QMCKL_INVALID_ARG_5
  |   if (info /= QMCKL_SUCCESS)         return
  | 
  |   TransA = 'N'
  |   TransB = 'N'
  |   alpha = 1.0d0
  |   beta  = 0.0d0
  | 
  |   M = 4*elec_num
  |   N = nucl_num*(cord_num + 1)
  |   K = elec_num
  |   LDA = 4*size(een_rescaled_e_gl,1)
  |   LDB = size(een_rescaled_n,1)
  |   LDC = 4*size(dtmp_c,1)
  | 
  |   do nw=1, walk_num
  |      do i=0, cord_num-1
  |         info = qmckl_dgemm(context,TransA, TransB, M, N, K, alpha,  &
  |              een_rescaled_e_gl(1,1,1,i,nw),LDA*1_8,            &
  |              een_rescaled_n(1,1,0,nw),LDB*1_8,                      &
  |              beta,                                                  &
  |              dtmp_c(1,1,1,0,i,nw),LDC)
  |      end do
  |   end do
  | 
  | end function qmckl_compute_dtmp_c_doc
  `----


3.3.6 Electron-electron-nucleus Jastrow $f_{een}$
-------------------------------------------------

  Calculate the electron-electron-nuclear three-body jastrow component
  `factor_een' using the above prepared tables.

  TODO: write equations.


3.3.6.1 Get

  ,----
  | qmckl_exit_code
  | qmckl_get_jastrow_champ_factor_een(qmckl_context context,
  |                              double* const factor_een,
  |                              const int64_t size_max);
  `----


* 3.3.6.1.1 Fortran interface

  ,----
  | interface
  |    integer(qmckl_exit_code) function qmckl_get_jastrow_champ_factor_een (context, &
  |         factor_een, size_max) bind(C)
  |      use, intrinsic :: iso_c_binding
  |      import
  |      implicit none
  |      integer (qmckl_context) , intent(in), value :: context
  |      integer(c_int64_t), intent(in), value       :: size_max
  |      real(c_double),   intent(out)               :: factor_een(size_max)
  |    end function qmckl_get_jastrow_champ_factor_een
  | end interface
  `----


3.3.6.2 Compute naive

  -------------------------------------------------------------------------------------------------------------------------
   Variable               Type                                                In/Out  Description                          
  -------------------------------------------------------------------------------------------------------------------------
   `context'              `qmckl_context'                                     in      Global state                         
   `walk_num'             `int64_t'                                           in      Number of walkers                    
   `elec_num'             `int64_t'                                           in      Number of electrons                  
   `nucl_num'             `int64_t'                                           in      Number of nuclei                     
   `cord_num'             `int64_t'                                           in      order of polynomials                 
   `dim_c_vector'         `int64_t'                                           in      dimension of full coefficient vector 
   `c_vector_full'        `double[dim_c_vector][nucl_num]'                    in      full coefficient vector              
   `lkpm_combined_index'  `int64_t[4][dim_c_vector]'                          in      combined indices                     
   `een_rescaled_e'       `double[walk_num][0:cord_num][elec_num][elec_num]'  in      Electron-nucleus rescaled            
   `een_rescaled_n'       `double[walk_num][0:cord_num][nucl_num][elec_num]'  in      Electron-nucleus rescaled factor     
   `factor_een'           `double[walk_num]'                                  out     Electron-nucleus jastrow             
  -------------------------------------------------------------------------------------------------------------------------

  ,----
  | function qmckl_compute_jastrow_champ_factor_een_naive( &
  |      context, walk_num, elec_num, nucl_num, cord_num,&
  |      dim_c_vector, c_vector_full, lkpm_combined_index, &
  |      een_rescaled_e, een_rescaled_n, factor_een) &
  |      result(info) bind(C)
  |   use, intrinsic :: iso_c_binding
  |   use qmckl
  |   implicit none
  |   integer(qmckl_context), intent(in), value :: context
  |   integer (c_int64_t) , intent(in)  , value :: walk_num
  |   integer (c_int64_t) , intent(in)  , value :: elec_num
  |   integer (c_int64_t) , intent(in)  , value :: nucl_num
  |   integer (c_int64_t) , intent(in)  , value :: cord_num
  |   integer (c_int64_t) , intent(in)  , value :: dim_c_vector
  |   real    (c_double ) , intent(in)          :: c_vector_full(nucl_num,dim_c_vector)
  |   integer (c_int64_t) , intent(in)          :: lkpm_combined_index(dim_c_vector,4)
  |   real    (c_double ) , intent(in)          :: een_rescaled_e(elec_num,elec_num,0:cord_num,walk_num)
  |   real    (c_double ) , intent(in)          :: een_rescaled_n(elec_num,nucl_num,0:cord_num,walk_num)
  |   real    (c_double ) , intent(out)         :: factor_een(walk_num)
  |   integer(qmckl_exit_code)                  :: info
  | 
  |   integer*8 :: i, a, j, l, k, m, n, p, nw
  |   double precision :: cn
  | 
  |   info = QMCKL_SUCCESS
  | 
  |   if (context == QMCKL_NULL_CONTEXT) info = QMCKL_INVALID_CONTEXT
  |   if (walk_num <= 0)                 info = QMCKL_INVALID_ARG_2
  |   if (elec_num <= 0)                 info = QMCKL_INVALID_ARG_3
  |   if (nucl_num <= 0)                 info = QMCKL_INVALID_ARG_4
  |   if (cord_num <  0)                 info = QMCKL_INVALID_ARG_5
  |   if (info /= QMCKL_SUCCESS)         return
  | 
  |   do nw =1, walk_num
  |      factor_een(nw) = 0.d0
  |      do n = 1, dim_c_vector
  |         l = lkpm_combined_index(n, 1)
  |         k = lkpm_combined_index(n, 2)
  |         p = lkpm_combined_index(n, 3)
  |         m = lkpm_combined_index(n, 4)
  | 
  |         do a = 1, nucl_num
  |            cn = c_vector_full(a, n)
  |            if (cn == 0.d0) cycle
  |            do j = 1, elec_num
  |               do i = 1, j-1
  |                  factor_een(nw) = factor_een(nw) + cn*( &
  |                       een_rescaled_e(i,j,k,nw) *       &
  |                       (een_rescaled_n(i,a,l,nw) + een_rescaled_n(j,a,l,nw)) * &
  |                       (een_rescaled_n(i,a,m,nw) * een_rescaled_n(j,a,m,nw)) )
  |               end do
  |            end do
  |         end do
  |      end do
  |   end do
  | 
  | end function qmckl_compute_jastrow_champ_factor_een_naive
  | 
  `----


3.3.6.3 Compute

  ---------------------------------------------------------------------------------------------------------------------------------------
   Variable               Type                                                              In/Out  Description                          
  ---------------------------------------------------------------------------------------------------------------------------------------
   `context'              `qmckl_context'                                                   in      Global state                         
   `walk_num'             `int64_t'                                                         in      Number of walkers                    
   `elec_num'             `int64_t'                                                         in      Number of electrons                  
   `nucl_num'             `int64_t'                                                         in      Number of nuclei                     
   `cord_num'             `int64_t'                                                         in      order of polynomials                 
   `dim_c_vector'         `int64_t'                                                         in      dimension of full coefficient vector 
   `c_vector_full'        `double[dim_c_vector][nucl_num]'                                  in      full coefficient vector              
   `lkpm_combined_index'  `int64_t[4][dim_c_vector]'                                        in      combined indices                     
   `tmp_c'                `double[walk_num][0:cord_num-1][0:cord_num][nucl_num][elec_num]'  in      vector of non-zero coefficients      
   `een_rescaled_n'       `double[walk_num][0:cord_num][nucl_num][elec_num]'                in      Electron-nucleus rescaled distances  
   `factor_een'           `double[walk_num]'                                                out     Electron-nucleus jastrow             
  ---------------------------------------------------------------------------------------------------------------------------------------

  ,----
  | function qmckl_compute_jastrow_champ_factor_een_doc( &
  |      context, walk_num, elec_num, nucl_num, cord_num,   &
  |      dim_c_vector, c_vector_full, lkpm_combined_index, &
  |      tmp_c, een_rescaled_n, factor_een) &
  |      result(info) bind(C)
  |   use, intrinsic :: iso_c_binding
  |   use qmckl
  |   implicit none
  |   integer(qmckl_context), intent(in), value :: context
  |   integer (c_int64_t) , intent(in)  , value :: walk_num
  |   integer (c_int64_t) , intent(in)  , value :: elec_num
  |   integer (c_int64_t) , intent(in)  , value :: nucl_num
  |   integer (c_int64_t) , intent(in)  , value :: cord_num
  |   integer (c_int64_t) , intent(in)  , value :: dim_c_vector
  |   real    (c_double ) , intent(in)          :: c_vector_full(nucl_num,dim_c_vector)
  |   integer (c_int64_t) , intent(in)          :: lkpm_combined_index(dim_c_vector,4)
  |   real    (c_double ) , intent(in)          :: tmp_c(elec_num,nucl_num,0:cord_num,0:cord_num-1,walk_num)
  |   real    (c_double ) , intent(in)          :: een_rescaled_n(elec_num,nucl_num,0:cord_num,walk_num)
  |   real    (c_double ) , intent(out)         :: factor_een(walk_num)
  |   integer(qmckl_exit_code)                  :: info
  | 
  |   integer*8 :: i, a, j, l, k, p, m, n, nw
  |   double precision :: accu, accu2, cn
  | 
  |   info = QMCKL_SUCCESS
  | 
  |   if (context == QMCKL_NULL_CONTEXT) info = QMCKL_INVALID_CONTEXT
  |   if (walk_num <= 0)                 info = QMCKL_INVALID_ARG_2
  |   if (elec_num <= 0)                 info = QMCKL_INVALID_ARG_3
  |   if (nucl_num <= 0)                 info = QMCKL_INVALID_ARG_4
  |   if (cord_num <  0)                 info = QMCKL_INVALID_ARG_5
  |   if (info /= QMCKL_SUCCESS)         return
  | 
  |   factor_een = 0.0d0
  | 
  |   if (cord_num == 0) return
  | 
  |   do nw =1, walk_num
  |      do n = 1, dim_c_vector
  |         l = lkpm_combined_index(n, 1)
  |         k = lkpm_combined_index(n, 2)
  |         m = lkpm_combined_index(n, 4)
  | 
  |         do a = 1, nucl_num
  |            cn = c_vector_full(a, n)
  |            if(cn == 0.d0) cycle
  | 
  |            accu = 0.0d0
  |            do j = 1, elec_num
  |               accu = accu + een_rescaled_n(j,a,m,nw) * tmp_c(j,a,m+l,k,nw)
  |            end do
  |            factor_een(nw) = factor_een(nw) + accu * cn
  |         end do
  |      end do
  |   end do
  | 
  | end function qmckl_compute_jastrow_champ_factor_een_doc
  `----


3.3.7 Electron-electron-nucleus Jastrow $f_{een}$ derivative
------------------------------------------------------------

  Calculate the electron-electron-nuclear three-body jastrow component
  `factor_een_gl' using the above prepared tables.

  TODO: write equations.


3.3.7.1 Get

  ,----
  | qmckl_exit_code
  | qmckl_get_jastrow_champ_factor_een_gl(qmckl_context context,
  |                                      double* const factor_een_gl,
  |                                      const int64_t size_max);
  `----

  ,----
  | qmckl_exit_code
  | qmckl_get_jastrow_champ_factor_een_grad(qmckl_context context,
  |                                         double* const factor_een_grad,
  |                                         const int64_t size_max);
  `----


* 3.3.7.1.1 Fortran interface

  ,----
  | interface
  |    integer(qmckl_exit_code) function qmckl_get_jastrow_champ_factor_een_gl (context, &
  |         factor_een_gl, size_max) bind(C)
  |      use, intrinsic :: iso_c_binding
  |      import
  |      implicit none
  |      integer (qmckl_context) , intent(in), value :: context
  |      integer(c_int64_t), intent(in), value       :: size_max
  |      real(c_double),   intent(out)               :: factor_een_gl(size_max)
  |    end function qmckl_get_jastrow_champ_factor_een_gl
  | end interface
  | 
  | interface
  |    integer(qmckl_exit_code) function qmckl_get_jastrow_champ_factor_een_grad (context, &
  |         factor_een_grad, size_max) bind(C)
  |      use, intrinsic :: iso_c_binding
  |      import
  |      implicit none
  |      integer (qmckl_context) , intent(in), value :: context
  |      integer(c_int64_t), intent(in), value       :: size_max
  |      real(c_double),   intent(out)               :: factor_een_grad(size_max)
  |    end function qmckl_get_jastrow_champ_factor_een_grad
  | end interface
  `----


3.3.7.2 Compute Naive

  ----------------------------------------------------------------------------------------------------------------------------
   Variable               Type                                                   In/Out  Description                          
  ----------------------------------------------------------------------------------------------------------------------------
   `context'              `qmckl_context'                                        in      Global state                         
   `walk_num'             `int64_t'                                              in      Number of walkers                    
   `elec_num'             `int64_t'                                              in      Number of electrons                  
   `nucl_num'             `int64_t'                                              in      Number of nuclei                     
   `cord_num'             `int64_t'                                              in      order of polynomials                 
   `dim_c_vector'         `int64_t'                                              in      dimension of full coefficient vector 
   `c_vector_full'        `double[dim_c_vector][nucl_num]'                       in      full coefficient vector              
   `lkpm_combined_index'  `int64_t[4][dim_c_vector]'                             in      combined indices                     
   `een_rescaled_e'       `double[walk_num][0:cord_num][elec_num][elec_num]'     in      Electron-nucleus rescaled            
   `een_rescaled_n'       `double[walk_num][0:cord_num][nucl_num][elec_num]'     in      Electron-nucleus rescaled factor     
   `een_rescaled_e_gl'    `double[walk_num][0:cord_num][elec_num][4][elec_num]'  in      Electron-nucleus rescaled            
   `een_rescaled_n_gl'    `double[walk_num][0:cord_num][nucl_num][4][elec_num]'  in      Electron-nucleus rescaled factor     
   `factor_een_gl'        `double[walk_num][4][elec_num]'                        out     Electron-nucleus jastrow             
  ----------------------------------------------------------------------------------------------------------------------------

  ,----
  | function qmckl_compute_jastrow_champ_factor_een_gl_naive( &
  |      context, walk_num, elec_num, nucl_num, cord_num, dim_c_vector, &
  |      c_vector_full, lkpm_combined_index, een_rescaled_e, een_rescaled_n, &
  |      een_rescaled_e_gl, een_rescaled_n_gl, factor_een_gl)&
  |      result(info) bind(C)
  |   use, intrinsic :: iso_c_binding
  |   use qmckl
  |   implicit none
  |   integer(qmckl_context), intent(in), value :: context
  |   integer (c_int64_t) , intent(in)  , value :: walk_num
  |   integer (c_int64_t) , intent(in)  , value :: elec_num
  |   integer (c_int64_t) , intent(in)  , value :: nucl_num
  |   integer (c_int64_t) , intent(in)  , value :: cord_num
  |   integer (c_int64_t) , intent(in)  , value :: dim_c_vector
  |   real    (c_double ) , intent(in)          :: c_vector_full(nucl_num,dim_c_vector)
  |   integer (c_int64_t) , intent(in)          :: lkpm_combined_index(dim_c_vector,4)
  |   real    (c_double ) , intent(in)          :: een_rescaled_e(elec_num,elec_num,0:cord_num,walk_num)
  |   real    (c_double ) , intent(in)          :: een_rescaled_n(elec_num,nucl_num,0:cord_num,walk_num)
  |   real    (c_double ) , intent(in)          :: een_rescaled_e_gl(elec_num,4,elec_num,0:cord_num,walk_num)
  |   real    (c_double ) , intent(in)          :: een_rescaled_n_gl(elec_num,4,nucl_num,0:cord_num,walk_num)
  |   real    (c_double ) , intent(out)         :: factor_een_gl(elec_num,4,walk_num)
  |   integer(qmckl_exit_code)                  :: info
  | 
  |   integer*8 :: i, a, j, l, k, m, n, nw
  |   double precision :: accu, accu2, cn
  |   double precision :: daccu(1:4), daccu2(1:4)
  | 
  |   info = QMCKL_SUCCESS
  | 
  |   if (context == QMCKL_NULL_CONTEXT) info = QMCKL_INVALID_CONTEXT
  |   if (walk_num <= 0)                 info = QMCKL_INVALID_ARG_2
  |   if (elec_num <= 0)                 info = QMCKL_INVALID_ARG_3
  |   if (nucl_num <= 0)                 info = QMCKL_INVALID_ARG_4
  |   if (cord_num <  0)                 info = QMCKL_INVALID_ARG_5
  |   if (info /= QMCKL_SUCCESS)         return
  | 
  |   factor_een_gl = 0.0d0
  | 
  |   do nw =1, walk_num
  |      do n = 1, dim_c_vector
  |         l = lkpm_combined_index(n, 1)
  |         k = lkpm_combined_index(n, 2)
  |         m = lkpm_combined_index(n, 4)
  | 
  |         do a = 1, nucl_num
  |            cn = c_vector_full(a, n)
  |            do j = 1, elec_num
  |               accu = 0.0d0
  |               accu2 = 0.0d0
  |               daccu = 0.0d0
  |               daccu2 = 0.0d0
  |               do i = 1, elec_num
  |                  accu = accu + een_rescaled_e(i, j, k, nw) * een_rescaled_n(i, a, m, nw)
  |                  accu2 = accu2 + een_rescaled_e(i, j, k, nw) * een_rescaled_n(i, a, m + l, nw)
  |                  daccu(1:4) = daccu(1:4) + een_rescaled_e_gl(j, 1:4, i, k, nw) *   &
  |                       een_rescaled_n(i, a, m, nw)
  |                  daccu2(1:4) = daccu2(1:4) + een_rescaled_e_gl(j, 1:4, i, k, nw) * &
  |                       een_rescaled_n(i, a, m + l, nw)
  |               end do
  |               factor_een_gl(j, 1:4, nw) = factor_een_gl(j, 1:4, nw) +   &
  |                    (accu * een_rescaled_n_gl(j, 1:4, a, m + l, nw)      &
  |                    + daccu(1:4) * een_rescaled_n(j, a, m + l, nw)       &
  |                    + daccu2(1:4) * een_rescaled_n(j, a, m, nw)          &
  |                    + accu2 * een_rescaled_n_gl(j, 1:4, a, m, nw)) * cn
  | 
  |               factor_een_gl(j, 4, nw) = factor_een_gl(j, 4, nw) + 2.0d0 * ( &
  |                    daccu (1) * een_rescaled_n_gl(j, 1, a, m + l, nw) +      &
  |                    daccu (2) * een_rescaled_n_gl(j, 2, a, m + l, nw) +      &
  |                    daccu (3) * een_rescaled_n_gl(j, 3, a, m + l, nw) +      &
  |                    daccu2(1) * een_rescaled_n_gl(j, 1, a, m, nw    ) +      &
  |                    daccu2(2) * een_rescaled_n_gl(j, 2, a, m, nw    ) +      &
  |                    daccu2(3) * een_rescaled_n_gl(j, 3, a, m, nw    ) ) * cn
  | 
  |            end do
  |         end do
  |      end do
  |   end do
  | 
  | end function qmckl_compute_jastrow_champ_factor_een_gl_naive
  `----


3.3.7.3 Compute GL

  ----------------------------------------------------------------------------------------------------------------------------------------------------
   Variable               Type                                                                 In/Out  Description                                    
  ----------------------------------------------------------------------------------------------------------------------------------------------------
   `context'              `qmckl_context'                                                      in      Global state                                   
   `walk_num'             `int64_t'                                                            in      Number of walkers                              
   `elec_num'             `int64_t'                                                            in      Number of electrons                            
   `nucl_num'             `int64_t'                                                            in      Number of nuclei                               
   `cord_num'             `int64_t'                                                            in      order of polynomials                           
   `dim_c_vector'         `int64_t'                                                            in      dimension of full coefficient vector           
   `c_vector_full'        `double[dim_c_vector][nucl_num]'                                     in      full coefficient vector                        
   `lkpm_combined_index'  `int64_t[4][dim_c_vector]'                                           in      combined indices                               
   `tmp_c'                `double[walk_num][0:cord_num-1][0:cord_num][nucl_num][elec_num]'     in      Temporary intermediate tensor                  
   `dtmp_c'               `double[walk_num][0:cord_num-1][0:cord_num][nucl_num][4][elec_num]'  in      vector of non-zero coefficients                
   `een_rescaled_n'       `double[walk_num][0:cord_num][nucl_num][elec_num]'                   in      Electron-nucleus rescaled factor               
   `een_rescaled_n_gl'    `double[walk_num][0:cord_num][nucl_num][4][elec_num]'                in      Derivative of Electron-nucleus rescaled factor 
   `factor_een_gl'        `double[walk_num][4][elec_num]'                                      out     Derivative of Electron-nucleus jastrow         
  ----------------------------------------------------------------------------------------------------------------------------------------------------


  ,----
  | function qmckl_compute_jastrow_champ_factor_een_gl_doc( &
  |      context, walk_num, elec_num, nucl_num, &
  |      cord_num, dim_c_vector, c_vector_full, lkpm_combined_index, &
  |      tmp_c, dtmp_c, een_rescaled_n, een_rescaled_n_gl, factor_een_gl)&
  |      result(info) bind(C)
  |   use, intrinsic :: iso_c_binding
  |   use qmckl
  |   implicit none
  |   integer(qmckl_context), intent(in), value :: context
  |   integer (c_int64_t) , intent(in)  , value :: walk_num
  |   integer (c_int64_t) , intent(in)  , value :: elec_num
  |   integer (c_int64_t) , intent(in)  , value :: nucl_num
  |   integer (c_int64_t) , intent(in)  , value :: cord_num
  |   integer (c_int64_t) , intent(in)  , value :: dim_c_vector
  |   real    (c_double ) , intent(in)          :: c_vector_full(nucl_num,dim_c_vector)
  |   integer (c_int64_t) , intent(in)          :: lkpm_combined_index(dim_c_vector,4)
  |   real    (c_double ) , intent(in)          :: tmp_c(elec_num,nucl_num,0:cord_num,0:cord_num-1,walk_num)
  |   real    (c_double ) , intent(in)          :: dtmp_c(elec_num,4,nucl_num,0:cord_num,0:cord_num-1,walk_num)
  |   real    (c_double ) , intent(in)          :: een_rescaled_n(elec_num,nucl_num,0:cord_num,walk_num)
  |   real    (c_double ) , intent(in)          :: een_rescaled_n_gl(elec_num,4,nucl_num,0:cord_num,walk_num)
  |   real    (c_double ) , intent(out)         :: factor_een_gl(elec_num,4,walk_num)
  |   integer(qmckl_exit_code)                  :: info
  | 
  |   integer*8 :: i, a, j, l, k, m, n, nw, ii
  |   double precision :: accu, accu2, cn
  | 
  |   info = QMCKL_SUCCESS
  | 
  |   if (context == QMCKL_NULL_CONTEXT) info = QMCKL_INVALID_CONTEXT
  |   if (walk_num <= 0)                 info = QMCKL_INVALID_ARG_2
  |   if (elec_num <= 0)                 info = QMCKL_INVALID_ARG_3
  |   if (nucl_num <= 0)                 info = QMCKL_INVALID_ARG_4
  |   if (cord_num <  0)                 info = QMCKL_INVALID_ARG_5
  |   if (info /= QMCKL_SUCCESS)         return
  | 
  |   if (cord_num == 0) then
  |      factor_een_gl = 0.0d0
  |      return
  |   end if
  | 
  |   do nw =1, walk_num
  |      factor_een_gl(:,:,nw) = 0.0d0
  |      do n = 1, dim_c_vector
  |         l = lkpm_combined_index(n, 1)
  |         k = lkpm_combined_index(n, 2)
  |         m = lkpm_combined_index(n, 4)
  | 
  |         do a = 1, nucl_num
  |            cn = c_vector_full(a, n)
  |            if(cn == 0.d0) cycle
  | 
  |            do ii = 1, 4
  |               do j = 1, elec_num
  |                  factor_een_gl(j,ii,nw) = factor_een_gl(j,ii,nw) + ( &
  |                       tmp_c (j,   a,m  ,k,nw) * een_rescaled_n_gl(j,ii,a,m+l,nw) + &
  |                       tmp_c (j,   a,m+l,k,nw) * een_rescaled_n_gl(j,ii,a,m  ,nw) + &
  |                       dtmp_c(j,ii,a,m  ,k,nw) * een_rescaled_n   (j,   a,m+l,nw) + &
  |                       dtmp_c(j,ii,a,m+l,k,nw) * een_rescaled_n   (j,   a,m  ,nw)   &
  |                       ) * cn
  |               end do
  |            end do
  | 
  |            cn = cn + cn
  |            do j = 1, elec_num
  |               factor_een_gl(j,4,nw) = factor_een_gl(j,4,nw) +  ( &
  |                    dtmp_c(j,1,a,m  ,k,nw) * een_rescaled_n_gl(j,1,a,m+l,nw)  + &
  |                    dtmp_c(j,2,a,m  ,k,nw) * een_rescaled_n_gl(j,2,a,m+l,nw)  + &
  |                    dtmp_c(j,3,a,m  ,k,nw) * een_rescaled_n_gl(j,3,a,m+l,nw)  + &
  |                    dtmp_c(j,1,a,m+l,k,nw) * een_rescaled_n_gl(j,1,a,m  ,nw)  + &
  |                    dtmp_c(j,2,a,m+l,k,nw) * een_rescaled_n_gl(j,2,a,m  ,nw)  + &
  |                    dtmp_c(j,3,a,m+l,k,nw) * een_rescaled_n_gl(j,3,a,m  ,nw)    &
  |                    ) * cn
  |            end do
  |         end do
  |      end do
  |   end do
  | 
  | end function qmckl_compute_jastrow_champ_factor_een_gl_doc
  `----

  ,----
  | qmckl_exit_code qmckl_compute_jastrow_champ_factor_een_gl_doc (
  |       Type Variable,
  |       const qmckl_context context,
  |       const int64_t walk_num,
  |       const int64_t elec_num,
  |       const int64_t nucl_num,
  |       const int64_t cord_num,
  |       const int64_t dim_c_vector,
  |       const double* c_vector_full,
  |       const int64_t* lkpm_combined_index,
  |       const double* tmp_c,
  |       const double* dtmp_c,
  |       const double* een_rescaled_n,
  |       const double* een_rescaled_n_gl,
  |       double* const factor_een_gl ); 
  `----

  ,----
  | qmckl_exit_code qmckl_compute_jastrow_champ_factor_een_gl (
  |       Type Variable,
  |       const qmckl_context context,
  |       const int64_t walk_num,
  |       const int64_t elec_num,
  |       const int64_t nucl_num,
  |       const int64_t cord_num,
  |       const int64_t dim_c_vector,
  |       const double* c_vector_full,
  |       const int64_t* lkpm_combined_index,
  |       const double* tmp_c,
  |       const double* dtmp_c,
  |       const double* een_rescaled_n,
  |       const double* een_rescaled_n_gl,
  |       double* const factor_een_gl ); 
  `----

  ,----
  | qmckl_exit_code
  | qmckl_compute_jastrow_champ_factor_een_gl(const qmckl_context context,
  |                                                const int64_t walk_num,
  |                                                const int64_t elec_num,
  |                                                const int64_t nucl_num,
  |                                                const int64_t cord_num,
  |                                                const int64_t dim_c_vector,
  |                                                const double *c_vector_full,
  |                                                const int64_t *lkpm_combined_index,
  |                                                const double *tmp_c,
  |                                                const double *dtmp_c,
  |                                                const double *een_rescaled_n,
  |                                                const double *een_rescaled_n_gl,
  |                                                double* const factor_een_gl)
  | {
  | #ifdef HAVE_HPC
  |   return qmckl_compute_jastrow_champ_factor_een_gl_hpc
  | #else
  |   return qmckl_compute_jastrow_champ_factor_een_gl_doc
  | #endif
  |     (context, walk_num, elec_num, nucl_num,
  |      cord_num, dim_c_vector, c_vector_full,
  |      lkpm_combined_index, tmp_c, dtmp_c,
  |      een_rescaled_n, een_rescaled_n_gl,
  |      factor_een_gl);
  | }
  `----


3.3.7.4 Compute Gradient only

  ----------------------------------------------------------------------------------------------------------------------------------------------------
   Variable               Type                                                                 In/Out  Description                                    
  ----------------------------------------------------------------------------------------------------------------------------------------------------
   `context'              `qmckl_context'                                                      in      Global state                                   
   `walk_num'             `int64_t'                                                            in      Number of walkers                              
   `elec_num'             `int64_t'                                                            in      Number of electrons                            
   `nucl_num'             `int64_t'                                                            in      Number of nuclei                               
   `cord_num'             `int64_t'                                                            in      order of polynomials                           
   `dim_c_vector'         `int64_t'                                                            in      dimension of full coefficient vector           
   `c_vector_full'        `double[dim_c_vector][nucl_num]'                                     in      full coefficient vector                        
   `lkpm_combined_index'  `int64_t[4][dim_c_vector]'                                           in      combined indices                               
   `tmp_c'                `double[walk_num][0:cord_num-1][0:cord_num][nucl_num][elec_num]'     in      Temporary intermediate tensor                  
   `dtmp_c'               `double[walk_num][0:cord_num-1][0:cord_num][nucl_num][4][elec_num]'  in      vector of non-zero coefficients                
   `een_rescaled_n'       `double[walk_num][0:cord_num][nucl_num][elec_num]'                   in      Electron-nucleus rescaled factor               
   `een_rescaled_n_gl'    `double[walk_num][0:cord_num][nucl_num][4][elec_num]'                in      Derivative of Electron-nucleus rescaled factor 
   `factor_een_grad'      `double[walk_num][3][elec_num]'                                      out     Derivative of Electron-nucleus jastrow         
  ----------------------------------------------------------------------------------------------------------------------------------------------------


  ,----
  | function qmckl_compute_jastrow_champ_factor_een_grad_doc( &
  |      context, walk_num, elec_num, nucl_num, &
  |      cord_num, dim_c_vector, c_vector_full, lkpm_combined_index, &
  |      tmp_c, dtmp_c, een_rescaled_n, een_rescaled_n_gl, factor_een_grad) &
  |      bind(C) result(info)
  | 
  |   use, intrinsic :: iso_c_binding
  |   use qmckl
  |   implicit none
  |   integer(qmckl_context), intent(in), value :: context
  |   integer (c_int64_t) , intent(in)  , value :: walk_num
  |   integer (c_int64_t) , intent(in)  , value :: elec_num
  |   integer (c_int64_t) , intent(in)  , value :: nucl_num
  |   integer (c_int64_t) , intent(in)  , value :: cord_num
  |   integer (c_int64_t) , intent(in)  , value :: dim_c_vector
  |   real    (c_double ) , intent(in)          :: c_vector_full(nucl_num,dim_c_vector)
  |   integer (c_int64_t) , intent(in)          :: lkpm_combined_index(dim_c_vector,4)
  |   real    (c_double ) , intent(in)          :: tmp_c(elec_num,nucl_num,0:cord_num,0:cord_num-1,walk_num)
  |   real    (c_double ) , intent(in)          :: dtmp_c(elec_num,4,nucl_num,0:cord_num,0:cord_num-1,walk_num)
  |   real    (c_double ) , intent(in)          :: een_rescaled_n(elec_num,nucl_num,0:cord_num,walk_num)
  |   real    (c_double ) , intent(in)          :: een_rescaled_n_gl(elec_num,4,nucl_num,0:cord_num,walk_num)
  |   real    (c_double ) , intent(out)         :: factor_een_grad(elec_num,3,walk_num)
  |   integer(qmckl_exit_code)                  :: info
  | 
  |   integer*8 :: i, a, j, l, k, m, n, nw, ii
  |   double precision :: accu, accu2, cn
  | 
  |   info = QMCKL_SUCCESS
  | 
  |   if (context == QMCKL_NULL_CONTEXT) info = QMCKL_INVALID_CONTEXT
  |   if (walk_num <= 0)                 info = QMCKL_INVALID_ARG_2
  |   if (elec_num <= 0)                 info = QMCKL_INVALID_ARG_3
  |   if (nucl_num <= 0)                 info = QMCKL_INVALID_ARG_4
  |   if (cord_num <  0)                 info = QMCKL_INVALID_ARG_5
  |   if (info /= QMCKL_SUCCESS)         return
  | 
  | 
  |   if (cord_num == 0) then
  |      factor_een_grad = 0.0d0
  |      return
  |   end if
  | 
  |   do nw =1, walk_num
  |      factor_een_grad(:,:,nw) = 0.0d0
  |      do n = 1, dim_c_vector
  |         l = lkpm_combined_index(n, 1)
  |         k = lkpm_combined_index(n, 2)
  |         m = lkpm_combined_index(n, 4)
  | 
  |         do a = 1, nucl_num
  |            cn = c_vector_full(a, n)
  |            if(cn == 0.d0) cycle
  | 
  |            do ii = 1, 3
  |               do j = 1, elec_num
  |                  factor_een_grad(j,ii,nw) = factor_een_grad(j,ii,nw) + (           &
  |                       dtmp_c(j,ii,a,m  ,k,nw) * een_rescaled_n   (j,   a,m+l,nw) + &
  |                       dtmp_c(j,ii,a,m+l,k,nw) * een_rescaled_n   (j,   a,m  ,nw) + &
  |                       tmp_c(j,a,m  ,k,nw)     * een_rescaled_n_gl(j,ii,a,m+l,nw) + &
  |                       tmp_c(j,a,m+l,k,nw)     * een_rescaled_n_gl(j,ii,a,m  ,nw)   &
  |                       ) * cn
  |               end do
  |            end do
  | 
  |         end do
  |      end do
  |   end do
  | 
  | end function qmckl_compute_jastrow_champ_factor_een_grad_doc
  `----

  ,----
  | qmckl_exit_code qmckl_compute_jastrow_champ_factor_een_grad_doc (
  |       Type Variable,
  |       const qmckl_context context,
  |       const int64_t walk_num,
  |       const int64_t elec_num,
  |       const int64_t nucl_num,
  |       const int64_t cord_num,
  |       const int64_t dim_c_vector,
  |       const double* c_vector_full,
  |       const int64_t* lkpm_combined_index,
  |       const double* tmp_c,
  |       const double* dtmp_c,
  |       const double* een_rescaled_n,
  |       const double* een_rescaled_n_gl,
  |       double* const factor_een_grad ); 
  `----

  ,----
  | qmckl_exit_code qmckl_compute_jastrow_champ_factor_een_grad (
  |       Type Variable,
  |       const qmckl_context context,
  |       const int64_t walk_num,
  |       const int64_t elec_num,
  |       const int64_t nucl_num,
  |       const int64_t cord_num,
  |       const int64_t dim_c_vector,
  |       const double* c_vector_full,
  |       const int64_t* lkpm_combined_index,
  |       const double* tmp_c,
  |       const double* dtmp_c,
  |       const double* een_rescaled_n,
  |       const double* een_rescaled_n_gl,
  |       double* const factor_een_grad ); 
  `----

  ,----
  | qmckl_exit_code
  | qmckl_compute_jastrow_champ_factor_een_grad(const qmckl_context context,
  |                                                const int64_t walk_num,
  |                                                const int64_t elec_num,
  |                                                const int64_t nucl_num,
  |                                                const int64_t cord_num,
  |                                                const int64_t dim_c_vector,
  |                                                const double *c_vector_full,
  |                                                const int64_t *lkpm_combined_index,
  |                                                const double *tmp_c,
  |                                                const double *dtmp_c,
  |                                                const double *een_rescaled_n,
  |                                                const double *een_rescaled_n_gl,
  |                                                double* const factor_een_grad)
  | {
  | #ifdef HAVE_HPC
  |   return qmckl_compute_jastrow_champ_factor_een_grad_hpc
  | #else
  |   return qmckl_compute_jastrow_champ_factor_een_grad_doc
  | #endif
  |     (context, walk_num, elec_num, nucl_num,
  |      cord_num, dim_c_vector, c_vector_full,
  |      lkpm_combined_index, tmp_c, dtmp_c,
  |      een_rescaled_n, een_rescaled_n_gl,
  |      factor_een_grad);
  | }
  `----


* 3.3.7.4.1 Test

  ,----
  | /* Check if Jastrow is properly initialized */
  | assert(qmckl_jastrow_champ_provided(context));
  | 
  | {
  |   double factor_een_gl[walk_num][4][elec_num];
  |   rc = qmckl_get_jastrow_champ_factor_een_gl(context, &(factor_een_gl[0][0][0]),4*walk_num*elec_num);
  | 
  |   double factor_een_grad[walk_num][3][elec_num];
  |   rc = qmckl_get_jastrow_champ_factor_een_grad(context, &(factor_een_grad[0][0][0]),3*walk_num*elec_num);
  | 
  |   for (int nw=0 ; nw<walk_num ; nw++) {
  |     for (int k=0 ; k<3; k++) {
  |       for (int i=0 ; i<elec_num ; i++) {
  |         assert(fabs(factor_een_gl[nw][k][i] - factor_een_grad[nw][k][i]) < 1e-8);
  |       }
  |     }
  |   }
  | }
  `----


3.4 Total Jastrow
~~~~~~~~~~~~~~~~~

3.4.1 Value
-----------

  Value of the total Jastrow factor: $\exp(J)$


3.4.1.1 Get

  ,----
  | qmckl_exit_code
  | qmckl_get_jastrow_champ_value(qmckl_context context,
  |                             double* const value,
  |                             const int64_t size_max);
  `----


* 3.4.1.1.1 Fortran interface

  ,----
  | interface
  |    integer(qmckl_exit_code) function qmckl_get_jastrow_champ_value (context, &
  |         value, size_max) bind(C)
  |      use, intrinsic :: iso_c_binding
  |      import
  |      implicit none
  |      integer (qmckl_context) , intent(in), value :: context
  |      integer(c_int64_t), intent(in), value       :: size_max
  |      real(c_double),   intent(out)               :: value(size_max)
  |    end function qmckl_get_jastrow_champ_value
  | end interface
  `----


3.4.1.2 Compute

  --------------------------------------------------------------
   Variable    Type                In/Out  Description          
  --------------------------------------------------------------
   `context'   `qmckl_context'     in      Global state         
   `walk_num'  `int64_t'           in      Number of walkers    
   `f_ee'      `double[walk_num]'  in      ee component         
   `f_en'      `double[walk_num]'  in      eN component         
   `f_een'     `double[walk_num]'  in      eeN component        
   `value'     `double[walk_num]'  out     Total Jastrow factor 
  --------------------------------------------------------------

  ,----
  | function qmckl_compute_jastrow_champ_value_doc(context, &
  |      walk_num, f_ee, f_en, f_een, value) &
  |      result(info) bind(C)
  |   use, intrinsic :: iso_c_binding
  |   use qmckl
  |   implicit none
  |   integer(qmckl_context), intent(in), value :: context
  |   integer (c_int64_t) , intent(in)  , value :: walk_num
  |   real    (c_double ) , intent(in)          :: f_ee(walk_num)
  |   real    (c_double ) , intent(in)          :: f_en(walk_num)
  |   real    (c_double ) , intent(in)          :: f_een(walk_num)
  |   real    (c_double ) , intent(out)         :: value(walk_num)
  |   integer(qmckl_exit_code)                  :: info
  | 
  |   integer*8 :: i
  | 
  |   info = QMCKL_SUCCESS
  | 
  |   if (context == QMCKL_NULL_CONTEXT) then
  |      info = QMCKL_INVALID_CONTEXT
  |      return
  |   endif
  | 
  |   if (walk_num <= 0) then
  |      info = QMCKL_INVALID_ARG_2
  |      return
  |   endif
  | 
  |   do i = 1, walk_num
  |      value(i) = f_ee(i) + f_en(i) + f_een(i)
  |   end do
  | 
  |   do i = 1, walk_num
  |      ! Flush to zero to avoid floating-point exception
  |      if (value(i) < -100.d0) then
  |        value(i) = 0.d0
  |      else
  |        value(i) = dexp(value(i))
  |      endif
  |   end do
  | 
  | end function qmckl_compute_jastrow_champ_value_doc
  `----

  ,----
  | qmckl_exit_code qmckl_compute_jastrow_champ_value (
  |       Type Variable,
  |       const qmckl_context context,
  |       const int64_t walk_num,
  |       const double* f_ee,
  |       const double* f_en,
  |       const double* f_een,
  |       double* const value ); 
  `----

  ,----
  | qmckl_exit_code qmckl_compute_jastrow_champ_value_doc (
  |       Type Variable,
  |       const qmckl_context context,
  |       const int64_t walk_num,
  |       const double* f_ee,
  |       const double* f_en,
  |       const double* f_een,
  |       double* const value ); 
  `----

  ,----
  | qmckl_exit_code qmckl_compute_jastrow_champ_value_hpc (
  |       Type Variable,
  |       const qmckl_context context,
  |       const int64_t walk_num,
  |       const double* f_ee,
  |       const double* f_en,
  |       const double* f_een,
  |       double* const value ); 
  `----

  ,----
  | qmckl_exit_code qmckl_compute_jastrow_champ_value (
  |           const qmckl_context context,
  |           const int64_t walk_num,
  |           const double* factor_ee,
  |           const double* factor_en,
  |           const double* factor_een,
  |           double* const value)
  | {
  | 
  | #ifdef HAVE_HPC
  |   return qmckl_compute_jastrow_champ_value_hpc
  | #else
  |   return qmckl_compute_jastrow_champ_value_doc
  | #endif
  |     (context, walk_num, factor_ee, factor_en, factor_een, value);
  | }
  `----


3.4.2 Derivatives
-----------------

  Gradients and Laplacian of the total Jastrow factor: \[ \nabla \left[
  e^{J(\mathbf{r})} \right] = e^{J(\mathbf{r})} \nabla J(\mathbf{r}) \]
  \[ \Delta \left[ e^{J(\mathbf{r})} \right] = e^{J(\mathbf{r})} \left[
  \Delta J(\mathbf{r}) + \nabla J(\mathbf{r}) \cdot \nabla J(\mathbf{r})
  \right] \]


3.4.2.1 Get

  ,----
  | qmckl_exit_code
  | qmckl_get_jastrow_champ_gl(qmckl_context context,
  |                             double* const gl,
  |                             const int64_t size_max);
  | 
  | qmckl_exit_code
  | qmckl_get_jastrow_champ_grad(qmckl_context context,
  |                             double* const grad,
  |                             const int64_t size_max);
  `----

  ,----
  | qmckl_exit_code
  | qmckl_get_jastrow_champ_grad(qmckl_context context,
  |                             double* const grad,
  |                             const int64_t size_max);
  `----


* 3.4.2.1.1 Fortran interface

  ,----
  | interface
  |    integer(qmckl_exit_code) function qmckl_get_jastrow_champ_gl (context, &
  |         gl, size_max) bind(C)
  |      use, intrinsic :: iso_c_binding
  |      import
  |      implicit none
  |      integer (qmckl_context) , intent(in), value :: context
  |      integer(c_int64_t), intent(in), value       :: size_max
  |      real(c_double),   intent(out)               :: gl(size_max)
  |    end function qmckl_get_jastrow_champ_gl
  | end interface
  `----


3.4.2.2 Compute GL

  ---------------------------------------------------------------------------
   Variable    Type                             In/Out  Description          
  ---------------------------------------------------------------------------
   `context'   `qmckl_context'                  in      Global state         
   `walk_num'  `int64_t'                        in      Number of walkers    
   `elec_num'  `int64_t'                        in      Number of electrons  
   `value'     `double[walk_num]'               in      Total Jastrow        
   `gl_ee'     `double[walk_num][4][elec_num]'  in      ee component         
   `gl_en'     `double[walk_num][4][elec_num]'  in      eN component         
   `gl_een'    `double[walk_num][4][elec_num]'  in      eeN component        
   `gl'        `double[walk_num][4][elec_num]'  out     Total Jastrow factor 
  ---------------------------------------------------------------------------

  ,----
  | function qmckl_compute_jastrow_champ_gl_doc(context, &
  |      walk_num, elec_num, value, gl_ee, gl_en, gl_een, gl) &
  |      bind(C) result(info)
  |   use qmckl
  |   use, intrinsic :: iso_c_binding
  |   implicit none
  |   integer(qmckl_context), intent(in), value :: context
  |   integer (c_int64_t) , intent(in)  , value :: walk_num
  |   integer (c_int64_t) , intent(in)  , value :: elec_num
  |   real    (c_double ) , intent(in)          :: value(walk_num)
  |   real    (c_double ) , intent(in)          :: gl_ee(elec_num,4,walk_num)
  |   real    (c_double ) , intent(in)          :: gl_en(elec_num,4,walk_num)
  |   real    (c_double ) , intent(in)          :: gl_een(elec_num,4,walk_num)
  |   real    (c_double ) , intent(out)         :: gl(elec_num,4,walk_num)
  | 
  |   integer(qmckl_exit_code)                 :: info
  |   integer*8 :: i, j, k
  | 
  |   info = QMCKL_SUCCESS
  | 
  |   if (context == QMCKL_NULL_CONTEXT) then
  |      info = QMCKL_INVALID_CONTEXT
  |      return
  |   endif
  | 
  |   if (walk_num <= 0) then
  |      info = QMCKL_INVALID_ARG_2
  |      return
  |   endif
  | 
  |   do k = 1, walk_num
  |      do j=1,4
  |         do i = 1, elec_num
  |            gl(i,j,k) = gl_ee(i,j,k) + gl_en(i,j,k) + gl_een(i,j,k)
  |         end do
  |      end do
  |      do i = 1, elec_num
  |         gl(i,4,k) = gl(i,4,k) + &
  |              gl(i,1,k) * gl(i,1,k) + &
  |              gl(i,2,k) * gl(i,2,k) + &
  |              gl(i,3,k) * gl(i,3,k)
  |      end do
  |      gl(:,:,k) = gl(:,:,k) * value(k)
  |   end do
  | 
  | 
  | end function qmckl_compute_jastrow_champ_gl_doc
  `----

  ,----
  | qmckl_exit_code qmckl_compute_jastrow_champ_gl (
  |       Type Variable,
  |       const qmckl_context context,
  |       const int64_t walk_num,
  |       const int64_t elec_num,
  |       const double* value,
  |       const double* gl_ee,
  |       const double* gl_en,
  |       const double* gl_een,
  |       double* const gl ); 
  `----

  ,----
  | qmckl_exit_code qmckl_compute_jastrow_champ_gl_doc (
  |       Type Variable,
  |       const qmckl_context context,
  |       const int64_t walk_num,
  |       const int64_t elec_num,
  |       const double* value,
  |       const double* gl_ee,
  |       const double* gl_en,
  |       const double* gl_een,
  |       double* const gl ); 
  `----

  ,----
  | qmckl_exit_code qmckl_compute_jastrow_champ_gl_hpc (
  |       Type Variable,
  |       const qmckl_context context,
  |       const int64_t walk_num,
  |       const int64_t elec_num,
  |       const double* value,
  |       const double* gl_ee,
  |       const double* gl_en,
  |       const double* gl_een,
  |       double* const gl ); 
  `----

  ,----
  | qmckl_exit_code qmckl_compute_jastrow_champ_gl (
  |       const qmckl_context context,
  |       const int64_t walk_num,
  |       const int64_t elec_num,
  |       const double* value,
  |       const double* gl_ee,
  |       const double* gl_en,
  |       const double* gl_een,
  |       double* const gl)
  | {
  | 
  | #ifdef HAVE_HPC
  |   return qmckl_compute_jastrow_champ_gl_hpc
  | #else
  |   return qmckl_compute_jastrow_champ_gl_doc
  | #endif
  |     (context, walk_num, elec_num, value, gl_ee, gl_en, gl_een, gl);
  | }
  `----


* 3.4.2.2.1 Test

  ,----
  | printf("Total Jastrow derivatives\n");
  | /* Check if Jastrow is properly initialized */
  | assert(qmckl_jastrow_champ_provided(context));
  | {
  | 
  |   double factor_ee_gl[walk_num][4][elec_num];
  |   rc = qmckl_check(context,
  |                    qmckl_get_jastrow_champ_factor_ee_gl(context, &(factor_ee_gl[0][0][0]), walk_num*elec_num*4)
  |                    );
  |   assert(rc == QMCKL_SUCCESS);
  | 
  |   double factor_en_gl[walk_num][4][elec_num];
  |   rc = qmckl_check(context,
  |                    qmckl_get_jastrow_champ_factor_en_gl(context, &(factor_en_gl[0][0][0]), walk_num*elec_num*4)
  |                    );
  |   assert(rc == QMCKL_SUCCESS);
  | 
  |   double factor_een_gl[walk_num][4][elec_num];
  |   rc = qmckl_check(context,
  |                    qmckl_get_jastrow_champ_factor_een_gl(context, &(factor_een_gl[0][0][0]), walk_num*elec_num*4)
  |                    );
  |   assert(rc == QMCKL_SUCCESS);
  | 
  |   double total_j_deriv[walk_num][4][elec_num];
  |   rc = qmckl_check(context,
  |                    qmckl_get_jastrow_champ_gl(context, &(total_j_deriv[0][0][0]), walk_num*elec_num*4)
  |                    );
  |   assert(rc == QMCKL_SUCCESS);
  | 
  |   double total_j[walk_num];
  |   rc = qmckl_check(context,
  |                    qmckl_get_jastrow_champ_value(context, &(total_j[0]), walk_num)
  |                    );
  |   assert(rc == QMCKL_SUCCESS);
  | 
  | 
  |   for (int64_t k=0 ; k< walk_num ; ++k) {
  |     for (int64_t m=0 ; m<4; ++m) {
  |       for (int64_t e=0 ; e<elec_num; ++e) {
  |         if (m < 3) { /* test only gradients */
  |           if (fabs(total_j_deriv[k][m][e]/total_j[k] - (factor_ee_gl[k][m][e] + factor_en_gl[k][m][e] + factor_een_gl[k][m][e])) > 1e-12) {
  |             printf("k = %ld\n", k);
  |             printf("m = %ld\n", m);
  |             printf("e = %ld\n", e);
  |             printf("total_j_deriv/total_j = %20.15e\n", total_j_deriv[k][m][e]/total_j[k]);
  |             printf("factor_ee_gl + factor_en_gl + factor_een_gl = %20.15e\n", factor_ee_gl[k][m][e] + factor_en_gl[k][m][e] + factor_een_gl[k][m][e]);
  |             fflush(stdout);
  |           }
  |           assert (fabs(total_j_deriv[k][m][e]/total_j[k] - (factor_ee_gl[k][m][e] + factor_en_gl[k][m][e] + factor_een_gl[k][m][e])) < 1.e-8);
  |         }
  |       }
  |     }
  |   }
  | 

  `----


3.4.2.3 Compute Gradient only

  ---------------------------------------------------------------------------
   Variable    Type                             In/Out  Description          
  ---------------------------------------------------------------------------
   `context'   `qmckl_context'                  in      Global state         
   `walk_num'  `int64_t'                        in      Number of walkers    
   `elec_num'  `int64_t'                        in      Number of electrons  
   `value'     `double[walk_num]'               in      Total Jastrow        
   `gl_ee'     `double[walk_num][4][elec_num]'  in      ee component         
   `gl_en'     `double[walk_num][4][elec_num]'  in      eN component         
   `grad_een'  `double[walk_num][3][elec_num]'  in      eeN component        
   `grad'      `double[walk_num][3][elec_num]'  out     Total Jastrow factor 
  ---------------------------------------------------------------------------

  ,----
  | function qmckl_compute_jastrow_champ_grad_doc(context, &
  |      walk_num, elec_num, value, gl_ee, gl_en, grad_een, grad) &
  |      result(info) bind(C)
  |   use, intrinsic :: iso_c_binding
  |   use qmckl
  |   implicit none
  |   integer(qmckl_context), intent(in), value :: context
  |   integer (c_int64_t) , intent(in)  , value :: walk_num
  |   integer (c_int64_t) , intent(in)  , value :: elec_num
  |   real    (c_double ) , intent(in)          :: value(walk_num)
  |   real    (c_double ) , intent(in)          :: gl_ee(elec_num,4,walk_num)
  |   real    (c_double ) , intent(in)          :: gl_en(elec_num,4,walk_num)
  |   real    (c_double ) , intent(in)          :: grad_een(elec_num,3,walk_num)
  |   real    (c_double ) , intent(out)         :: grad(elec_num,3,walk_num)
  | 
  |   integer(qmckl_exit_code) :: info
  |   integer*8 :: i, j, k
  | 
  |   info = QMCKL_SUCCESS
  | 
  |   if (context == QMCKL_NULL_CONTEXT) then
  |      info = QMCKL_INVALID_CONTEXT
  |      return
  |   endif
  | 
  |   if (walk_num <= 0) then
  |      info = QMCKL_INVALID_ARG_2
  |      return
  |   endif
  | 
  |   do k = 1, walk_num
  |      do j=1,3
  |         do i = 1, elec_num
  |            grad(i,j,k) = gl_ee(i,j,k) + gl_en(i,j,k) + grad_een(i,j,k)
  |         end do
  |      end do
  |      grad(:,:,k) = grad(:,:,k) * value(k)
  |   end do
  | 
  | 
  | end function qmckl_compute_jastrow_champ_grad_doc
  `----

  ,----
  | qmckl_exit_code qmckl_compute_jastrow_champ_grad (
  |       Type Variable,
  |       const qmckl_context context,
  |       const int64_t walk_num,
  |       const int64_t elec_num,
  |       const double* value,
  |       const double* gl_ee,
  |       const double* gl_en,
  |       const double* grad_een,
  |       double* const grad ); 
  `----

  ,----
  | qmckl_exit_code qmckl_compute_jastrow_champ_grad_doc (
  |       Type Variable,
  |       const qmckl_context context,
  |       const int64_t walk_num,
  |       const int64_t elec_num,
  |       const double* value,
  |       const double* gl_ee,
  |       const double* gl_en,
  |       const double* grad_een,
  |       double* const grad ); 
  `----

  ,----
  | qmckl_exit_code qmckl_compute_jastrow_champ_grad_hpc (
  |       Type Variable,
  |       const qmckl_context context,
  |       const int64_t walk_num,
  |       const int64_t elec_num,
  |       const double* value,
  |       const double* gl_ee,
  |       const double* gl_en,
  |       const double* grad_een,
  |       double* const grad ); 
  `----


  ,----
  | qmckl_exit_code qmckl_compute_jastrow_champ_grad (
  |       const qmckl_context context,
  |       const int64_t walk_num,
  |       const int64_t elec_num,
  |       const double* value,
  |       const double* gl_ee,
  |       const double* gl_en,
  |       const double* grad_een,
  |       double* const grad)
  | {
  | 
  | #ifdef HAVE_HPC
  |   return qmckl_compute_jastrow_champ_grad_hpc
  | #else
  |   return qmckl_compute_jastrow_champ_grad_doc
  | #endif
  |     (context, walk_num, elec_num, value, gl_ee, gl_en, grad_een, grad);
  | }
  `----


* 3.4.2.3.1 Test

  ,----
  | printf("Total Jastrow gradient only\n");
  | /* Check if Jastrow is properly initialized */
  | assert(qmckl_jastrow_champ_provided(context));
  | 
  | {
  |   double total_j_grad[walk_num][3][elec_num];
  |   rc = qmckl_check(context,
  |                   qmckl_get_jastrow_champ_grad(context, &(total_j_grad[0][0][0]), walk_num*elec_num*3)
  |                   );
  |   assert(rc == QMCKL_SUCCESS);
  | 
  | 
  |   double total_j_deriv[walk_num][4][elec_num];
  |   rc = qmckl_check(context,
  |                   qmckl_get_jastrow_champ_gl(context, &(total_j_deriv[0][0][0]), walk_num*elec_num*4)
  |                   );
  |   assert(rc == QMCKL_SUCCESS);
  | 
  | 
  | 
  |   for (int64_t k=0 ; k< walk_num ; ++k) {
  |     for (int64_t m=0 ; m<3; ++m) {
  |       for (int64_t e=0 ; e<elec_num; ++e) {
  |         if (fabs(total_j_grad[k][m][e] - total_j_deriv[k][m][e]) > 1e-12) {
  |           printf("%ld %ld %ld\n", k, m, e);
  |           printf("total_j_deriv = %20.15e\n", total_j_deriv[k][m][e]);
  |           printf("total_j_grad  = %20.15e\n", total_j_grad[k][m][e]);
  |           fflush(stdout);
  |         }
  |         assert (fabs(total_j_deriv[k][m][e] - total_j_grad[k][m][e]) < 1.e-8);
  |       }
  |     }
  |   }
  | }
  | 
  | }
  `----
