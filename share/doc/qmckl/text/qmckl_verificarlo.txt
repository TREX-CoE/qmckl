                            ________________

                             VERIFICARLO CI

                                TREX CoE
                            ________________


Table of Contents
_________________

1. Verificarlo probes
.. 1. Automatically initialize the `vfc_probe' object if `VFC_CI' is defined
.. 2. Standard probe, without check
.. 3. Probe with absolute check
.. 4. Probe with relative check
.. 5. Automatically delete and dump the vfc_probe object if `VFC_CI' is defined
2. Fortran wrappers





1 Verificarlo probes
====================

  This file contains utility functions to enable the Verificarlo
  Continuous Integration system (`VFC_CI').

  It is a wrapper to Verificarlo's `vfc_probes' system. The goal of
  QMCkl probes is to simplify the use of `vfc_probes', and to provide
  functions that can be called either with or without `VFC_CI' support
  by using `#ifndef' statements :

  - when `VFC_CI' is disabled, the functions will either return `false'
    (no error) or perform a check based on a reference value

  - when `VFC_CI' is enabled, the functions will simply encapsulate
  calls to `vfc_probe'.

  Moreover, one does not have to worry about the life cycle of the
  probes structure, as it is automatically created, dumped and freed by
  this wrapper.

  `VFC_CI' support can be enabled by using the following configure
  command :

  ,----
  | QMCKL_DEVEL=1 ./configure --prefix=$PWD/_install --enable-silent-rules \
  |   --enable-maintainer-mode CC=verificarlo-f FC=verificarlo-f --host=x86_64
  `----

  Finally, this wrapper also comes with a Fortran interface (in its
  dedicated file).

  To learn more about Verificarlo CI :
  <https://github.com/verificarlo/verificarlo/blob/master/doc/06-Postprocessing.md#verificarlo-ci>


1.1 Automatically initialize the `vfc_probe' object if `VFC_CI' is defined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  ,----
  | void qmckl_init_probes();
  `----

  ,----
  | void qmckl_init_probes(){
  | #ifdef VFC_CI
  |         probes = vfc_init_probes();
  | #endif
  | }
  `----


1.2 Standard probe, without check
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  - if `VFC_CI' is defined, place a standard probe
  - if `VFC_CI' is undefined, return `false' (no error)

    ,----
    | bool qmckl_probe(
    |     char * testName,
    |     char * varName,
    |     double value
    | );
    `----

    ,----
    | bool qmckl_probe(
    |     char * testName,
    |     char * varName,
    |     double value)
    | {
    | #ifdef VFC_CI
    |     return vfc_probe(&probes, testName, varName, value);
    | #else
    |         return false;
    | #endif
    | }
    `----


1.3 Probe with absolute check
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  - if `VFC_CI' is defined, place a probe with an absolute check
  - if `VFC_CI' is undefined, perform an absolute check based on target
    value and accuracy

    ,----
    | bool qmckl_probe_check(
    |     char * testName,
    |     char * varName,
    |     double value,
    |     double expectedValue,
    |     double accuracyTarget
    | );
    `----

    ,----
    | bool qmckl_probe_check(
    |     char * testName,
    |     char * varName,
    |     double value,
    |     double expectedValue,
    |     double accuracyTarget)
    | {
    | #ifdef VFC_CI
    |     return vfc_probe_check(&probes, testName, varName, value, accuracyTarget);
    | #else
    |     return !(fabs(value - expectedValue) < accuracyTarget);
    | #endif
    | }
    `----


1.4 Probe with relative check
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  - if `VFC_CI' is defined, place a probe with a relative check
  - if `VFC_CI' is undefined, perform a relative check based on target
    value and accuracy

    ,----
    | bool qmckl_probe_check_relative(
    |     char * testName,
    |     char * varName,
    |     double value,
    |     double expectedValue,
    |     double accuracyTarget
    | );
    `----

    ,----
    | bool qmckl_probe_check_relative (
    |     char * testName,
    |     char * varName,
    |     double value,
    |     double expectedValue,
    |     double accuracyTarget)
    | {
    | #ifdef VFC_CI
    |     return vfc_probe_check_relative(&probes, testName, varName, value, accuracyTarget);
    | #else
    |     return !(fabs(value - expectedValue) / fabs(expectedValue) < accuracyTarget);
    | #endif
    | }
    `----


1.5 Automatically delete and dump the vfc_probe object if `VFC_CI' is defined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  ,----
  | void qmckl_dump_probes();
  `----

  ,----
  | void qmckl_dump_probes(){
  | #ifdef VFC_CI
  |     vfc_dump_probes(&probes);
  | #endif
  | }
  `----


2 Fortran wrappers
==================

  ,----
  | bool qmckl_probe_f(
  |     char * testName,
  |     char * varName,
  |     double * value
  | );
  | 
  | bool qmckl_probe_check_f(
  |     char * testName,
  |     char * varName,
  |     double * value,
  |     double * expectedValue,
  |     double * accuracyTarget
  | );
  | 
  | 
  | bool qmckl_probe_check_relative_f(
  |     char * testName,
  |     char * varName,
  |     double * value,
  |     double * expectedValue,
  |     double * accuracyTarget
  | );
  `----

  ,----
  | bool qmckl_probe_f(
  |     char * testName,
  |     char * varName,
  |     double * value)
  | {
  |     return qmckl_probe(testName, varName, *value);
  | }
  | 
  | 
  | bool qmckl_probe_check_f(
  |     char * testName,
  |     char * varName,
  |     double * value,
  |     double * expectedValue,
  |     double * accuracyTarget)
  | {
  |     return qmckl_probe_check(
  |         testName, varName,
  |         *value, *expectedValue, *accuracyTarget
  |     );
  | }
  | 
  | 
  | bool qmckl_probe_check_relative_f(
  |     char * testName,
  |     char * varName,
  |     double * value,
  |     double * expectedValue,
  |     double * accuracyTarget)
  | {
  |     return qmckl_probe_check_relative(
  |         testName, varName,
  |         *value, *expectedValue, *accuracyTarget
  |     );
  | }
  `----

  ,----
  | module qmckl_verificarlo_f
  |   interface
  |      logical(c_bool) function qmckl_probe &
  |           (testName, varName, val) &
  |           bind(C, name="qmckl_probe_f")
  | 
  |        use, intrinsic :: iso_c_binding
  |        import
  |        implicit none
  | 
  |        character(C_CHAR), dimension(*) :: testName
  |        character(C_CHAR), dimension(*) :: varName
  | 
  |        real(C_DOUBLE) :: val
  |      end function qmckl_probe
  | 
  |      logical(c_bool) function qmckl_probe_check &
  |           (testName, varName, val, expectedValue, accuracyTarget) &
  |           bind(C, name="qmckl_probe_check_f")
  | 
  |        use, intrinsic :: iso_c_binding
  |        import
  |        implicit none
  | 
  |        character(C_CHAR), dimension(*) :: testName
  |        character(C_CHAR), dimension(*) :: varName
  | 
  |        real(C_DOUBLE) :: val
  |        real(C_DOUBLE) :: expectedValue
  |        real(C_DOUBLE) :: accuracyTarget
  |      end function qmckl_probe_check
  | 
  |      logical(c_bool) function qmckl_probe_check_relative &
  |           (testName, varName, val, expectedValue, accuracyTarget) &
  |           bind(C, name="qmckl_probe_check_relative_f")
  | 
  |        use, intrinsic :: iso_c_binding
  |        import
  |        implicit none
  | 
  |        character(C_CHAR), dimension(*) :: testName
  |        character(C_CHAR), dimension(*) :: varName
  | 
  |        real(C_DOUBLE) :: val
  |        real(C_DOUBLE) :: expectedValue
  |        real(C_DOUBLE) :: accuracyTarget
  |      end function qmckl_probe_check_relative
  |   end interface
  | end module qmckl_verificarlo_f
  `----
