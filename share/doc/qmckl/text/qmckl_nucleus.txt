                               __________

                                NUCLEUS

                                TREX CoE
                               __________


Table of Contents
_________________

1. Context
.. 1. Data structure
.. 2. Access functions
.. 3. Initialization functions
.. 4. Test
2. Computation
.. 1. Nucleus-nucleus distances
..... 1. Get
..... 2. Compute
..... 3. Test
.. 2. Nuclear repulsion energy
..... 1. Get
..... 2. Compute
..... 3. Test





1 Context
=========

  The following data stored in the context:

  --------------------------------------------------------------------------
   `uninitialized'  int32_t       Keeps bit set for uninitialized data      
   `num'            int64_t       Total number of nuclei                    
   `provided'       bool          If true, `nucleus' is valid               
   `charge'         qmckl_vector  Nuclear charges                           
   `coord'          qmckl_matrix  Nuclear coordinates, in transposed format 
   `coord_date'     int64_t       Nuclear coordinates, date if modified     

  Computed data:

  ---------------------------------------------------------------------------------------
   `nn_distance'       qmckl_matrix  Nucleus-nucleus distances                           
   `nn_distance_date'  int64_t       Date when Nucleus-nucleus distances were computed   
   `repulsion'         double        Nuclear repulsion energy                            
   `repulsion_date'    int64_t       Date when the nuclear repulsion energy was computed 


1.1 Data structure
~~~~~~~~~~~~~~~~~~

  ,----
  | typedef struct qmckl_nucleus_struct {
  |   int64_t      num;
  |   int64_t      repulsion_date;
  |   int64_t      nn_distance_date;
  |   int64_t      coord_date;
  |   qmckl_vector charge;
  |   qmckl_matrix coord;
  |   qmckl_matrix nn_distance;
  |   double       repulsion;
  |   int32_t      uninitialized;
  |   bool         provided;
  | } qmckl_nucleus_struct;
  | 
  `----

  The `uninitialized' integer contains one bit set to one for each
  initialization function which has not been called. It becomes equal to
  zero after all initialization functions have been called. The struct
  is then initialized and `provided == true'.  Some values are
  initialized by default, and are not concerned by this mechanism.

  ,----
  | qmckl_exit_code qmckl_init_nucleus(qmckl_context context);
  `----

  ,----
  | qmckl_exit_code qmckl_init_nucleus(qmckl_context context) {
  | 
  |   if (qmckl_context_check(context) == QMCKL_NULL_CONTEXT) {
  |     return false;
  |   }
  | 
  |   qmckl_context_struct* const ctx = (qmckl_context_struct*) context;
  |   assert (ctx != NULL);
  | 
  |   ctx->nucleus.uninitialized = (1 << 3) - 1;
  | 
  |   /* Default values */
  | 
  |   return QMCKL_SUCCESS;
  | }
  `----


1.2 Access functions
~~~~~~~~~~~~~~~~~~~~

  When all the data relative to nuclei have been set, the following
  function returns `true'.

  ,----
  | bool qmckl_nucleus_provided (const qmckl_context context);
  `----


1.3 Initialization functions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  To set the data relative to the nuclei in the context, the following
  functions need to be called.

  ,----
  | qmckl_exit_code
  | qmckl_set_nucleus_num(qmckl_context context,
  |                       const int64_t num);
  `----

  Sets the number of nuclei.

  ,----
  | qmckl_exit_code
  | qmckl_set_nucleus_charge(qmckl_context context,
  |                          const double* charge,
  |                          const int64_t size_max);
  `----

  Sets the nuclear charges of all the atoms.

  ,----
  | qmckl_exit_code
  | qmckl_set_nucleus_coord(qmckl_context context,
  |                         const char transp,
  |                         const double* coord,
  |                         const int64_t size_max);
  `----

  Sets the nuclear coordinates of all the atoms. The coordinates are be
  given in atomic units.


1.4 Test
~~~~~~~~

  ,----
  | const double*   nucl_charge   = chbrclf_charge;
  | const double*   nucl_coord    = &(chbrclf_nucl_coord[0][0]);
  | 
  | /* --- */
  | 
  | qmckl_exit_code rc;
  | 
  | assert(!qmckl_nucleus_provided(context));
  | 
  | int64_t n;
  | rc = qmckl_get_nucleus_num (context, &n);
  | assert(rc == QMCKL_NOT_PROVIDED);
  | 
  | 
  | rc = qmckl_set_nucleus_num (context, chbrclf_nucl_num);
  | qmckl_check(context, rc);
  | assert(!qmckl_nucleus_provided(context));
  | 
  | rc = qmckl_get_nucleus_num (context, &n);
  | qmckl_check(context, rc);
  | assert(n == chbrclf_nucl_num);
  | 
  | double nucl_coord2[3*chbrclf_nucl_num];
  | 
  | rc = qmckl_get_nucleus_coord (context, 'T', nucl_coord2, 3*chbrclf_nucl_num);
  | assert(rc == QMCKL_NOT_PROVIDED);
  | 
  | rc = qmckl_set_nucleus_coord (context, 'T', &(nucl_coord[0]), 3*chbrclf_nucl_num);
  | qmckl_check(context, rc);
  | 
  | assert(!qmckl_nucleus_provided(context));
  | 
  | rc = qmckl_get_nucleus_coord (context, 'N', nucl_coord2, 3*chbrclf_nucl_num);
  | qmckl_check(context, rc);
  | for (size_t k=0 ; k<3 ; ++k) {
  |   for (int64_t i=0 ; i<chbrclf_nucl_num ; ++i) {
  |     assert( nucl_coord[chbrclf_nucl_num*k+i] == nucl_coord2[3*i+k] );
  |   }
  | }
  | 
  | rc = qmckl_get_nucleus_coord (context, 'T', nucl_coord2, 3*chbrclf_nucl_num);
  | qmckl_check(context, rc);
  | for (int64_t i=0 ; i<3*chbrclf_nucl_num ; ++i) {
  |   assert( nucl_coord[i] == nucl_coord2[i] );
  | }
  | 
  | double nucl_charge2[chbrclf_nucl_num];
  | 
  | rc = qmckl_get_nucleus_charge(context, nucl_charge2, chbrclf_nucl_num);
  | assert(rc == QMCKL_NOT_PROVIDED);
  | 
  | rc = qmckl_set_nucleus_charge(context, nucl_charge, chbrclf_nucl_num);
  | qmckl_check(context, rc);
  | 
  | rc = qmckl_get_nucleus_charge(context, nucl_charge2, chbrclf_nucl_num);
  | qmckl_check(context, rc);
  | for (int64_t i=0 ; i<chbrclf_nucl_num ; ++i) {
  |   assert( nucl_charge[i] == nucl_charge2[i] );
  |  }
  | assert(qmckl_nucleus_provided(context));
  `----


2 Computation
=============

  The computed data is stored in the context so that it can be reused by
  different kernels. To ensure that the data is valid, for each computed
  data the date of the context is stored when it is computed.  To know
  if some data needs to be recomputed, we check if the date of the
  dependencies are more recent than the date of the data to compute. If
  it is the case, then the data is recomputed and the current date is
  stored.


2.1 Nucleus-nucleus distances
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

2.1.1 Get
---------

  ,----
  | qmckl_exit_code
  | qmckl_get_nucleus_nn_distance(qmckl_context context,
  |                               double* distance,
  |                               const int64_t size_max);
  `----


2.1.2 Compute
-------------

   qmckl_context  context                          in   Global state                   
   int64_t        nucl_num                         in   Number of nuclei               
   double         coord[3][nucl_num]               in   Nuclear coordinates (au)       
   double         nn_distance[nucl_num][nucl_num]  out  Nucleus-nucleus distances (au) 

  ,----
  | integer function qmckl_compute_nn_distance_f(context, nucl_num, coord, nn_distance) &
  |      result(info)
  |   use qmckl
  |   implicit none
  |   integer(qmckl_context), intent(in)  :: context
  |   integer*8             , intent(in)  :: nucl_num
  |   double precision      , intent(in)  :: coord(nucl_num,3)
  |   double precision      , intent(out) :: nn_distance(nucl_num,nucl_num)
  | 
  |   integer*8 :: k
  | 
  |   info = QMCKL_SUCCESS
  | 
  |   if (context == QMCKL_NULL_CONTEXT) then
  |      info = QMCKL_INVALID_CONTEXT
  |      return
  |   endif
  | 
  |   if (nucl_num <= 0) then
  |      info = QMCKL_INVALID_ARG_2
  |      return
  |   endif
  | 
  |   info = qmckl_distance(context, 'T', 'T', nucl_num, nucl_num, &
  |           coord, nucl_num, &
  |           coord, nucl_num, &
  |           nn_distance, nucl_num)
  | 
  | end function qmckl_compute_nn_distance_f
  `----


2.1.3 Test
----------

  ,----
  | /* Reference input data */
  | 
  | assert(qmckl_nucleus_provided(context));
  | 
  | double distance[chbrclf_nucl_num*chbrclf_nucl_num];
  | rc = qmckl_get_nucleus_nn_distance(context, distance, chbrclf_nucl_num*chbrclf_nucl_num);
  | assert(distance[0] == 0.);
  | assert(distance[1] == distance[chbrclf_nucl_num]);
  | assert(fabs(distance[1]-2.070304721365169) < 1.e-12);
  | 
  `----


2.2 Nuclear repulsion energy
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  \[ V_{NN} = \sum_{A=1}^{N-1} \sum_{B>A}^N \frac{Q_A Q_B}{R_{AB}} \]


2.2.1 Get
---------

  ,----
  | qmckl_exit_code qmckl_get_nucleus_repulsion(qmckl_context context, double* const energy);
  `----


2.2.2 Compute
-------------

   qmckl_context  context                          in   Global state                   
   int64_t        nucl_num                         in   Number of nuclei               
   double         charge[nucl_num]                 in   Nuclear charges (au)           
   double         nn_distance[nucl_num][nucl_num]  in   Nucleus-nucleus distances (au) 
   double         energy                           out  Nuclear repulsion energy       

  ,----
  | integer function qmckl_compute_nucleus_repulsion_f(context, nucl_num, charge, nn_distance, energy) &
  |      result(info)
  |   use qmckl
  |   implicit none
  |   integer(qmckl_context), intent(in)  :: context
  |   integer*8             , intent(in)  :: nucl_num
  |   double precision      , intent(in)  :: charge(nucl_num)
  |   double precision      , intent(in)  :: nn_distance(nucl_num,nucl_num)
  |   double precision      , intent(out) :: energy
  | 
  |   integer*8 :: i, j
  | 
  |   info = QMCKL_SUCCESS
  | 
  |   if (context == QMCKL_NULL_CONTEXT) then
  |      info = QMCKL_INVALID_CONTEXT
  |      return
  |   endif
  | 
  |   if (nucl_num <= 0) then
  |      info = QMCKL_INVALID_ARG_2
  |      return
  |   endif
  | 
  |   energy = 0.d0
  |   do j=2, nucl_num
  |      do i=1, j-1
  |         if (dabs(nn_distance(i,j)) > 1e-5) then
  |           energy = energy + charge(i) * charge(j) / nn_distance(i,j)
  |         endif
  |      end do
  |   end do
  | 
  | end function qmckl_compute_nucleus_repulsion_f
  `----


2.2.3 Test
----------

  ,----
  | /* Reference input data */
  | 
  | assert(qmckl_nucleus_provided(context));
  | 
  | double rep;
  | rc = qmckl_get_nucleus_repulsion(context, &rep);
  | assert(rep - 318.2309879436158 < 1.e-10);
  | 
  `----
