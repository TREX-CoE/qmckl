#+TITLE: Electrons
#+SETUPFILE: ../tools/theme.setup
#+INCLUDE: ../tools/lib.org

In conventional QMC simulations, up-spin and down-spin electrons are
different. The ~electron~  data structure contains the number of
up-spin and down-spin electrons, and the electron coordinates.

The electrons are stored as points in the following order: for each walker,
first up-spin electrons and then down-spin electrons.

If the points are set with the ='N'= flag, the order of
the components is =[ (x,y,z), (x,y,z), ... ]=
Using the ='T'= flage, it is =[ (x,x,x,...), (y,y,y,...), (z,z,z,...) ]=

# TODO: replace the qmckl_matrix by qmckl_point data structures.
# TODO: in provide funcions, replace the way to check that dimensions
# have changed

* Headers                                                          :noexport:
  #+begin_src elisp :noexport :results none
(org-babel-lob-ingest "../tools/lib.org")
#+end_src


  #+begin_src c :tangle (eval h_private_type) :exports none
#ifndef QMCKL_ELECTRON_HPT
#define QMCKL_ELECTRON_HPT
#include <stdbool.h>
#include "qmckl_point_private_type.h"
  #+end_src

  #+begin_src c :tangle (eval h_private_func) :exports none
#ifndef QMCKL_ELECTRON_HPF
#define QMCKL_ELECTRON_HPF
#include "qmckl_electron_private_type.h"
#include "qmckl_point_private_type.h"
#include "qmckl_point_private_func.h"
  #+end_src

  #+begin_src c :tangle (eval c_test) :noweb yes :exports none
#include "qmckl.h"
#include <assert.h>
#include <stdio.h>
#include <math.h>
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include "chbrclf.h"

int main() {
  qmckl_context context;
  context = qmckl_context_create();
  #+end_src

  #+begin_src c :tangle (eval c) :exports none
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#ifdef HAVE_STDINT_H
#include <stdint.h>
#elif HAVE_INTTYPES_H
#include <inttypes.h>
#endif

#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <assert.h>
#include <math.h>

#include <stdio.h>

#include "qmckl.h"
#include "qmckl_context_private_type.h"
#include "qmckl_memory_private_type.h"
#include "qmckl_memory_private_func.h"
#include "qmckl_electron_private_func.h"
  #+end_src

* Context

** Data structure
  The following data stored in the context:

  | Variable                  | Type               | Description                          |
  |---------------------------+--------------------+--------------------------------------|
  | ~uninitialized~           | ~int32_t~          | Keeps bit set for uninitialized data |
  | ~num~                     | ~int64_t~          | Total number of electrons            |
  | ~up_num~                  | ~int64_t~          | Number of up-spin electrons          |
  | ~down_num~                | ~int64_t~          | Number of down-spin electrons        |
  | ~provided~                | ~bool~             | If true, ~electron~ is valid         |
  | ~walker~                  | ~qmckl_point~      | Current set of walkers               |
  | ~walker_old~              | ~qmckl_point~      | Previous set of walkers              |

  Computed data:

  | Variable            | Type                           | Description                                                  |
  |---------------------+--------------------------------+--------------------------------------------------------------|
  | ~ee_distance~       | ~double[walker.num][num][num]~ | Electron-electron distances                                  |
  | ~ee_distance_date~  | ~uint64_t~                     | Last modification date of the electron-electron distances    |
  | ~en_distance~       | ~double[num][nucl_num]~        | Electron-nucleus distances                                   |
  | ~en_distance_date~  | ~uint64_t~                     | Last modification date of the electron-electron distances    |
  | ~ee_potential~      | ~double[walker.num]~           | Electron-electron potential energy                           |
  | ~ee_potential_date~ | ~uint64_t~                     | Last modification date of the electron-electron potential    |
  | ~en_potential~      | ~double[walker.num]~           | Electron-nucleus potential energy                            |
  | ~en_potential_date~ | ~int64_t~                      | Date when the electron-nucleus potential energy was computed |


   #+begin_src c :comments org :tangle (eval h_private_type) :exports none

typedef struct qmckl_walker_struct {
  int64_t num;
  qmckl_point_struct point;
} qmckl_walker;

typedef struct qmckl_electron_struct {
  int64_t        num;
  int64_t        up_num;
  int64_t        down_num;
  qmckl_walker   walker;
  qmckl_walker   walker_old;
  uint64_t       ee_distance_date;
  uint64_t       en_distance_date;
  uint64_t       ee_potential_date;
  uint64_t       en_potential_date;
  double*        ee_distance;
  double*        en_distance;
  double*        ee_potential;
  double*        en_potential;
  int32_t        uninitialized;
  bool           provided;
} qmckl_electron_struct;

   #+end_src

   The ~uninitialized~ integer contains one bit set to one for each
   initialization function which has not been called. It becomes equal
   to zero after all initialization functions have been called. The
   struct is then initialized and ~provided == true~.
   Some values are initialized by default, and are not concerned by
   this mechanism.

   #+begin_src c :comments org :tangle (eval h_private_func) :exports none
qmckl_exit_code qmckl_init_electron(qmckl_context context);
   #+end_src

   #+begin_src c :comments org :tangle (eval c) :exports none
qmckl_exit_code qmckl_init_electron(qmckl_context context) {

  if (qmckl_context_check(context) == QMCKL_NULL_CONTEXT) {
    return false;
  }

  qmckl_context_struct* const ctx = (qmckl_context_struct*) context;
  assert (ctx != NULL);

  ctx->electron.uninitialized = (1 << 1) - 1;

  return QMCKL_SUCCESS;
}
   #+end_src


      #+begin_src c :comments org :tangle (eval h_func)
bool qmckl_electron_provided (const qmckl_context context);
      #+end_src

      #+begin_src c :comments org :tangle (eval c) :noweb yes :exports none
bool qmckl_electron_provided(const qmckl_context context) {

  if (qmckl_context_check(context) == QMCKL_NULL_CONTEXT) {
    return false;
  }

  qmckl_context_struct* const ctx = (qmckl_context_struct*) context;
  assert (ctx != NULL);

  return ctx->electron.provided;
}
      #+end_src

** Initialization functions

   To set the data relative to the electrons in the context, the
   following functions need to be called. When the data structure is
   initialized, the internal ~coord_new~ and ~coord_old~ arrays are
   both not allocated.

   #+begin_src c :comments org :tangle (eval h_func)
qmckl_exit_code qmckl_set_electron_num      (qmckl_context context, const int64_t up_num, const int64_t down_num);
qmckl_exit_code qmckl_set_electron_coord    (qmckl_context context, const char transp, const int64_t walk_num, const double* coord, const int64_t size_max);
   #+end_src

   #+NAME:pre2
   #+begin_src c :exports none
if (qmckl_context_check(context) == QMCKL_NULL_CONTEXT) {
  return QMCKL_NULL_CONTEXT;
 }

qmckl_context_struct* const ctx = (qmckl_context_struct*) context;

if (mask != 0 && !(ctx->electron.uninitialized & mask)) {
    return qmckl_failwith( context,
                           QMCKL_ALREADY_SET,
                           "qmckl_set_electron_*",
                           NULL);
}
   #+end_src

   #+NAME:post
   #+begin_src c :exports none
ctx->electron.uninitialized &= ~mask;
ctx->electron.provided = (ctx->electron.uninitialized == 0);

return QMCKL_SUCCESS;
   #+end_src

   To set the number of electrons, we give the number of up-spin and
   down-spin electrons to the context and we set the number of walkers.

   #+begin_src c :comments org :tangle (eval c) :noweb yes  :exports none
qmckl_exit_code
qmckl_set_electron_num(qmckl_context context,
                       const int64_t up_num,
                       const int64_t down_num) {
  int32_t mask = 1 << 0;

  <<pre2>>

  if (up_num <= 0) {
    return qmckl_failwith( context,
                           QMCKL_INVALID_ARG_2,
                           "qmckl_set_electron_num",
                           "up_num <= 0");
  }

  if (down_num < 0) {
    return qmckl_failwith( context,
                           QMCKL_INVALID_ARG_3,
                           "qmckl_set_electron_num",
                           "down_num < 0");
  }

  ctx->electron.up_num = up_num;
  ctx->electron.down_num = down_num;
  ctx->electron.num = up_num + down_num;

  <<post>>
}
   #+end_src


   #+begin_src f90 :comments org :tangle (eval fh_func) :noweb yes :exports none
interface
  integer(qmckl_exit_code) function qmckl_set_electron_num(context, alpha, beta) bind(C)
    use, intrinsic :: iso_c_binding
    import
    implicit none

    integer (c_int64_t) , intent(in)  , value :: context
    integer (c_int64_t) , intent(in)  , value :: alpha
    integer (c_int64_t) , intent(in)  , value :: beta
  end function
end interface
   #+end_src


    The following function sets the electron coordinates of all the
    walkers. When this is done, the pointers to the old and new sets
    of coordinates are swapped, and the new coordinates are
    overwritten. This can be done only when the data relative to
    electrons have been set.

    ~size_max~ should be equal equal or geater than ~elec_num *
    walker.num * 3~, to be symmetric with ~qmckl_get_electron_coord~.

    *Important*: changing the electron coordinates increments the date
    in the context.

   #+begin_src c :comments org :tangle (eval c) :noweb yes :exports none
qmckl_exit_code
qmckl_set_electron_coord(qmckl_context context,
                         const char transp,
                         const int64_t walk_num,
                         const double* coord,
                         const int64_t size_max)
{

  int32_t mask = 0;

  <<pre2>>

  if (transp != 'N' && transp != 'T') {
    return qmckl_failwith( context,
                           QMCKL_INVALID_ARG_2,
                           "qmckl_set_electron_coord",
                           "transp should be 'N' or 'T'");
  }

  if (walk_num <= 0) {
    return qmckl_failwith( context,
                           QMCKL_INVALID_ARG_3,
                           "qmckl_set_electron_coord",
                           "walk_num <= 0");
  }

  if (coord == NULL) {
    return qmckl_failwith( context,
                           QMCKL_INVALID_ARG_4,
                           "qmckl_set_electron_coord",
                           "coord is a null pointer");
  }

  const int64_t elec_num = ctx->electron.num;

  if (elec_num == 0L) {
    return qmckl_failwith( context,
                           QMCKL_FAILURE,
                           "qmckl_set_electron_coord",
                           "elec_num is not set");
  }

  /* Swap pointers */
  qmckl_walker tmp         = ctx->electron.walker_old;
  ctx->electron.walker_old = ctx->electron.walker;
  ctx->electron.walker     = tmp;

  memcpy(&(ctx->point), &(ctx->electron.walker.point), sizeof(qmckl_point_struct));

  qmckl_exit_code rc;
  rc = qmckl_set_point(context, transp, walk_num*elec_num, coord, size_max);
  if (rc != QMCKL_SUCCESS) return rc;

  ctx->electron.walker.num = walk_num;
  memcpy(&(ctx->electron.walker.point), &(ctx->point), sizeof(qmckl_point_struct));

  // If it is the first time we set the electrons, we set also walkers_old.
  if (ctx->electron.walker_old.num == 0) {
    qmckl_set_electron_coord(context, transp, walk_num, coord, size_max);
  }
  return QMCKL_SUCCESS;

}
   #+end_src

   #+begin_src f90 :comments org :tangle (eval fh_func) :noweb yes :exports none
interface
  integer(qmckl_exit_code) function qmckl_set_electron_coord(context, transp, walk_num, coord, size_max) bind(C)
    use, intrinsic :: iso_c_binding
    import
    implicit none

    integer (c_int64_t) , intent(in)  , value :: context
    character(c_char)   , intent(in)  , value :: transp
    integer (c_int64_t) , intent(in)  , value :: walk_num
    real(c_double)      , intent(in)          :: coord(*)
    integer (c_int64_t) , intent(in)  , value :: size_max
  end function
end interface
   #+end_src

** Access functions

   Access functions return ~QMCKL_SUCCESS~ when the data has been
   successfully retrieved. It returnes ~QMCKL_INVALID_CONTEXT~ when
   the context is not a valid context, and ~QMCKL_NOT_PROVIDED~ when
   the data has not been provided. If the function returns
   successfully, the variable pointed by the pointer given in argument
   contains the requested data. Otherwise, this variable is untouched.

*** Number of electrons

      #+begin_src c :comments org :tangle (eval h_func)
qmckl_exit_code qmckl_get_electron_num        (const qmckl_context context, int64_t* const num);
qmckl_exit_code qmckl_get_electron_up_num     (const qmckl_context context, int64_t* const up_num);
qmckl_exit_code qmckl_get_electron_down_num   (const qmckl_context context, int64_t* const down_num);
      #+end_src

      #+begin_src c :comments org :tangle (eval c) :noweb yes :exports none
qmckl_exit_code
qmckl_get_electron_num (const qmckl_context context, int64_t* const num) {

  if (qmckl_context_check(context) == QMCKL_NULL_CONTEXT) {
    return QMCKL_INVALID_CONTEXT;
  }

  if (num == NULL) {
    return qmckl_failwith( context,
                           QMCKL_INVALID_ARG_2,
                           "qmckl_get_electron_num",
                           "num is a null pointer");
  }

  qmckl_context_struct* const ctx = (qmckl_context_struct*) context;
  assert (ctx != NULL);

  int32_t mask = 1 << 0;

  if ( (ctx->electron.uninitialized & mask) != 0) {
    return QMCKL_NOT_PROVIDED;
  }

  assert (ctx->electron.num > (int64_t) 0);
  ,*num = ctx->electron.num;
  return QMCKL_SUCCESS;
}


qmckl_exit_code
qmckl_get_electron_up_num (const qmckl_context context, int64_t* const up_num) {
  if (qmckl_context_check(context) == QMCKL_NULL_CONTEXT) {
    return QMCKL_INVALID_CONTEXT;
  }

  if (up_num == NULL) {
    return qmckl_failwith( context,
                           QMCKL_INVALID_ARG_2,
                           "qmckl_get_electron_up_num",
                           "up_num is a null pointer");
  }

  qmckl_context_struct* const ctx = (qmckl_context_struct*) context;
  assert (ctx != NULL);

  int32_t mask = 1 << 0;

  if ( (ctx->electron.uninitialized & mask) != 0) {
    return QMCKL_NOT_PROVIDED;
  }

  assert (ctx->electron.up_num > (int64_t) 0);
  ,*up_num = ctx->electron.up_num;
  return QMCKL_SUCCESS;
}


qmckl_exit_code
qmckl_get_electron_down_num (const qmckl_context context, int64_t* const down_num) {
  if (qmckl_context_check(context) == QMCKL_NULL_CONTEXT) {
    return QMCKL_INVALID_CONTEXT;
  }

  if (down_num == NULL) {
    return qmckl_failwith( context,
                           QMCKL_INVALID_ARG_2,
                           "qmckl_get_electron_down_num",
                           "down_num is a null pointer");
  }

  qmckl_context_struct* const ctx = (qmckl_context_struct*) context;
  assert (ctx != NULL);

  int32_t mask = 1 << 0;

  if ( (ctx->electron.uninitialized & mask) != 0) {
    return QMCKL_NOT_PROVIDED;
  }

  assert (ctx->electron.down_num >= (int64_t) 0);
  ,*down_num = ctx->electron.down_num;
  return QMCKL_SUCCESS;
}

      #+end_src

*** Number of walkers

    A walker is a set of electron coordinates that are arguments of
    the wave function. ~walk_num~ is the number of walkers.

    #+begin_src c :comments org :tangle (eval h_func)
qmckl_exit_code qmckl_get_electron_walk_num   (const qmckl_context context, int64_t* const walk_num);
    #+end_src

    #+begin_src c :comments org :tangle (eval c) :noweb yes :exports none
qmckl_exit_code
qmckl_get_electron_walk_num (const qmckl_context context, int64_t* const walk_num) {
  if (qmckl_context_check(context) == QMCKL_NULL_CONTEXT) {
    return QMCKL_INVALID_CONTEXT;
  }

  if (walk_num == NULL) {
    return qmckl_failwith( context,
                           QMCKL_INVALID_ARG_2,
                           "qmckl_get_electron_walk_num",
                           "walk_num is a null pointer");
  }

  qmckl_context_struct* const ctx = (qmckl_context_struct*) context;
  assert (ctx != NULL);

  ,*walk_num = ctx->electron.walker.num;
  return QMCKL_SUCCESS;
}
    #+end_src


*** Electron coordinates

    Returns the current electron coordinates. The pointer is assumed
    to point on a memory block of size ~size_max~ \ge ~3 * elec_num * walker.num~.
    The order of the indices is:

    |         | Normal                     | Transposed                 |
    |---------+----------------------------+----------------------------|
    | C       | ~[walker.num*elec_num][3]~ | ~[3][walker.num*elec_num]~ |
    | Fortran | ~(3,walker.num*elec_num)~  | ~(walker.num*elec_num, 3)~ |


      #+begin_src c :comments org :tangle (eval h_func) 
qmckl_exit_code
qmckl_get_electron_coord (const qmckl_context context,
                          const char transp,
                          double* const coord,
                          const int64_t size_max);
      #+end_src

      As the ~walker~ attribute is equal to ~points~, returning the
      current electron coordinates is equivalent to returning the
      current points.

      #+begin_src c :comments org :tangle (eval c) :noweb yes :exports none
qmckl_exit_code
qmckl_get_electron_coord (const qmckl_context context,
                          const char transp,
                          double* const coord,
                          const int64_t size_max)
{
  if (transp != 'N' && transp != 'T') {
    return qmckl_failwith( context,
                           QMCKL_INVALID_ARG_2,
                           "qmckl_get_electron_coord",
                           "transp should be 'N' or 'T'");
  }

  if (coord == NULL) {
    return qmckl_failwith( context,
                           QMCKL_INVALID_ARG_3,
                           "qmckl_get_electron_coord",
                           "coord is a null pointer");
  }

  if (size_max <= 0) {
    return qmckl_failwith( context,
                           QMCKL_INVALID_ARG_4,
                           "qmckl_get_electron_coord",
                           "size_max should be > 0");
  }

  if (qmckl_context_check(context) == QMCKL_NULL_CONTEXT) {
    return QMCKL_INVALID_CONTEXT;
  }

  qmckl_context_struct* const ctx = (qmckl_context_struct*) context;
  assert (ctx != NULL);

  if (!ctx->electron.provided) {
    return qmckl_failwith( context,
                           QMCKL_NOT_PROVIDED,
                           "qmckl_get_electron_coord",
                           NULL);
  }

  assert (ctx->point.num  == ctx->electron.walker.point.num);
  assert (ctx->point.coord.data == ctx->electron.walker.point.coord.data);

  return qmckl_get_point(context, transp, coord, size_max);
}

      #+end_src

   #+begin_src f90 :comments org :tangle (eval fh_func) :noweb yes :exports none
interface
  integer(qmckl_exit_code) function qmckl_get_electron_coord(context, transp, coord, size_max) bind(C)
    use, intrinsic :: iso_c_binding
    import
    implicit none

    integer (c_int64_t) , intent(in)  , value :: context
    character(c_char)   , intent(in)  , value :: transp
    real(c_double)      , intent(in)          :: coord(*)
    integer (c_int64_t) , intent(in)  , value :: size_max
  end function
end interface
   #+end_src

** Deep copy

   #+begin_src c :comments org :tangle (eval h_private_func) :exports none
qmckl_exit_code qmckl_copy_electron(qmckl_context context, const qmckl_electron_struct* src, qmckl_electron_struct* dest);
   #+end_src

   Performs a deep copy of the electron structure from ~src~ to ~dest~.
   Memory allocations are done using the provided context.

   #+begin_src c :comments org :tangle (eval c)
qmckl_exit_code qmckl_copy_electron(qmckl_context context, const qmckl_electron_struct* src, qmckl_electron_struct* dest) {
  qmckl_exit_code rc;
  
  if (qmckl_context_check(context) == QMCKL_NULL_CONTEXT) {
    return QMCKL_INVALID_CONTEXT;
  }

  if (src == NULL || dest == NULL) {
    return qmckl_failwith(context,
                          QMCKL_INVALID_ARG_2,
                          "qmckl_copy_electron",
                          "NULL pointer");
  }

  /* Copy scalar fields */
  dest->num = src->num;
  dest->up_num = src->up_num;
  dest->down_num = src->down_num;
  dest->ee_distance_date = src->ee_distance_date;
  dest->en_distance_date = src->en_distance_date;
  dest->ee_potential_date = src->ee_potential_date;
  dest->en_potential_date = src->en_potential_date;
  dest->uninitialized = src->uninitialized;
  dest->provided = src->provided;

  /* Deep copy walker structures */
  dest->walker.num = src->walker.num;
  rc = qmckl_copy_point(context, &(src->walker.point), &(dest->walker.point));
  if (rc != QMCKL_SUCCESS) return rc;

  dest->walker_old.num = src->walker_old.num;
  rc = qmckl_copy_point(context, &(src->walker_old.point), &(dest->walker_old.point));
  if (rc != QMCKL_SUCCESS) return rc;

  /* Deep copy distance and potential arrays */
  /* Note: These are computed arrays and may not need copying in all cases */
  /* For now, we set them to NULL as they can be recomputed */
  /* Set dates to zero so they will be recomputed */
  dest->ee_distance = NULL;
  dest->ee_distance_date = 0;
  dest->en_distance = NULL;
  dest->en_distance_date = 0;
  dest->ee_potential = NULL;
  dest->ee_potential_date = 0;
  dest->en_potential = NULL;
  dest->en_potential_date = 0;

  return QMCKL_SUCCESS;
}
   #+end_src


** Test                                                            :noexport:

   #+begin_src python :results output :exports none
import numpy as np

   #+end_src

   #+begin_src c :tangle (eval c_test) :exports none
/* Reference input data */
int64_t walk_num      = chbrclf_walk_num;
int64_t elec_num      = chbrclf_elec_num;
int64_t elec_up_num   = chbrclf_elec_up_num;
int64_t elec_dn_num   = chbrclf_elec_dn_num;
int64_t nucl_num      = chbrclf_nucl_num;
double* charge        = chbrclf_charge;
double* nucl_coord    = &(chbrclf_nucl_coord[0][0]);

double* elec_coord    = &(chbrclf_elec_coord[0][0][0]);


/* --- */

qmckl_exit_code rc;

assert(!qmckl_electron_provided(context));

int64_t n;
rc = qmckl_get_electron_num (context, &n);
assert(rc == QMCKL_NOT_PROVIDED);

rc = qmckl_get_electron_up_num (context, &n);
assert(rc == QMCKL_NOT_PROVIDED);

rc = qmckl_get_electron_down_num (context, &n);
assert(rc == QMCKL_NOT_PROVIDED);


rc = qmckl_set_electron_num (context, elec_up_num, elec_dn_num);
qmckl_check(context, rc);
assert(qmckl_electron_provided(context));

rc = qmckl_get_electron_up_num (context, &n);
qmckl_check(context, rc);
assert(n == elec_up_num);

rc = qmckl_get_electron_down_num (context, &n);
qmckl_check(context, rc);
assert(n == elec_dn_num);

rc = qmckl_get_electron_num (context, &n);
qmckl_check(context, rc);
assert(n == elec_num);


int64_t w = 0;
rc = qmckl_get_electron_walk_num (context, &w);
qmckl_check(context, rc);
assert(w == 0);


assert(qmckl_electron_provided(context));

rc = qmckl_set_electron_coord (context, 'N', walk_num, elec_coord, walk_num*elec_num*3);
qmckl_check(context, rc);

rc = qmckl_get_electron_walk_num (context, &w);
qmckl_check(context, rc);
assert(w == walk_num);

double elec_coord2[walk_num*3*elec_num];

rc = qmckl_get_electron_coord (context, 'N', elec_coord2, walk_num*3*elec_num);
qmckl_check(context, rc);
for (int64_t i=0 ; i<3*elec_num*walk_num ; ++i) {
  printf("%f %f\n",  elec_coord[i],  elec_coord2[i]);
  assert( elec_coord[i] == elec_coord2[i] );
 }

    #+end_src

* Computation

  The computed data is stored in the context so that it can be reused
  by different kernels. To ensure that the data is valid, for each
  computed data the date of the context is stored when it is computed.
  To know if some data needs to be recomputed, we check if the date of
  the dependencies are more recent than the date of the data to
  compute. If it is the case, then the data is recomputed and the
  current date is stored.

** Electron-electron distances

*** Get

    #+begin_src c :comments org :tangle (eval h_func) :noweb yes
qmckl_exit_code
qmckl_get_electron_ee_distance(qmckl_context context,
                               double* const distance,
                               const int64_t size_max);
    #+end_src

    #+begin_src f90 :tangle (eval fh_func) :comments org :exports none
interface
  integer(qmckl_exit_code) function qmckl_get_electron_ee_distance(context, distance, size_max) &
    bind(C)
    use, intrinsic :: iso_c_binding
    import
    implicit none
    integer (c_int64_t) , intent(in)  , value :: context
    real    (c_double ) , intent(out)         :: distance(*)
    integer (c_int64_t) , intent(in)          :: size_max
  end function
end interface
    #+end_src


    #+begin_src c :comments org :tangle (eval c) :noweb yes  :exports none
qmckl_exit_code
qmckl_get_electron_ee_distance(qmckl_context context,
                               double* const distance,
                               const int64_t size_max)
{
  if (qmckl_context_check(context) == QMCKL_NULL_CONTEXT) {
    return QMCKL_NULL_CONTEXT;
  }

  qmckl_exit_code rc;

  rc = qmckl_provide_ee_distance(context);
  if (rc != QMCKL_SUCCESS) return rc;

  if (distance == NULL) {
    return qmckl_failwith( context,
                           QMCKL_INVALID_ARG_2,
                           "qmckl_get_electron_ee_distance",
                           "distance is a null pointer");
  }

  qmckl_context_struct* const ctx = (qmckl_context_struct*) context;
  assert (ctx != NULL);

  const int64_t sze = ctx->electron.num * ctx->electron.num * ctx->electron.walker.num;
  if (size_max < sze) {
    return qmckl_failwith( context,
                           QMCKL_INVALID_ARG_3,
                           "qmckl_get_electron_ee_distance",
                           "size_max < num*num*walk_num");
  }
  memcpy(distance, ctx->electron.ee_distance, sze * sizeof(double));

  return QMCKL_SUCCESS;
}
    #+end_src

*** Provide                                                        :noexport:

    #+begin_src c :comments org :tangle (eval h_private_func) :noweb yes :exports none
qmckl_exit_code qmckl_provide_ee_distance(qmckl_context context);
    #+end_src

    #+begin_src c :comments org :tangle (eval c) :noweb yes  :exports none
qmckl_exit_code qmckl_provide_ee_distance(qmckl_context context)
{

  if (qmckl_context_check(context) == QMCKL_NULL_CONTEXT) {
    return QMCKL_NULL_CONTEXT;
  }

  qmckl_context_struct* const ctx = (qmckl_context_struct*) context;
  assert (ctx != NULL);


  /* Compute if necessary */
  if (ctx->point.date > ctx->electron.ee_distance_date) {

    if (ctx->electron.walker.num > ctx->electron.walker_old.num) {
      free(ctx->electron.ee_distance);
      ctx->electron.ee_distance = NULL;
    }

    /* Allocate array */
    if (ctx->electron.ee_distance == NULL) {

      qmckl_memory_info_struct mem_info = qmckl_memory_info_struct_zero;
      mem_info.size = ctx->electron.num * ctx->electron.num *
        ctx->electron.walker.num * sizeof(double);
      double* ee_distance = (double*) qmckl_malloc(context, mem_info);

      if (ee_distance == NULL) {
        return qmckl_failwith( context,
                               QMCKL_ALLOCATION_FAILED,
                               "qmckl_ee_distance",
                               NULL);
      }
      ctx->electron.ee_distance = ee_distance;
    }

    qmckl_exit_code rc =
      qmckl_compute_ee_distance(context,
                                ctx->electron.num,
                                ctx->electron.walker.num,
                                ctx->electron.walker.point.coord.data,
                                ctx->electron.ee_distance);
    if (rc != QMCKL_SUCCESS) {
      return rc;
    }

    ctx->electron.ee_distance_date = ctx->date;
  }

  return QMCKL_SUCCESS;
}
    #+end_src

*** Compute
   :PROPERTIES:
   :Name:     qmckl_compute_ee_distance
   :CRetType: qmckl_exit_code
   :FRetType: qmckl_exit_code
   :END:

    #+NAME: qmckl_ee_distance_args
    | Variable      | Type                                   | In/Out | Description                 |
    |---------------+----------------------------------------+--------+-----------------------------|
    | ~context~     | ~qmckl_context~                        | in     | Global state                |
    | ~elec_num~    | ~int64_t~                              | in     | Number of electrons         |
    | ~walk_num~    | ~int64_t~                              | in     | Number of walkers           |
    | ~coord~       | ~double[3][walk_num][elec_num]~        | in     | Electron coordinates        |
    | ~ee_distance~ | ~double[walk_num][elec_num][elec_num]~ | out    | Electron-electron distances |

    #+begin_src f90 :comments org :tangle (eval f) :noweb yes
function qmckl_compute_ee_distance(context, elec_num, walk_num, coord, ee_distance) &
     result(info) bind(C)
  use qmckl_constants
  use qmckl, only : qmckl_distance
  implicit none
  integer (qmckl_context) , intent(in)  , value :: context
  integer (c_int64_t) , intent(in)  , value :: elec_num
  integer (c_int64_t) , intent(in)  , value :: walk_num
  real    (c_double ) , intent(in)          :: coord(elec_num,3,walk_num)
  real    (c_double ) , intent(out)         :: ee_distance(elec_num,elec_num,walk_num)
  integer (qmckl_exit_code) :: info

  integer*8 :: k, i, j
  double precision :: x, y, z

  info = QMCKL_SUCCESS

  if (context == QMCKL_NULL_CONTEXT) then
     info = QMCKL_INVALID_CONTEXT
     return
  endif

  if (elec_num <= 0) then
     info = QMCKL_INVALID_ARG_2
     return
  endif

  if (walk_num <= 0) then
     info = QMCKL_INVALID_ARG_3
     return
  endif

  do k=1,walk_num
     info = qmckl_distance(context, 'T', 'T', elec_num, elec_num, &
          coord(1,k,1), elec_num * walk_num, &
          coord(1,k,1), elec_num * walk_num, &
          ee_distance(1,1,k), elec_num)
     if (info /= QMCKL_SUCCESS) then
        exit
     endif
  end do

end function qmckl_compute_ee_distance
    #+end_src

    #+begin_src c :tangle (eval h_private_func) :comments org :exports none
qmckl_exit_code qmckl_compute_ee_distance (
          const qmckl_context context,
          const int64_t elec_num,
          const int64_t walk_num,
          const double* coord,
          double* const ee_distance );
    #+end_src


*** Test                                                           :noexport:

    #+begin_src python :results output :exports none
import numpy as np

elec_1_w1 = np.array( [ -2.26995253563, -5.15737533569, -2.22940072417 ])
elec_2_w1 = np.array( [  3.51983380318, -1.08717381954, -1.19617708027 ])
elec_1_w2 = np.array( [ -2.34410619736, -3.20016115904, -1.53496759012 ])
elec_2_w2 = np.array( [  3.17996025085, -1.40260577202,  1.49473607540 ])

print ( "[0][0][0] : ", np.linalg.norm(elec_1_w1-elec_1_w1) )
print ( "[0][1][0] : ", np.linalg.norm(elec_1_w1-elec_2_w1) )
print ( "[1][0][0] : ", np.linalg.norm(elec_2_w1-elec_1_w1) )
print ( "[0][0][1] : ", np.linalg.norm(elec_1_w2-elec_1_w2) )
print ( "[0][1][1] : ", np.linalg.norm(elec_1_w2-elec_2_w2) )
print ( "[1][0][1] : ", np.linalg.norm(elec_2_w2-elec_1_w2) )
    #+end_src

    #+RESULTS:
    : [0][0][0] :  0.0
    : [0][1][0] :  7.152322512964209
    : [1][0][0] :  7.152322512964209
    : [0][0][1] :  0.0
    : [0][1][1] :  6.5517646321055665
    : [1][0][1] :  6.5517646321055665

     #+begin_src c :tangle (eval c_test) :exports none
assert(qmckl_electron_provided(context));


double ee_distance[walk_num * elec_num * elec_num];
rc = qmckl_get_electron_ee_distance(context, ee_distance, walk_num * elec_num * elec_num);

// (e1,e2,w)
// (0,0,0) == 0.
assert(ee_distance[0] == 0.);

// (1,0,0) == (0,1,0)
assert(ee_distance[1] == ee_distance[elec_num]);

// value of (1,0,0)
assert(fabs(ee_distance[1]-7.152322512964209) < 1.e-12);

// (0,0,1) == 0.
assert(ee_distance[elec_num*elec_num] == 0.);

// (1,0,1) == (0,1,1)
assert(ee_distance[elec_num*elec_num+1] == ee_distance[elec_num*elec_num+elec_num]);

// value of (1,0,1)
assert(fabs(ee_distance[elec_num*elec_num+1]-6.5517646321055665) < 1.e-12);

     #+end_src

** Electron-electron potential

   ~ee_potential~ is given by

   \[
   \mathcal{V}_{ee} = \sum_{i=1}^{N_e}\sum_{j>i}^{N_e}\frac{1}{r_{ij}}
   \]

   where \(\mathcal{V}_{ee}\) is the ~ee~ potential and \[r_{ij}\] the ~ee~
   distance.

*** Get

    #+begin_src c :comments org :tangle (eval h_func) :noweb yes
qmckl_exit_code qmckl_get_electron_ee_potential(qmckl_context context, double* const ee_potential);
    #+end_src

    #+begin_src c :comments org :tangle (eval c) :noweb yes  :exports none
qmckl_exit_code qmckl_get_electron_ee_potential(qmckl_context context, double* const ee_potential)
{
  if (qmckl_context_check(context) == QMCKL_NULL_CONTEXT) {
    return QMCKL_NULL_CONTEXT;
  }

  qmckl_exit_code rc;

  rc = qmckl_provide_ee_potential(context);
  if (rc != QMCKL_SUCCESS) return rc;

  qmckl_context_struct* const ctx = (qmckl_context_struct*) context;
  assert (ctx != NULL);

  size_t sze = ctx->electron.walker.num * sizeof(double);
  memcpy(ee_potential, ctx->electron.ee_potential, sze);

  return QMCKL_SUCCESS;
}
    #+end_src

*** Provide                                                        :noexport:

    #+begin_src c :comments org :tangle (eval h_private_func) :noweb yes :exports none
qmckl_exit_code qmckl_provide_ee_potential(qmckl_context context);
    #+end_src

    #+begin_src c :comments org :tangle (eval c) :noweb yes  :exports none
qmckl_exit_code qmckl_provide_ee_potential(qmckl_context context)
{

  if (qmckl_context_check(context) == QMCKL_NULL_CONTEXT) {
    return QMCKL_NULL_CONTEXT;
  }

  qmckl_context_struct* const ctx = (qmckl_context_struct*) context;
  assert (ctx != NULL);

  if (!ctx->electron.provided) return QMCKL_NOT_PROVIDED;

  qmckl_exit_code rc = qmckl_provide_ee_distance(context);
  if (rc != QMCKL_SUCCESS) return rc;

  /* Compute if necessary */
  if (ctx->point.date > ctx->electron.ee_potential_date) {

    if (ctx->electron.walker.num > ctx->electron.walker_old.num) {
      free(ctx->electron.ee_potential);
    }

    /* Allocate array */
    if (ctx->electron.ee_potential == NULL) {

      qmckl_memory_info_struct mem_info = qmckl_memory_info_struct_zero;
      mem_info.size = ctx->electron.walker.num * sizeof(double);
      double* ee_potential = (double*) qmckl_malloc(context, mem_info);

      if (ee_potential == NULL) {
        return qmckl_failwith( context,
                               QMCKL_ALLOCATION_FAILED,
                               "qmckl_ee_potential",
                               NULL);
      }
      ctx->electron.ee_potential = ee_potential;
    }

    rc = qmckl_compute_ee_potential(context,
                                ctx->electron.num,
                                ctx->electron.walker.num,
                                ctx->electron.ee_distance,
                                ctx->electron.ee_potential);
    if (rc != QMCKL_SUCCESS) {
      return rc;
    }

    ctx->electron.ee_potential_date = ctx->date;
  }

  return QMCKL_SUCCESS;
}
    #+end_src

*** Compute
   :PROPERTIES:
   :Name:     qmckl_compute_ee_potential
   :CRetType: qmckl_exit_code
   :FRetType: qmckl_exit_code
   :END:

    #+NAME: qmckl_ee_potential_args
    | Variable       | Type                                   | In/Out | Description                 |
    |----------------+----------------------------------------+--------+-----------------------------|
    | ~context~      | ~qmckl_context~                        | in     | Global state                |
    | ~elec_num~     | ~int64_t~                              | in     | Number of electrons         |
    | ~walk_num~     | ~int64_t~                              | in     | Number of walkers           |
    | ~ee_distance~  | ~double[walk_num][elec_num][elec_num]~ | in     | Electron-electron distances |
    | ~ee_potential~ | ~double[walk_num]~                     | out    | Electron-electron potential |

    #+begin_src f90 :comments org :tangle (eval f) :noweb yes
function qmckl_compute_ee_potential(context, elec_num, walk_num, &
     ee_distance, ee_potential) result(info) bind(C)
  use qmckl_constants
  implicit none
  integer(qmckl_context), intent(in), value :: context
  integer (c_int64_t) , intent(in)  , value :: elec_num
  integer (c_int64_t) , intent(in)  , value :: walk_num
  real    (c_double ) , intent(in)          :: ee_distance(elec_num,elec_num,walk_num)
  real    (c_double ) , intent(out)         :: ee_potential(walk_num)
  integer (qmckl_exit_code) :: info

  integer*8 :: nw, i, j

  info = QMCKL_SUCCESS

  if (context == QMCKL_NULL_CONTEXT) then
     info = QMCKL_INVALID_CONTEXT
     return
  endif

  if (elec_num <= 0) then
     info = QMCKL_INVALID_ARG_2
     return
  endif

  if (walk_num <= 0) then
     info = QMCKL_INVALID_ARG_3
     return
  endif

  ee_potential = 0.0d0
  do nw=1,walk_num
    do j=2,elec_num
      do i=1,j-1
        if (dabs(ee_distance(i,j,nw)) > 1e-5) then
          ee_potential(nw) = ee_potential(nw) + 1.0d0/(ee_distance(i,j,nw))
        endif
      end do
    end do
  end do
  
end function qmckl_compute_ee_potential
    #+end_src

    #+CALL: generate_c_header(table=qmckl_ee_potential_args,rettyp=get_value("CRetType"),fname=get_value("Name"))

    #+RESULTS:
    #+begin_src c :tangle (eval h_private_func) :comments org :exports none
qmckl_exit_code qmckl_compute_ee_potential (const qmckl_context context,
                                            const int64_t elec_num,
                                            const int64_t walk_num,
                                            const double* ee_distance,
                                            double* const ee_potential );
    #+end_src

    #+CALL: generate_c_interface(table=qmckl_ee_potential_args,rettyp=get_value("CRetType"),fname=get_value("Name"))

*** Test                                                           :noexport:
     #+begin_src c :tangle (eval c_test) :exports none
double ee_potential[walk_num];

rc = qmckl_get_electron_ee_potential(context, &(ee_potential[0]));
qmckl_check(context, rc);
     #+end_src
** Electron-nucleus distances

*** Get

    #+begin_src c :comments org :tangle (eval h_func) :noweb yes
qmckl_exit_code
qmckl_get_electron_en_distance(qmckl_context context,
                               double* const distance,
                               const int64_t size_max);
    #+end_src

    #+begin_src f90 :tangle (eval fh_func) :comments org :exports none
interface
  integer(c_int32_t) function qmckl_get_electron_en_distance(context, distance, size_max) &
    bind(C)
    use, intrinsic :: iso_c_binding
    import
    implicit none
    integer (c_int64_t) , intent(in)  , value :: context
    real    (c_double ) , intent(out)         :: distance(*)
    integer (c_int64_t) , intent(in)          :: size_max
  end function
end interface
    #+end_src

    #+begin_src c :comments org :tangle (eval c) :noweb yes  :exports none
qmckl_exit_code
qmckl_get_electron_en_distance(qmckl_context context,
                               double* const distance,
                               const int64_t size_max)
{

  if (qmckl_context_check(context) == QMCKL_NULL_CONTEXT) {
    return QMCKL_NULL_CONTEXT;
  }

  qmckl_exit_code rc;

  rc = qmckl_provide_en_distance(context);
  if (rc != QMCKL_SUCCESS) return rc;

  qmckl_context_struct* const ctx = (qmckl_context_struct*) context;
  assert (ctx != NULL);

  if (distance == NULL) {
    return qmckl_failwith( context,
                           QMCKL_INVALID_ARG_2,
                           "qmckl_get_electron_en_distance",
                           "distance is a null pointer");
  }

  int64_t sze = ctx->point.num * ctx->nucleus.num;
  if (size_max < sze) {
    return qmckl_failwith( context,
                           QMCKL_INVALID_ARG_3,
                           "qmckl_get_electron_en_distance",
                           "size_max < num*nucl_num");
  }
  memcpy(distance, ctx->electron.en_distance, sze * sizeof(double));

  return QMCKL_SUCCESS;
}
    #+end_src

*** Provide                                                        :noexport:

    #+begin_src c :comments org :tangle (eval h_private_func) :noweb yes :exports none
qmckl_exit_code qmckl_provide_en_distance(qmckl_context context);
    #+end_src

    #+begin_src c :comments org :tangle (eval c) :noweb yes  :exports none
qmckl_exit_code qmckl_provide_en_distance(qmckl_context context)
{

  if (qmckl_context_check(context) == QMCKL_NULL_CONTEXT) {
    return QMCKL_NULL_CONTEXT;
  }

  qmckl_context_struct* const ctx = (qmckl_context_struct*) context;
  assert (ctx != NULL);

  if (!(ctx->nucleus.provided)) {
    return qmckl_failwith( context,
                           QMCKL_NOT_PROVIDED,
                           "qmckl_provide_en_distance",
                           NULL);
  }

  /* Compute if necessary */
  if (ctx->point.date > ctx->electron.en_distance_date) {

    qmckl_memory_info_struct mem_info = qmckl_memory_info_struct_zero;
    mem_info.size = ctx->point.num * ctx->nucleus.num * sizeof(double);

    if (ctx->electron.en_distance != NULL) {
      qmckl_memory_info_struct mem_info_test = qmckl_memory_info_struct_zero;
      qmckl_exit_code rc = qmckl_get_malloc_info(context, ctx->electron.en_distance, &mem_info_test);

      /* if rc != QMCKL_SUCCESS, we are maybe in an _inplace function because the
         memory was not allocated with qmckl_malloc */

      if ((rc == QMCKL_SUCCESS) && (mem_info_test.size != mem_info.size)) {
        rc = qmckl_free(context, ctx->electron.en_distance);
        assert (rc == QMCKL_SUCCESS);
        ctx->electron.en_distance = NULL;
      }
    }

    /* Allocate array */
    if (ctx->electron.en_distance == NULL) {

      double* en_distance = (double*) qmckl_malloc(context, mem_info);

      if (en_distance == NULL) {
        return qmckl_failwith( context,
                               QMCKL_ALLOCATION_FAILED,
                               "qmckl_en_distance",
                               NULL);
      }
      ctx->electron.en_distance = en_distance;
    }

    qmckl_exit_code rc =
      qmckl_compute_en_distance(context,
                                ctx->point.num,
                                ctx->nucleus.num,
                                ctx->point.coord.data,
                                ctx->nucleus.coord.data,
                                ctx->electron.en_distance);
    if (rc != QMCKL_SUCCESS) {
      return rc;
    }

    ctx->electron.en_distance_date = ctx->date;
  }

  return QMCKL_SUCCESS;
}
    #+end_src

*** Compute
   :PROPERTIES:
   :Name:     qmckl_compute_en_distance
   :CRetType: qmckl_exit_code
   :FRetType: qmckl_exit_code
   :END:

    #+NAME: qmckl_en_distance_args
    | Variable      | Type                          | In/Out | Description                |
    |---------------+-------------------------------+--------+----------------------------|
    | ~context~     | ~qmckl_context~               | in     | Global state               |
    | ~point_num~   | ~int64_t~                     | in     | Number of points           |
    | ~nucl_num~    | ~int64_t~                     | in     | Number of nuclei           |
    | ~elec_coord~  | ~double[3][point_num]~        | in     | Electron coordinates       |
    | ~nucl_coord~  | ~double[3][nucl_num]~         | in     | Nuclear coordinates        |
    | ~en_distance~ | ~double[point_num][nucl_num]~ | out    | Electron-nucleus distances |

    #+begin_src f90 :comments org :tangle (eval f) :noweb yes
function qmckl_compute_en_distance(context, &
     point_num, nucl_num, elec_coord, nucl_coord, en_distance) &
     result(info) bind(C)
  use qmckl_constants
  use qmckl, only : qmckl_distance
  implicit none
  integer (qmckl_context), intent(in), value :: context
  integer (c_int64_t)    , intent(in), value :: point_num
  integer (c_int64_t)    , intent(in), value :: nucl_num
  real    (c_double )    , intent(in)        :: elec_coord(point_num,3)
  real    (c_double )    , intent(in)        :: nucl_coord(nucl_num,3)
  real    (c_double )    , intent(out)       :: en_distance(nucl_num,point_num)
  integer(qmckl_exit_code) :: info
  
  info = QMCKL_SUCCESS

  if (context == QMCKL_NULL_CONTEXT) then
     info = QMCKL_INVALID_CONTEXT
     return
  endif

  if (point_num <= 0) then
     info = QMCKL_INVALID_ARG_2
     return
  endif

  if (nucl_num <= 0) then
     info = QMCKL_INVALID_ARG_3
     return
  endif

  info = qmckl_distance(context, 'T', 'T', nucl_num, point_num, &
          nucl_coord, nucl_num, &
          elec_coord, point_num, &
          en_distance, nucl_num)

end function qmckl_compute_en_distance
    #+end_src

    #+begin_src c :tangle (eval h_private_func) :comments org :exports none
qmckl_exit_code qmckl_compute_en_distance (
          const qmckl_context context,
          const int64_t point_num,
          const int64_t nucl_num,
          const double* elec_coord,
          const double* nucl_coord,
          double* const en_distance );
    #+end_src


*** Test                                                           :noexport:

    #+begin_src python :results output :exports none
import numpy as np

elec_1_w1 = np.array( [ -2.26995253563, -5.15737533569, -2.22940072417 ])
elec_2_w1 = np.array( [  3.51983380318, -1.08717381954, -1.19617708027 ])
elec_1_w2 = np.array( [ -2.34410619736, -3.20016115904, -1.53496759012 ])
elec_2_w2 = np.array( [  3.17996025085, -1.40260577202,  1.49473607540 ])
nucl_1    = np.array( [ 1.096243353458458e+00, 8.907054016973815e-01, 7.777092280258892e-01 ] )
nucl_2    = np.array( [ 1.168459237342663e+00, 1.125660720053393e+00, 2.833370314829343e+00 ] )

print ( "[0][0][0] : ", np.linalg.norm(elec_1_w1-nucl_1) )
print ( "[0][1][0] : ", np.linalg.norm(elec_1_w1-nucl_2) )
print ( "[0][0][1] : ", np.linalg.norm(elec_2_w1-nucl_1) )
print ( "[1][0][0] : ", np.linalg.norm(elec_1_w2-nucl_1) )
print ( "[1][1][0] : ", np.linalg.norm(elec_1_w2-nucl_2) )
print ( "[1][0][1] : ", np.linalg.norm(elec_2_w2-nucl_1) )
    #+end_src

    #+RESULTS:
    : [0][0][0] :  7.546738741619978
    : [0][1][0] :  8.77102435246984
    : [0][0][1] :  3.698922010513608
    : [1][0][0] :  5.824059436060509
    : [1][1][0] :  7.080482110317645
    : [1][0][1] :  3.1804527583077356

     #+begin_src c :tangle (eval c_test) :exports none

assert(!qmckl_nucleus_provided(context));
assert(qmckl_electron_provided(context));

rc = qmckl_set_nucleus_num (context, nucl_num);
qmckl_check(context, rc);

rc = qmckl_set_nucleus_charge (context, charge, nucl_num);
qmckl_check(context, rc);

rc = qmckl_set_nucleus_coord (context, 'T', nucl_coord, 3*nucl_num);
qmckl_check(context, rc);

assert(qmckl_nucleus_provided(context));

double en_distance[walk_num][elec_num][nucl_num];

rc = qmckl_get_electron_en_distance(context, &(en_distance[0][0][0]), walk_num * elec_num * nucl_num);
qmckl_check(context, rc);

// (e,n,w) in Fortran notation
// (1,1,1)
assert(fabs(en_distance[0][0][0] - 7.546738741619978) < 1.e-12);

// (1,2,1)
assert(fabs(en_distance[0][0][1] - 8.77102435246984) < 1.e-12);

// (2,1,1)
assert(fabs(en_distance[0][1][0] - 3.698922010513608) < 1.e-12);

// (1,1,2)
assert(fabs(en_distance[1][0][0] - 5.824059436060509) < 1.e-12);

// (1,2,2)
assert(fabs(en_distance[1][0][1] - 7.080482110317645) < 1.e-12);

// (2,1,2)
assert(fabs(en_distance[1][1][0] - 3.1804527583077356) < 1.e-12);

     #+end_src

** Electron-nucleus potential
   ~en_potential~ stores the ~en~ potential energy

   \[
   \mathcal{V}_{en} = -\sum_{i=1}^{N_e}\sum_{A=1}^{N_n}\frac{Z_A}{r_{iA}}
   \]

   where \(\mathcal{V}_{en}\) is the ~en~ potential, \[r_{iA}\] the ~en~
   distance and \[Z_A\] is the nuclear charge.

*** Get

    #+begin_src c :comments org :tangle (eval h_func) :noweb yes
qmckl_exit_code qmckl_get_electron_en_potential(qmckl_context context, double* const en_potential);
    #+end_src

    #+begin_src c :comments org :tangle (eval c) :noweb yes  :exports none
qmckl_exit_code qmckl_get_electron_en_potential(qmckl_context context, double* const en_potential)
{
  if (qmckl_context_check(context) == QMCKL_NULL_CONTEXT) {
    return QMCKL_NULL_CONTEXT;
  }

  qmckl_exit_code rc;

  rc = qmckl_provide_en_potential(context);
  if (rc != QMCKL_SUCCESS) return rc;

  qmckl_context_struct* const ctx = (qmckl_context_struct*) context;
  assert (ctx != NULL);

  size_t sze = ctx->electron.walker.num * sizeof(double);
  memcpy(en_potential, ctx->electron.en_potential, sze);

  return QMCKL_SUCCESS;
}
    #+end_src

*** Provide                                                        :noexport:

    #+begin_src c :comments org :tangle (eval h_private_func) :noweb yes :exports none
qmckl_exit_code qmckl_provide_en_potential(qmckl_context context);
    #+end_src

    #+begin_src c :comments org :tangle (eval c) :noweb yes  :exports none
qmckl_exit_code qmckl_provide_en_potential(qmckl_context context)
{

  if (qmckl_context_check(context) == QMCKL_NULL_CONTEXT) {
    return QMCKL_NULL_CONTEXT;
  }

  qmckl_context_struct* const ctx = (qmckl_context_struct*) context;
  assert (ctx != NULL);

  if (!ctx->electron.provided) return QMCKL_NOT_PROVIDED;
  if (!ctx->nucleus.provided) return QMCKL_NOT_PROVIDED;

  qmckl_exit_code rc = qmckl_provide_en_distance(context);
  if (rc != QMCKL_SUCCESS) return rc;

  /* Compute if necessary */
  if (ctx->point.date > ctx->electron.en_potential_date) {

    if (ctx->electron.walker.num > ctx->electron.walker_old.num) {
      free(ctx->electron.en_potential);
      ctx->electron.en_potential = NULL;
    }

    /* Allocate array */
    if (ctx->electron.en_potential == NULL) {

      qmckl_memory_info_struct mem_info = qmckl_memory_info_struct_zero;
      mem_info.size = ctx->electron.walker.num * sizeof(double);
      double* en_potential = (double*) qmckl_malloc(context, mem_info);

      if (en_potential == NULL) {
        return qmckl_failwith( context,
                               QMCKL_ALLOCATION_FAILED,
                               "qmckl_en_potential",
                               NULL);
      }
      ctx->electron.en_potential = en_potential;
    }

    rc = qmckl_compute_en_potential(context,
                                ctx->electron.num,
                                ctx->nucleus.num,
                                ctx->electron.walker.num,
                                ctx->nucleus.charge.data,
                                ctx->electron.en_distance,
                                ctx->electron.en_potential);
    if (rc != QMCKL_SUCCESS) {
      return rc;
    }

    ctx->electron.en_potential_date = ctx->date;
  }

  return QMCKL_SUCCESS;
}
    #+end_src

*** Compute
   :PROPERTIES:
   :Name:     qmckl_compute_en_potential
   :CRetType: qmckl_exit_code
   :FRetType: qmckl_exit_code
   :END:

    #+NAME: qmckl_en_potential_args
    | Variable       | Type                                   | In/Out | Description                          |
    |----------------+----------------------------------------+--------+--------------------------------------|
    | ~context~      | ~qmckl_context~                        | in     | Global state                         |
    | ~elec_num~     | ~int64_t~                              | in     | Number of electrons                  |
    | ~nucl_num~     | ~int64_t~                              | in     | Number of nuclei                     |
    | ~walk_num~     | ~int64_t~                              | in     | Number of walkers                    |
    | ~charge~       | ~double[nucl_num]~                     | in     | charge of nucleus                    |
    | ~en_distance~  | ~double[walk_num][elec_num][nucl_num]~ | in     | Electron-electron distances          |
    | ~en_potential~ | ~double[walk_num]~                     | out    | Electron-electron potential          |

    #+begin_src f90 :comments org :tangle (eval f) :noweb yes
function qmckl_compute_en_potential(context, elec_num, nucl_num, walk_num, &
     charge, en_distance, en_potential) &
     result(info) bind(C)
  use qmckl
  implicit none
  integer (qmckl_context), intent(in), value :: context
  integer (c_int64_t) , intent(in)   , value :: elec_num
  integer (c_int64_t) , intent(in)   , value :: nucl_num
  integer (c_int64_t) , intent(in)   , value :: walk_num
  real    (c_double ) , intent(in)           :: charge(nucl_num)
  real    (c_double ) , intent(in)           :: en_distance(nucl_num,elec_num,walk_num)
  real    (c_double ) , intent(out)          :: en_potential(walk_num)

  integer(qmckl_exit_code) :: info
  integer*8 :: nw, i, j

  info = QMCKL_SUCCESS

  if (context == QMCKL_NULL_CONTEXT) then
     info = QMCKL_INVALID_CONTEXT
     return
  endif

  if (elec_num <= 0) then
     info = QMCKL_INVALID_ARG_2
     return
  endif

  if (walk_num <= 0) then
     info = QMCKL_INVALID_ARG_3
     return
  endif

  en_potential = 0.0d0
  do nw=1,walk_num
    do i=1,elec_num
      do j=1,nucl_num
        if (dabs(en_distance(j,i,nw)) > 1.d-6) then
          en_potential(nw) = en_potential(nw) - charge(j)/(en_distance(j,i,nw))
        endif
      end do
    end do
  end do

end function qmckl_compute_en_potential
    #+end_src

    #+CALL: generate_c_header(table=qmckl_en_potential_args,rettyp=get_value("CRetType"),fname=get_value("Name"))

    #+RESULTS:
    #+begin_src c :tangle (eval h_func) :comments org
    qmckl_exit_code qmckl_compute_en_potential (
	  const qmckl_context context,
	  const int64_t elec_num,
	  const int64_t nucl_num,
	  const int64_t walk_num,
	  const double* charge,
	  const double* en_distance,
	  double* const en_potential );
    #+end_src

*** Test                                                           :noexport:
     #+begin_src c :tangle (eval c_test) :exports none
double en_potential[walk_num];

rc = qmckl_get_electron_en_potential(context, &(en_potential[0]));
qmckl_check(context, rc);
     #+end_src

** TODO Generate initial coordinates

*** Compute                                                        :noexport:

   # begin_src f90 :comments org :tangle (eval f) :noweb yes
subroutine draw_init_points
  implicit none
  BEGIN_DOC
! Place randomly electrons around nuclei
  END_DOC
  integer                        :: iwalk
  logical, allocatable           :: do_elec(:)
  integer                        :: acc_num

  real, allocatable              :: xmin(:,:)

  integer                        :: i, j, k, l, kk

  real                           :: norm
  allocate (do_elec(elec_num), xmin(3,elec_num))
  xmin = -huge(1.)
  norm = 0.
  do i=1,elec_alpha_num
    do j=1,ao_num
      norm += mo_coef_transp(i,j)*mo_coef_transp(i,j)
    enddo
  enddo
  norm = sqrt(norm/float(elec_alpha_num))
  call rinfo( irp_here, 'Norm : ', norm )
  call rinfo( irp_here, 'mo_scale: ' , mo_scale )
  mo_coef_transp = mo_coef_transp/norm

  double precision               :: qmc_ranf
  real                           :: mo_max
  do i=1,elec_alpha_num
    l=1
    xmin(1,i) = mo_coef_transp(i,1)*mo_coef_transp(i,1) - 0.001*qmc_ranf()
    do j=2,ao_num
      xmin(2,i) = mo_coef_transp(i,j)*mo_coef_transp(i,j) - 0.001*qmc_ranf()
      if (xmin(2,i) > xmin(1,i)  ) then
        xmin(1,i) = xmin(2,i)
        l = ao_nucl(j)
      endif
    enddo
    xmin(1,i) = nucl_coord(l,1)
    xmin(2,i) = nucl_coord(l,2)
    xmin(3,i) = nucl_coord(l,3)
  enddo

  call iinfo(irp_here, 'Det num = ', det_num )
  do k=1,elec_beta_num
    i = k+elec_alpha_num
    l=1
    xmin(1,i) = mo_coef_transp(k,1)*mo_coef_transp(k,1) - 0.001*qmc_ranf()
    do j=2,ao_num
      xmin(2,i) = mo_coef_transp(k,j)*mo_coef_transp(k,j) - 0.001*qmc_ranf()
      if (xmin(2,i) > xmin(1,i) ) then
        xmin(1,i) = xmin(2,i)
        l = ao_nucl(j)
      endif
    enddo
    xmin(1,i) = nucl_coord(l,1)
    xmin(2,i) = nucl_coord(l,2)
    xmin(3,i) = nucl_coord(l,3)
  enddo

  call rinfo( irp_here, 'time step =', time_step )
  do iwalk=1,walk_num
    print *, 'Generating initial positions for walker', iwalk
    acc_num = 0
    do_elec = .True.
    integer :: iter
    do iter = 1,10000
      if (acc_num >= elec_num) then
        exit
      endif
      double precision               :: gauss
      real                           :: re_compute
      re_compute = 0.
      do while (re_compute < 1.e-6)
        do i=1,elec_num
          if (do_elec(i)) then
            do l=1,3
              elec_coord(i,l) = xmin(l,i) + 1.5*(0.5-qmc_ranf())
            enddo
          endif
        enddo
        TOUCH elec_coord
        re_compute = minval(nucl_elec_dist(1:nucl_num,1:elec_num))
      enddo

      do i=1,elec_alpha_num
        if (do_elec(i)) then
          if ( mo_value_transp(i,i)**2 >= qmc_ranf()) then
            acc_num += 1
            do_elec(i) = .False.
          endif
        endif
      enddo

      do i=1,elec_beta_num
        if (do_elec(i+elec_alpha_num)) then
          if ( mo_value_transp(i,i+elec_alpha_num)**2 >= qmc_ranf()) then
            acc_num += 1
            do_elec(i+elec_alpha_num) = .False.
          endif
        endif
      enddo

    enddo

    do l=1,3
      do i=1,elec_num+1
        elec_coord_full(i,l,iwalk) = elec_coord(i,l)
      enddo
    enddo
  enddo
  if (.not.is_worker) then
    call ezfio_set_electrons_elec_coord_pool_size(walk_num)
    call ezfio_set_electrons_elec_coord_pool(elec_coord_full)
  endif
  SOFT_TOUCH elec_coord elec_coord_full
  deallocate (do_elec, xmin)

end
    # end_src

* End of files                                                     :noexport:

  #+begin_src c :tangle (eval h_private_type) :exports none
#endif
  #+end_src

  #+begin_src c :tangle (eval h_private_func) :exports none
#endif
  #+end_src

*** Test
  #+begin_src c :tangle (eval c_test) :exports none
  if (qmckl_context_destroy(context) != QMCKL_SUCCESS)
    return QMCKL_FAILURE;
  return 0;
}
  #+end_src

*** Compute file names
    #+begin_src emacs-lisp
; The following is required to compute the file names

(setq pwd (file-name-directory buffer-file-name))
(setq name (file-name-nondirectory (substring buffer-file-name 0 -4)))
(setq f  (concat pwd name "_f.f90"))
(setq fh (concat pwd name "_fh.f90"))
(setq c  (concat pwd name ".c"))
(setq h  (concat name ".h"))
(setq h_private  (concat name "_private.h"))
(setq c_test  (concat pwd "test_" name ".c"))
(setq f_test  (concat pwd "test_" name "_f.f90"))

; Minted
(require 'ox-latex)
(setq org-latex-listings 'minted)
(add-to-list 'org-latex-packages-alist '("" "listings"))
(add-to-list 'org-latex-packages-alist '("" "color"))

    #+end_src

    #+RESULTS:
    |   | color    |
    |   | listings |


# -*- mode: org -*-
# vim: syntax=c


