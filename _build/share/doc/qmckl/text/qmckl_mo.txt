                          ____________________

                           MOLECULAR ORBITALS

                                TREX CoE
                          ____________________


Table of Contents
_________________

1. Context
.. 1. Data structure
.. 2. Initialization functions
.. 3. Deep copy
.. 4. Cusp adjsutment functions
.. 5. Access functions
..... 1. Fortran interfaces
.. 6. Update
..... 1. Fortran interface
2. Computation
.. 1. Parameters of the cusp-correction functions
.. 2. Computation of MOs: values only
..... 1. Get
..... 2. Provide
..... 3. Compute
.. 3. Computation of MOs: values, gradient, Laplacian
..... 1. Get
..... 2. Provide
..... 3. Compute
.. 4. Computation of cusp-corrected MOs: values only
..... 1. Compute
.. 5. Computation of cusp-corrected MOs: values, gradient, Laplacian
..... 1. Compute
.. 6. Rescaling of MO coefficients
..... 1. Fortran interface
.. 7. Test





1 Context
=========

  The following arrays are stored in the context:

  -----------------------------------------------------------------------------------
   `mo_num'                             Number of MOs                                
   `coefficient'    `[mo_num][ao_num]'  MO coefficients                              
   `coefficient_t'  `[ao_num][mo_num]'  Transposed of the Orbital coefficients       
   `r_cusp'         `[nucl_num]'        Radius of the functions for Cusp adjustments 
  -----------------------------------------------------------------------------------

  Computed data:

  ---------------------------------------------------------------------------------------------------
   `cusp_param'  `[nucl_num][4][mo_num]'   Parameters of the functions for Cusp adjustments          
   `mo_value'    `[point_num][mo_num]'     Value of the MOs at point positions                       
   `mo_vgl'      `[point_num][5][mo_num]'  Value, gradients, Laplacian of the MOs at point positions 
  ---------------------------------------------------------------------------------------------------


1.1 Data structure
~~~~~~~~~~~~~~~~~~

  The `uninitialized' integer contains one bit set to one for each
  initialization function which has not been called. It becomes equal to
  zero after all initialization functions have been called. The struct
  is then initialized and `provided == true'.  Some values are
  initialized by default, and are not concerned by this mechanism.


1.2 Initialization functions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  To set the basis set, all the following functions need to be called.

  ,----
  | qmckl_exit_code  qmckl_set_mo_basis_mo_num           (qmckl_context context, const int64_t   mo_num);
  | qmckl_exit_code  qmckl_set_mo_basis_coefficient      (qmckl_context context, const double  * coefficient, const int64_t size_max);
  | qmckl_exit_code  qmckl_set_mo_basis_r_cusp           (qmckl_context context, const double  * r_cusp, const int64_t size_max);
  `----

  When the basis set is completely entered, other data structures are
  computed to accelerate the calculations.


1.3 Deep copy
~~~~~~~~~~~~~

  Performs a deep copy of the MO basis structure from `src' to `dest'.
  Memory allocations are done using the provided context.

  ,----
  | qmckl_exit_code qmckl_copy_mo_basis(qmckl_context context, const qmckl_mo_basis_struct* src, qmckl_mo_basis_struct* dest) {
  | 
  |   if (qmckl_context_check(context) == QMCKL_NULL_CONTEXT) {
  |     return QMCKL_INVALID_CONTEXT;
  |   }
  | 
  |   if (src == NULL || dest == NULL) {
  |     return qmckl_failwith(context,
  |                           QMCKL_INVALID_ARG_2,
  |                           "qmckl_copy_mo_basis",
  |                           "NULL pointer");
  |   }
  | 
  |   /* If source is not provided/initialized, just copy the struct */
  |   if (!src->provided) {
  |     *dest = *src;
  |     return QMCKL_SUCCESS;
  |   }
  | 
  |   /* Copy scalar fields */
  |   dest->mo_num = src->mo_num;
  |   dest->mo_vgl_date = src->mo_vgl_date;
  |   dest->mo_value_date = src->mo_value_date;
  |   dest->uninitialized = src->uninitialized;
  |   dest->provided = src->provided;
  | 
  |   /* Get ao_num from the context for array size calculations */
  |   qmckl_context_struct* const ctx = (qmckl_context_struct*) context;
  |   int64_t ao_num = ctx->ao_basis.ao_num;
  |   int64_t mo_num = src->mo_num;
  | 
  |   /* Deep copy coefficient array */
  |   if (src->coefficient != NULL && ao_num > 0 && mo_num > 0) {
  |     qmckl_memory_info_struct mem_info = qmckl_memory_info_struct_zero;
  |     mem_info.size = ao_num * mo_num * sizeof(double);
  |     dest->coefficient = (double*) qmckl_malloc(context, mem_info);
  |     if (dest->coefficient == NULL) return QMCKL_ALLOCATION_FAILED;
  |     memcpy(dest->coefficient, src->coefficient, mem_info.size);
  |   } else {
  |     dest->coefficient = NULL;
  |   }
  | 
  |   /* Deep copy coefficient_t array */
  |   if (src->coefficient_t != NULL && ao_num > 0 && mo_num > 0) {
  |     qmckl_memory_info_struct mem_info = qmckl_memory_info_struct_zero;
  |     mem_info.size = ao_num * mo_num * sizeof(double);
  |     dest->coefficient_t = (double*) qmckl_malloc(context, mem_info);
  |     if (dest->coefficient_t == NULL) return QMCKL_ALLOCATION_FAILED;
  |     memcpy(dest->coefficient_t, src->coefficient_t, mem_info.size);
  |   } else {
  |     dest->coefficient_t = NULL;
  |   }
  | 
  |   /* Deep copy r_cusp array */
  |   if (src->r_cusp != NULL && ctx->nucleus.num > 0) {
  |     qmckl_memory_info_struct mem_info = qmckl_memory_info_struct_zero;
  |     mem_info.size = ctx->nucleus.num * sizeof(double);
  |     dest->r_cusp = (double*) qmckl_malloc(context, mem_info);
  |     if (dest->r_cusp == NULL) return QMCKL_ALLOCATION_FAILED;
  |     memcpy(dest->r_cusp, src->r_cusp, mem_info.size);
  |   } else {
  |     dest->r_cusp = NULL;
  |   }
  | 
  |   /* Deep copy mo_vgl array - this is a computed array, set to NULL to recompute */
  |   dest->mo_vgl = NULL;
  |   dest->mo_vgl_date = 0;
  | 
  |   /* Deep copy mo_value array - this is a computed array, set to NULL to recompute */
  |   dest->mo_value = NULL;
  |   dest->mo_value_date = 0;
  | 
  |   /* Deep copy cusp_param tensor */
  |   if (src->cusp_param.data != NULL && src->cusp_param.size[0] > 0) {
  |     dest->cusp_param = qmckl_tensor_alloc(context, src->cusp_param.order, src->cusp_param.size);
  |     if (dest->cusp_param.data == NULL) return QMCKL_ALLOCATION_FAILED;
  | 
  |     /* Calculate total size of tensor data */
  |     int64_t tensor_size = 1;
  |     for (int32_t i = 0; i < src->cusp_param.order; ++i) {
  |       tensor_size *= src->cusp_param.size[i];
  |     }
  |     memcpy(dest->cusp_param.data, src->cusp_param.data, tensor_size * sizeof(double));
  |   } else {
  |     memset(&(dest->cusp_param), 0, sizeof(qmckl_tensor));
  |   }
  | 
  |   return QMCKL_SUCCESS;
  | }
  `----


1.4 Cusp adjsutment functions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  To activate the cusp adjustment, the user must enter the radius of the
  fitting function for each atom.

  This function requires the computation of the value and gradients of
  the $s$ AOs at the distance equal to the radius, and the values of the
  non-$s$ AOs at the center.


1.5 Access functions
~~~~~~~~~~~~~~~~~~~~

  When all the data for the AOs have been provided, the following
  function returns `true'.

  ,----
  | bool qmckl_mo_basis_provided (const qmckl_context context);
  `----


1.5.1 Fortran interfaces
------------------------


1.6 Update
~~~~~~~~~~

  It may be desirable to remove certain molecular orbitals (MOs) that do
  not significantly contribute to the wave function.  In particular, in
  a single determinant calculation, the virtual MOs can be removed as
  they do not participate in the ground state configuration.

  To select a subset of MOs that will be kept, an array of integers of
  size `mo_num' can be created. If the integer corresponding to an MO is
  zero, that MO is dropped and will not be included in the
  calculation. If the integer is non-zero, the MO will be kept.


  ,----
  | qmckl_exit_code
  | qmckl_mo_basis_select_mo (const qmckl_context context,
  |                           const int32_t* keep,
  |                           const int64_t size_max);
  `----


1.6.1 Fortran interface
-----------------------


2 Computation
=============

2.1 Parameters of the cusp-correction functions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


2.2 Computation of MOs: values only
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

2.2.1 Get
---------

  ,----
  | qmckl_exit_code
  | qmckl_get_mo_basis_mo_value(qmckl_context context,
  |                             double* const mo_value,
  |                             const int64_t size_max);
  `----

  Uses the given array to compute the values.

  ,----
  | qmckl_exit_code
  | qmckl_get_mo_basis_mo_value_inplace (qmckl_context context,
  |                                      double* const mo_value,
  |                                      const int64_t size_max);
  `----


2.2.2 Provide
-------------

  ,----
  | qmckl_exit_code qmckl_provide_mo_basis_mo_value(qmckl_context context);
  `----

  ,----
  | qmckl_exit_code qmckl_provide_mo_basis_mo_value(qmckl_context context)
  | {
  | 
  |   qmckl_exit_code rc = QMCKL_SUCCESS;
  | 
  |   if (qmckl_context_check(context) == QMCKL_NULL_CONTEXT) {
  |     return qmckl_failwith( context,
  |                            QMCKL_INVALID_CONTEXT,
  |                            "qmckl_provide_mo_basis_mo_value",
  |                            NULL);
  |   }
  | 
  |   qmckl_context_struct* const ctx = (qmckl_context_struct*) context;
  |   assert (ctx != NULL);
  | 
  |   if (!ctx->mo_basis.provided) {
  |     return qmckl_failwith( context,
  |                            QMCKL_NOT_PROVIDED,
  |                            "qmckl_provide_mo_basis_mo_value",
  |                            NULL);
  |   }
  | 
  |   /* Compute if necessary */
  |   if (ctx->point.date > ctx->mo_basis.mo_value_date) {
  | 
  |     qmckl_memory_info_struct mem_info = qmckl_memory_info_struct_zero;
  |     mem_info.size = ctx->mo_basis.mo_num * ctx->point.num * sizeof(double);
  | 
  |     if (ctx->mo_basis.mo_value != NULL) {
  |       qmckl_memory_info_struct mem_info_test = qmckl_memory_info_struct_zero;
  |       rc = qmckl_get_malloc_info(context, ctx->mo_basis.mo_value, &mem_info_test);
  | 
  |       /* if rc != QMCKL_SUCCESS, we are maybe in an _inplace function because the
  |          memory was not allocated with qmckl_malloc */
  | 
  |       if ((rc == QMCKL_SUCCESS) && (mem_info_test.size != mem_info.size)) {
  |         rc = qmckl_free(context, ctx->mo_basis.mo_value);
  |         assert (rc == QMCKL_SUCCESS);
  |         ctx->mo_basis.mo_value = NULL;
  |       }
  |     }
  | 
  |     /* Allocate array */
  |     if (ctx->mo_basis.mo_value == NULL) {
  | 
  |       double* mo_value = (double*) qmckl_malloc(context, mem_info);
  | 
  |       if (mo_value == NULL) {
  |         return qmckl_failwith( context,
  |                                QMCKL_ALLOCATION_FAILED,
  |                                "qmckl_mo_basis_mo_value",
  |                                NULL);
  |       }
  |       ctx->mo_basis.mo_value = mo_value;
  |     }
  | 
  `----


  ,----
  |     if (rc != QMCKL_SUCCESS) {
  |       return rc;
  |     }
  | 
  |     ctx->mo_basis.mo_value_date = ctx->date;
  |   }
  | 
  |   return QMCKL_SUCCESS;
  | }
  `----


2.2.3 Compute
-------------

   Variable         Type                         In/Out  Description                                     
  -------------------------------------------------------------------------------------------------------
   `context'        `qmckl_context'              in      Global state                                    
   `ao_num'         `int64_t'                    in      Number of AOs                                   
   `mo_num'         `int64_t'                    in      Number of MOs                                   
   `point_num'      `int64_t'                    in      Number of points                                
   `coefficient_t'  `double[mo_num][ao_num]'     in      Transpose of the AO to MO transformation matrix 
   `ao_value'       `double[point_num][ao_num]'  in      Value of the AOs                                
   `mo_value'       `double[point_num][mo_num]'  out     Value of the MOs                                


  The matrix of AO values is very sparse, so we use a sparse-dense
  matrix multiplication instead of a dgemm, as exposed in
  <https://dx.doi.org/10.1007/978-3-642-38718-0_14>.



  ,----
  | integer function qmckl_compute_mo_basis_mo_value_doc_f(context, &
  |      ao_num, mo_num, point_num, &
  |      coefficient_t, ao_value, mo_value) &
  |      result(info)
  |   use qmckl
  |   implicit none
  |   integer(qmckl_context), intent(in)  :: context
  |   integer*8             , intent(in)  :: ao_num, mo_num
  |   integer*8             , intent(in)  :: point_num
  |   double precision      , intent(in)  :: ao_value(ao_num,point_num)
  |   double precision      , intent(in)  :: coefficient_t(mo_num,ao_num)
  |   double precision      , intent(out) :: mo_value(mo_num,point_num)
  |   integer*8 :: j,k
  | 
  |   info = QMCKL_SUCCESS
  | 
  |   do j=1,point_num
  |      mo_value(:,j) = 0.d0
  |      do k=1,ao_num
  |         if (ao_value(k,j) == 0.d0) cycle
  |         mo_value(:,j) = mo_value(:,j) + coefficient_t(:,k) * ao_value(k,j)
  |      end do
  |   end do
  | 
  | end function qmckl_compute_mo_basis_mo_value_doc_f
  `----


2.3 Computation of MOs: values, gradient, Laplacian
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

2.3.1 Get
---------

  ,----
  | qmckl_exit_code
  | qmckl_get_mo_basis_mo_vgl(qmckl_context context,
  |                           double* const mo_vgl,
  |                           const int64_t size_max);
  `----

  Uses the given array to compute the VGL.

  ,----
  | qmckl_exit_code
  | qmckl_get_mo_basis_mo_vgl_inplace (qmckl_context context,
  |                                    double* const mo_vgl,
  |                                    const int64_t size_max);
  `----


2.3.2 Provide
-------------

  ,----
  | qmckl_exit_code qmckl_provide_mo_basis_mo_vgl(qmckl_context context);
  `----

  ,----
  | qmckl_exit_code qmckl_provide_mo_basis_mo_vgl(qmckl_context context)
  | {
  | 
  |   qmckl_exit_code rc = QMCKL_SUCCESS;
  | 
  |   if (qmckl_context_check(context) == QMCKL_NULL_CONTEXT) {
  |     return qmckl_failwith( context,
  |                            QMCKL_INVALID_CONTEXT,
  |                            "qmckl_provide_mo_basis_mo_vgl",
  |                            NULL);
  |   }
  | 
  |   qmckl_context_struct* const ctx = (qmckl_context_struct*) context;
  |   assert (ctx != NULL);
  | 
  |   if (!ctx->mo_basis.provided) {
  |     return qmckl_failwith( context,
  |                            QMCKL_NOT_PROVIDED,
  |                            "qmckl_provide_mo_basis_mo_vgl",
  |                            NULL);
  |   }
  | 
  |   /* Compute if necessary */
  |   if (ctx->point.date > ctx->mo_basis.mo_vgl_date) {
  | 
  |     qmckl_memory_info_struct mem_info = qmckl_memory_info_struct_zero;
  |     mem_info.size = 5 * ctx->mo_basis.mo_num * ctx->point.num * sizeof(double);
  | 
  |     if (ctx->mo_basis.mo_vgl != NULL) {
  |       qmckl_memory_info_struct mem_info_test = qmckl_memory_info_struct_zero;
  |       rc = qmckl_get_malloc_info(context, ctx->mo_basis.mo_vgl, &mem_info_test);
  | 
  |       /* if rc != QMCKL_SUCCESS, we are maybe in an _inplace function because the
  |          memory was not allocated with qmckl_malloc */
  | 
  |       if ((rc == QMCKL_SUCCESS) && (mem_info_test.size != mem_info.size)) {
  |         rc = qmckl_free(context, ctx->mo_basis.mo_vgl);
  |         assert (rc == QMCKL_SUCCESS);
  |         ctx->mo_basis.mo_vgl = NULL;
  |       }
  |     }
  | 
  |     /* Allocate array */
  |     if (ctx->mo_basis.mo_vgl == NULL) {
  | 
  |       double* mo_vgl = (double*) qmckl_malloc(context, mem_info);
  | 
  |       if (mo_vgl == NULL) {
  |         return qmckl_failwith( context,
  |                                QMCKL_ALLOCATION_FAILED,
  |                                "qmckl_mo_basis_mo_vgl",
  |                                NULL);
  |       }
  |       ctx->mo_basis.mo_vgl = mo_vgl;
  |     }
  | 
  `----

  ,----
  |     if (rc != QMCKL_SUCCESS) {
  |       return rc;
  |     }
  | 
  |     ctx->mo_basis.mo_vgl_date = ctx->date;
  |   }
  | 
  |   return QMCKL_SUCCESS;
  | }
  `----


2.3.3 Compute
-------------

   Variable         Type                            In/Out  Description                                     
  ----------------------------------------------------------------------------------------------------------
   `context'        `qmckl_context'                 in      Global state                                    
   `ao_num'         `int64_t'                       in      Number of AOs                                   
   `mo_num'         `int64_t'                       in      Number of MOs                                   
   `point_num'      `int64_t'                       in      Number of points                                
   `coefficient_t'  `double[mo_num][ao_num]'        in      Transpose of the AO to MO transformation matrix 
   `ao_vgl'         `double[point_num][5][ao_num]'  in      Value, gradients and Laplacian of the AOs       
   `mo_vgl'         `double[point_num][5][mo_num]'  out     Value, gradients and Laplacian of the MOs       


  The matrix of AO values is very sparse, so we use a sparse-dense
  matrix multiplication instead of a dgemm, as exposed in
  <https://dx.doi.org/10.1007/978-3-642-38718-0_14>.



  ,----
  | integer function qmckl_compute_mo_basis_mo_vgl_doc_f(context, &
  |      ao_num, mo_num, point_num, &
  |      coefficient_t, ao_vgl, mo_vgl) &
  |      result(info)
  |   use qmckl
  |   implicit none
  |   integer(qmckl_context), intent(in)  :: context
  |   integer*8             , intent(in)  :: ao_num, mo_num
  |   integer*8             , intent(in)  :: point_num
  |   double precision      , intent(in)  :: ao_vgl(ao_num,5,point_num)
  |   double precision      , intent(in)  :: coefficient_t(mo_num,ao_num)
  |   double precision      , intent(out) :: mo_vgl(mo_num,5,point_num)
  |   integer*8 :: i,j,k
  |   double precision :: c1, c2, c3, c4, c5
  | 
  |   info = QMCKL_SUCCESS
  | 
  |   do j=1,point_num
  |      mo_vgl(:,:,j) = 0.d0
  |      do k=1,ao_num
  |         if (ao_vgl(k,1,j) /= 0.d0) then
  |            c1 = ao_vgl(k,1,j)
  |            c2 = ao_vgl(k,2,j)
  |            c3 = ao_vgl(k,3,j)
  |            c4 = ao_vgl(k,4,j)
  |            c5 = ao_vgl(k,5,j)
  |            do i=1,mo_num
  |               mo_vgl(i,1,j) = mo_vgl(i,1,j) + coefficient_t(i,k) * c1
  |               mo_vgl(i,2,j) = mo_vgl(i,2,j) + coefficient_t(i,k) * c2
  |               mo_vgl(i,3,j) = mo_vgl(i,3,j) + coefficient_t(i,k) * c3
  |               mo_vgl(i,4,j) = mo_vgl(i,4,j) + coefficient_t(i,k) * c4
  |               mo_vgl(i,5,j) = mo_vgl(i,5,j) + coefficient_t(i,k) * c5
  |            end do
  |         end if
  |      end do
  |   end do
  | 
  | end function qmckl_compute_mo_basis_mo_vgl_doc_f
  `----


2.4 Computation of cusp-corrected MOs: values only
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

2.4.1 Compute
-------------

   Variable         Type                           In/Out  Description                                     
  ---------------------------------------------------------------------------------------------------------
   `context'        `qmckl_context'                in      Global state                                    
   `nucl_num'       `int64_t'                      in      Number of nuclei                                
   `ao_num'         `int64_t'                      in      Number of AOs                                   
   `mo_num'         `int64_t'                      in      Number of MOs                                   
   `point_num'      `int64_t'                      in      Number of points                                
   `ao_nucl'        `int64_t[ao_num]'              in      Nucleus on which the AO is centered             
   `ao_ang_mom'     `int32_t[ao_num]'              in      Angular momentum of the shell                   
   `en_distance'    `double[point_num][nucl_num]'  in      Electron-nucleus distances                      
   `r_cusp'         `double[nucl_num]'             in      Cusp-adjustment radius                          
   `cusp_param'     `double[nucl_num][4][mo_num]'  in      Cusp-adjustment parameters                      
   `coefficient_t'  `double[mo_num][ao_num]'       in      Transpose of the AO to MO transformation matrix 
   `ao_value'       `double[point_num][ao_num]'    in      Value of the AOs                                
   `mo_value'       `double[point_num][mo_num]'    out     Cusp correction for the values of the MOs       




  ,----
  | integer function qmckl_compute_mo_basis_mo_value_cusp_doc_f(context, &
  |      nucl_num, ao_num, mo_num, point_num, ao_nucl, ao_ang_mom, en_distance, &
  |      r_cusp, cusp_param, coefficient_t, ao_value, mo_value) &
  |      result(info)
  |   use qmckl
  |   implicit none
  |   integer(qmckl_context), intent(in)  :: context
  |   integer*8             , intent(in)  :: nucl_num, ao_num, mo_num, point_num
  |   integer*8             , intent(in)  :: ao_nucl(ao_num)
  |   integer*4             , intent(in)  :: ao_ang_mom(ao_num)
  |   double precision      , intent(in)  :: en_distance(nucl_num, point_num)
  |   double precision      , intent(in)  :: r_cusp(nucl_num)
  |   double precision      , intent(in)  :: cusp_param(mo_num, 4, nucl_num)
  |   double precision      , intent(in)  :: coefficient_t(mo_num, ao_num)
  |   double precision      , intent(in)  :: ao_value(ao_num, point_num)
  |   double precision      , intent(out) :: mo_value(mo_num, point_num)
  | 
  |   integer*8 :: i, j, k, inucl
  |   double precision :: r
  | 
  |   info = QMCKL_SUCCESS
  | 
  |   do i=1,point_num
  |      mo_value(:,i) = 0.d0
  |      do k=1,ao_num
  |         if (ao_value(k,i) == 0.d0) cycle
  |         inucl = ao_nucl(k)+1
  |         if ( (en_distance(inucl,i) < r_cusp(inucl)) .and. (ao_ang_mom(k) == 0) ) cycle
  |         mo_value(:,i) = mo_value(:,i) + coefficient_t(:,k) * ao_value(k,i)
  |      end do ! k
  | 
  |      do inucl=1,nucl_num
  |         r = en_distance(inucl,i)
  |         if (r > r_cusp(inucl)) cycle
  | 
  |         do j=1,mo_num
  |            mo_value(j,i) = mo_value(j,i) + &
  |                 cusp_param(j,1,inucl) + r*(cusp_param(j,2,inucl) + r*(  &
  |                 cusp_param(j,3,inucl) + r* cusp_param(j,4,inucl)     ))
  |         enddo
  |      enddo ! inucl
  |   enddo ! i
  | 
  | end function qmckl_compute_mo_basis_mo_value_cusp_doc_f
  `----


2.5 Computation of cusp-corrected MOs: values, gradient, Laplacian
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

2.5.1 Compute
-------------

   Variable         Type                            In/Out  Description                                     
  ----------------------------------------------------------------------------------------------------------
   `context'        `qmckl_context'                 in      Global state                                    
   `nucl_num'       `int64_t'                       in      Number of nuclei                                
   `ao_num'         `int64_t'                       in      Number of AOs                                   
   `mo_num'         `int64_t'                       in      Number of MOs                                   
   `point_num'      `int64_t'                       in      Number of points                                
   `ao_nucl'        `int64_t[ao_num]'               in      Nucleus on which the AO is centered             
   `ao_ang_mom'     `int32_t[ao_num]'               in      Angular momentum of the shell                   
   `en_distance'    `double[point_num][nucl_num]'   in      Electron-nucleus distances                      
   `nucl_coord'     `double[3][nucl_num]'           in      Nuclear coordinates                             
   `point_coord'    `double[3][point_num]'          in      Electron coordinates                            
   `r_cusp'         `double[nucl_num]'              in      Cusp-adjustment radius                          
   `cusp_param'     `double[nucl_num][4][mo_num]'   in      Cusp-adjustment parameters                      
   `coefficient_t'  `double[mo_num][ao_num]'        in      Transpose of the AO to MO transformation matrix 
   `ao_vgl'         `double[point_num][5][ao_num]'  in      Value, gradients and Laplacian of the AOs       
   `mo_vgl'         `double[point_num][5][mo_num]'  out     Value, gradients and Laplacian of the MOs       



  ,----
  | integer function qmckl_compute_mo_basis_mo_vgl_cusp_doc_f(context, &
  |      nucl_num, ao_num, mo_num, point_num, ao_nucl, ao_ang_mom, en_distance, &
  |      nucl_coord, point_coord, r_cusp, cusp_param, coefficient_t, ao_vgl, mo_vgl) &
  |      result(info)
  |   use qmckl
  |   implicit none
  |   integer(qmckl_context), intent(in)  :: context
  |   integer*8             , intent(in)  :: nucl_num, ao_num, mo_num, point_num
  |   integer*8             , intent(in)  :: ao_nucl(ao_num)
  |   integer*4             , intent(in)  :: ao_ang_mom(ao_num)
  |   double precision      , intent(in)  :: en_distance(nucl_num, point_num)
  |   double precision      , intent(in)  :: nucl_coord(nucl_num,3)
  |   double precision      , intent(in)  :: point_coord(point_num,3)
  |   double precision      , intent(in)  :: r_cusp(nucl_num)
  |   double precision      , intent(in)  :: cusp_param(mo_num,4,nucl_num)
  |   double precision      , intent(in)  :: coefficient_t(mo_num,ao_num)
  |   double precision      , intent(in)  :: ao_vgl(ao_num,5,point_num)
  |   double precision      , intent(out) :: mo_vgl(mo_num,5,point_num)
  |   integer*8 :: i,j,k, inucl
  |   double precision :: c1, c2, c3, c4, c5
  |   double precision :: r, r_inv, r_vec(3)
  | 
  |   do j=1,point_num
  | 
  |      ! Initial contribution of the MO
  |      mo_vgl(:,:,j) = 0.d0
  |      do k=1,ao_num
  |         if (ao_vgl(k,1,j) /= 0.d0) then
  |           inucl = ao_nucl(k)+1
  |           if ( (en_distance(inucl,j) > r_cusp(inucl)) .or. (ao_ang_mom(k) > 0) ) then
  |              c1 = ao_vgl(k,1,j)
  |              c2 = ao_vgl(k,2,j)
  |              c3 = ao_vgl(k,3,j)
  |              c4 = ao_vgl(k,4,j)
  |              c5 = ao_vgl(k,5,j)
  |              do i=1,mo_num
  |                 mo_vgl(i,1,j) = mo_vgl(i,1,j) + coefficient_t(i,k) * c1
  |                 mo_vgl(i,2,j) = mo_vgl(i,2,j) + coefficient_t(i,k) * c2
  |                 mo_vgl(i,3,j) = mo_vgl(i,3,j) + coefficient_t(i,k) * c3
  |                 mo_vgl(i,4,j) = mo_vgl(i,4,j) + coefficient_t(i,k) * c4
  |                 mo_vgl(i,5,j) = mo_vgl(i,5,j) + coefficient_t(i,k) * c5
  |              end do
  |           end if
  |        end if
  |      end do
  | 
  |     ! Cusp adjustment
  |     do inucl=1,nucl_num
  |        r = en_distance(inucl,j)
  |        if (r < r_cusp(inucl)) then
  | 
  |           r_vec(1:3) = point_coord(j,1:3) - nucl_coord(inucl,1:3)
  |           r_inv = 1.d0/r
  | 
  |           do i=1,mo_num
  |              mo_vgl(i,1,j) = mo_vgl(i,1,j) +  &
  |                   cusp_param(i,1,inucl) + r*( &
  |                   cusp_param(i,2,inucl) + r*( &
  |                   cusp_param(i,3,inucl) + r*( &
  |                   cusp_param(i,4,inucl)    )))
  | 
  |              c1 = r_inv * cusp_param(i,2,inucl) + 2.d0*cusp_param(i,3,inucl) +  &
  |                   r * 3.d0 * cusp_param(i,4,inucl)
  | 
  |              mo_vgl(i,2,j) = mo_vgl(i,2,j) + r_vec(1) * c1
  |              mo_vgl(i,3,j) = mo_vgl(i,3,j) + r_vec(2) * c1
  |              mo_vgl(i,4,j) = mo_vgl(i,4,j) + r_vec(3) * c1
  | 
  |              mo_vgl(i,5,j) = mo_vgl(i,5,j) +         &
  |                   2.d0*cusp_param(i,2,inucl)*r_inv + &
  |                   6.d0*cusp_param(i,3,inucl) +       &
  |                   12.d0*cusp_param(i,4,inucl)*r
  | 
  |           end do
  |        end if
  |     end do ! inucl
  |   end do
  |   info = QMCKL_SUCCESS
  | 
  | end function qmckl_compute_mo_basis_mo_vgl_cusp_doc_f
  `----


2.6 Rescaling of MO coefficients
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  When evaluating Slater determinants, the value of the determinants may
  get out of the range of double precision. A simple fix is to rescale
  the MO coefficients to put back the determinants in the correct range.

  ,----
  | qmckl_exit_code
  | qmckl_mo_basis_rescale(qmckl_context context,
  |                           const double scaling_factor);
  `----


2.6.1 Fortran interface
-----------------------


2.7 Test
~~~~~~~~
