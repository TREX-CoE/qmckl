<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-02-11 Fri 15:00 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>BLAS functions</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="TREX CoE" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" title="Standard" href="qmckl.css" type="text/css" />

<script type="text/javascript" src="org-info.js">
/**
 *
 * @source: org-info.js
 *
 * @licstart  The following is the entire license notice for the
 *  JavaScript code in org-info.js.
 *
 * Copyright (C) 2012-2019 Free Software Foundation, Inc.
 *
 *
 * The JavaScript code in this tag is free software: you can
 * redistribute it and/or modify it under the terms of the GNU
 * General Public License (GNU GPL) as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option)
 * any later version.  The code is distributed WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.
 *
 * As additional permission under GNU GPL version 3 section 7, you
 * may distribute non-source (e.g., minimized or compacted) forms of
 * that code without the copy of the GNU GPL normally required by
 * section 4, provided you include this license notice and a URL
 * through which recipients can access the Corresponding Source.
 *
 * @licend  The above is the entire license notice
 * for the JavaScript code in org-info.js.
 *
 */
</script>

<script type="text/javascript">

/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/

<!--/*--><![CDATA[/*><!--*/
org_html_manager.set("TOC_DEPTH", "4");
org_html_manager.set("LINK_HOME", "index.html");
org_html_manager.set("LINK_UP", "");
org_html_manager.set("LOCAL_TOC", "1");
org_html_manager.set("VIEW_BUTTONS", "0");
org_html_manager.set("MOUSE_HINT", "underline");
org_html_manager.set("FIXED_TOC", "0");
org_html_manager.set("TOC", "1");
org_html_manager.set("VIEW", "info");
org_html_manager.setup();  // activate after the parameters are set
/*]]>*///-->
</script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href=""> UP </a>
 |
 <a accesskey="H" href="index.html"> HOME </a>
</div><div id="content">
<h1 class="title">BLAS functions</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org561814a">1. Data types</a>
<ul>
<li><a href="#org86b4628">1.1. Vector</a></li>
<li><a href="#org6ab3689">1.2. Matrix</a></li>
<li><a href="#orgb4bb8b5">1.3. Tensor</a></li>
<li><a href="#orge8245cc">1.4. Reshaping</a>
<ul>
<li><a href="#orga022b1c">1.4.1. Vector -&gt; Matrix</a></li>
<li><a href="#orga8f445a">1.4.2. Vector -&gt; Tensor</a></li>
<li><a href="#org82027a9">1.4.3. Matrix -&gt; Vector</a></li>
<li><a href="#org5f92732">1.4.4. Matrix -&gt; Tensor</a></li>
<li><a href="#org02f19e5">1.4.5. Tensor -&gt; Vector</a></li>
<li><a href="#orgacdc60a">1.4.6. Tensor -&gt; Matrix</a></li>
</ul>
</li>
<li><a href="#org3886373">1.5. Access macros</a></li>
<li><a href="#orgdc75f7a">1.6. Copy to/from to <code>double*</code></a></li>
<li><a href="#orge357b0a">1.7. Tests</a></li>
</ul>
</li>
<li><a href="#orged24ee9">2. Matrix operations</a>
<ul>
<li><a href="#org3e1c790">2.1. <code>qmckl_dgemm</code></a></li>
<li><a href="#org22e8c11">2.2. <code>qmckl_matmul</code></a></li>
<li><a href="#org3bfeb4a">2.3. <code>qmckl_adjugate</code></a></li>
<li><a href="#org7983580">2.4. <code>qmckl_transpose</code></a>
<ul>
<li><a href="#org7b3ed34">2.4.1. Test</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org561814a" class="outline-2">
<h2 id="org561814a"><span class="section-number-2">1</span> Data types</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org86b4628" class="outline-3">
<h3 id="org86b4628"><span class="section-number-3">1.1</span> Vector</h3>
<div class="outline-text-3" id="text-1-1">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Variable</th>
<th scope="col" class="org-left">Type</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>size</code></td>
<td class="org-left"><code>int64_t</code></td>
<td class="org-left">Dimension of the vector</td>
</tr>

<tr>
<td class="org-left"><code>data</code></td>
<td class="org-left"><code>double*</code></td>
<td class="org-left">Elements</td>
</tr>
</tbody>
</table>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">qmckl_vector</span> {
  <span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">size</span>;
  <span style="color: #228b22;">double</span>* <span style="color: #a0522d;">data</span>;
} <span style="color: #228b22;">qmckl_vector</span>;
</pre>
</div>


<div class="org-src-container">
<pre class="src src-c"><span style="color: #228b22;">qmckl_vector</span>
<span style="color: #0000ff;">qmckl_vector_alloc</span>( <span style="color: #228b22;">qmckl_context</span> <span style="color: #a0522d;">context</span>, 
                    <span style="color: #a020f0;">const</span> <span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">size</span>);
</pre>
</div>

<p>
Allocates a new vector. If the allocation failed the size is zero.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #228b22;">qmckl_vector</span>
<span style="color: #0000ff;">qmckl_vector_alloc</span>( <span style="color: #228b22;">qmckl_context</span> <span style="color: #a0522d;">context</span>, 
                    <span style="color: #a020f0;">const</span> <span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">size</span>)
{
  /* <span style="color: #b22222;">Should always be true by contruction </span>*/
  assert (size &gt; (<span style="color: #228b22;">int64_t</span>) 0);

  <span style="color: #228b22;">qmckl_vector</span> <span style="color: #a0522d;">result</span>;
  result.size = size;

  <span style="color: #228b22;">qmckl_memory_info_struct</span> <span style="color: #a0522d;">mem_info</span> = qmckl_memory_info_struct_zero;
  mem_info.size = size * <span style="color: #a020f0;">sizeof</span>(<span style="color: #228b22;">double</span>);
  result.data = (<span style="color: #228b22;">double</span>*) qmckl_malloc (context, mem_info);

  <span style="color: #a020f0;">if</span> (result.data == <span style="color: #008b8b;">NULL</span>) {
    result.size = (<span style="color: #228b22;">int64_t</span>) 0;
  }

  <span style="color: #a020f0;">return</span> result;
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #228b22;">qmckl_exit_code</span>
<span style="color: #0000ff;">qmckl_vector_free</span>( <span style="color: #228b22;">qmckl_context</span> <span style="color: #a0522d;">context</span>, 
                   <span style="color: #228b22;">qmckl_vector</span> <span style="color: #a0522d;">vector</span>);
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #228b22;">qmckl_exit_code</span>
<span style="color: #0000ff;">qmckl_vector_free</span>( <span style="color: #228b22;">qmckl_context</span> <span style="color: #a0522d;">context</span>, 
                   <span style="color: #228b22;">qmckl_vector</span> <span style="color: #a0522d;">vector</span>)
{
  /* <span style="color: #b22222;">Always true </span>*/
  assert (vector.data != <span style="color: #008b8b;">NULL</span>);

  <span style="color: #228b22;">qmckl_exit_code</span> <span style="color: #a0522d;">rc</span>;

  rc = qmckl_free(context, vector.data);
  <span style="color: #a020f0;">if</span> (rc != QMCKL_SUCCESS) {
    <span style="color: #a020f0;">return</span> rc;
  }

  vector.size = (<span style="color: #228b22;">int64_t</span>) 0;
  vector.data = <span style="color: #008b8b;">NULL</span>;
  <span style="color: #a020f0;">return</span> QMCKL_SUCCESS;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org6ab3689" class="outline-3">
<h3 id="org6ab3689"><span class="section-number-3">1.2</span> Matrix</h3>
<div class="outline-text-3" id="text-1-2">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Variable</th>
<th scope="col" class="org-left">Type</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>size</code></td>
<td class="org-left"><code>int64_t[2]</code></td>
<td class="org-left">Dimension of each component</td>
</tr>

<tr>
<td class="org-left"><code>data</code></td>
<td class="org-left"><code>double*</code></td>
<td class="org-left">Elements</td>
</tr>
</tbody>
</table>

<p>
The dimensions use Fortran ordering: two elements differing by one
in the first dimension are consecutive in memory.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">qmckl_matrix</span> {
  <span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">size</span>[2];
  <span style="color: #228b22;">double</span>* <span style="color: #a0522d;">data</span>;
} <span style="color: #228b22;">qmckl_matrix</span>;
</pre>
</div>


<div class="org-src-container">
<pre class="src src-c"><span style="color: #228b22;">qmckl_matrix</span>
<span style="color: #0000ff;">qmckl_matrix_alloc</span>( <span style="color: #228b22;">qmckl_context</span> <span style="color: #a0522d;">context</span>, 
                    <span style="color: #a020f0;">const</span> <span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">size1</span>,
                    <span style="color: #a020f0;">const</span> <span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">size2</span>);
</pre>
</div>

<p>
Allocates a new matrix. If the allocation failed the sizes are zero.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #228b22;">qmckl_matrix</span>
<span style="color: #0000ff;">qmckl_matrix_alloc</span>( <span style="color: #228b22;">qmckl_context</span> <span style="color: #a0522d;">context</span>, 
                    <span style="color: #a020f0;">const</span> <span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">size1</span>,
                    <span style="color: #a020f0;">const</span> <span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">size2</span>)
{
  /* <span style="color: #b22222;">Should always be true by contruction </span>*/
  assert (size1 * size2 &gt; (<span style="color: #228b22;">int64_t</span>) 0);

  <span style="color: #228b22;">qmckl_matrix</span> <span style="color: #a0522d;">result</span>;

  result.size[0] = size1;
  result.size[1] = size2;

  <span style="color: #228b22;">qmckl_memory_info_struct</span> <span style="color: #a0522d;">mem_info</span> = qmckl_memory_info_struct_zero;
  mem_info.size = size1 * size2 * <span style="color: #a020f0;">sizeof</span>(<span style="color: #228b22;">double</span>);
  result.data = (<span style="color: #228b22;">double</span>*) qmckl_malloc (context, mem_info);

  <span style="color: #a020f0;">if</span> (result.data == <span style="color: #008b8b;">NULL</span>) {
    result.size[0] = (<span style="color: #228b22;">int64_t</span>) 0;
    result.size[1] = (<span style="color: #228b22;">int64_t</span>) 0;
  }

  <span style="color: #a020f0;">return</span> result;
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #228b22;">qmckl_exit_code</span>
<span style="color: #0000ff;">qmckl_matrix_free</span>( <span style="color: #228b22;">qmckl_context</span> <span style="color: #a0522d;">context</span>, 
                   <span style="color: #228b22;">qmckl_matrix</span> <span style="color: #a0522d;">matrix</span>);
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #228b22;">qmckl_exit_code</span>
<span style="color: #0000ff;">qmckl_matrix_free</span>( <span style="color: #228b22;">qmckl_context</span> <span style="color: #a0522d;">context</span>, 
                   <span style="color: #228b22;">qmckl_matrix</span> <span style="color: #a0522d;">matrix</span>)
{
  /* <span style="color: #b22222;">Always true </span>*/
  assert (matrix.data != <span style="color: #008b8b;">NULL</span>);

  <span style="color: #228b22;">qmckl_exit_code</span> <span style="color: #a0522d;">rc</span>;

  rc = qmckl_free(context, matrix.data);
  <span style="color: #a020f0;">if</span> (rc != QMCKL_SUCCESS) {
    <span style="color: #a020f0;">return</span> rc;
  }
  matrix.data = <span style="color: #008b8b;">NULL</span>;
  matrix.size[0] = (<span style="color: #228b22;">int64_t</span>) 0;
  matrix.size[1] = (<span style="color: #228b22;">int64_t</span>) 0;

  <span style="color: #a020f0;">return</span> QMCKL_SUCCESS;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb4bb8b5" class="outline-3">
<h3 id="orgb4bb8b5"><span class="section-number-3">1.3</span> Tensor</h3>
<div class="outline-text-3" id="text-1-3">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Variable</th>
<th scope="col" class="org-left">Type</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>order</code></td>
<td class="org-left"><code>int64_t</code></td>
<td class="org-left">Order of the tensor</td>
</tr>

<tr>
<td class="org-left"><code>size</code></td>
<td class="org-left"><code>int64_t[QMCKL_TENSOR_ORDER_MAX]</code></td>
<td class="org-left">Dimension of each component</td>
</tr>

<tr>
<td class="org-left"><code>data</code></td>
<td class="org-left"><code>double*</code></td>
<td class="org-left">Elements</td>
</tr>
</tbody>
</table>

<p>
The dimensions use Fortran ordering: two elements differing by one
in the first dimension are consecutive in memory.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">QMCKL_TENSOR_ORDER_MAX</span> 16

<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">qmckl_tensor</span> {
  <span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">order</span>;
  <span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">size</span>[QMCKL_TENSOR_ORDER_MAX];
  <span style="color: #228b22;">double</span>* <span style="color: #a0522d;">data</span>;
} <span style="color: #228b22;">qmckl_tensor</span>;
</pre>
</div>


<div class="org-src-container">
<pre class="src src-c"><span style="color: #228b22;">qmckl_tensor</span>
<span style="color: #0000ff;">qmckl_tensor_alloc</span>( <span style="color: #228b22;">qmckl_context</span> <span style="color: #a0522d;">context</span>, 
                    <span style="color: #a020f0;">const</span> <span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">order</span>,
                    <span style="color: #a020f0;">const</span> <span style="color: #228b22;">int64_t</span>* <span style="color: #a0522d;">size</span>);
</pre>
</div>

<p>
Allocates memory for a tensor. If the allocation failed, the size
is zero.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #228b22;">qmckl_tensor</span>
<span style="color: #0000ff;">qmckl_tensor_alloc</span>( <span style="color: #228b22;">qmckl_context</span> <span style="color: #a0522d;">context</span>, 
                    <span style="color: #a020f0;">const</span> <span style="color: #228b22;">int64_t</span>  <span style="color: #a0522d;">order</span>,
                    <span style="color: #a020f0;">const</span> <span style="color: #228b22;">int64_t</span>* <span style="color: #a0522d;">size</span>)
{
  /* <span style="color: #b22222;">Should always be true by contruction </span>*/
  assert (order &gt; 0);
  assert (order &lt;= QMCKL_TENSOR_ORDER_MAX);
  assert (size  != <span style="color: #008b8b;">NULL</span>);

  <span style="color: #228b22;">qmckl_tensor</span> <span style="color: #a0522d;">result</span>;
  result.order = order;

  <span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">prod_size</span> = (<span style="color: #228b22;">int64_t</span>) 1;
  <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">i</span>=0 ; i&lt;order ; ++i) {
    assert (size[i] &gt; (<span style="color: #228b22;">int64_t</span>) 0);
    result.size[i] = size[i];
    prod_size *= size[i];
  }

  <span style="color: #228b22;">qmckl_memory_info_struct</span> <span style="color: #a0522d;">mem_info</span> = qmckl_memory_info_struct_zero;
  mem_info.size = prod_size * <span style="color: #a020f0;">sizeof</span>(<span style="color: #228b22;">double</span>);

  result.data = (<span style="color: #228b22;">double</span>*) qmckl_malloc (context, mem_info);

  <span style="color: #a020f0;">if</span> (result.data == <span style="color: #008b8b;">NULL</span>) {
    memset(&amp;result, 0, <span style="color: #a020f0;">sizeof</span>(qmckl_tensor));
  }

  <span style="color: #a020f0;">return</span> result;
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #228b22;">qmckl_exit_code</span>
<span style="color: #0000ff;">qmckl_tensor_free</span>( <span style="color: #228b22;">qmckl_context</span> <span style="color: #a0522d;">context</span>, 
                   <span style="color: #228b22;">qmckl_tensor</span> <span style="color: #a0522d;">tensor</span>);
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #228b22;">qmckl_exit_code</span>
<span style="color: #0000ff;">qmckl_tensor_free</span>( <span style="color: #228b22;">qmckl_context</span> <span style="color: #a0522d;">context</span>, 
                   <span style="color: #228b22;">qmckl_tensor</span> <span style="color: #a0522d;">tensor</span>)
{
  /* <span style="color: #b22222;">Always true </span>*/
  assert (tensor.data != <span style="color: #008b8b;">NULL</span>);

  <span style="color: #228b22;">qmckl_exit_code</span> <span style="color: #a0522d;">rc</span>;

  rc = qmckl_free(context, tensor.data);
  <span style="color: #a020f0;">if</span> (rc != QMCKL_SUCCESS) {
    <span style="color: #a020f0;">return</span> rc;
  }

  memset(&amp;tensor, 0, <span style="color: #a020f0;">sizeof</span>(qmckl_tensor));

  <span style="color: #a020f0;">return</span> QMCKL_SUCCESS;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orge8245cc" class="outline-3">
<h3 id="orge8245cc"><span class="section-number-3">1.4</span> Reshaping</h3>
<div class="outline-text-3" id="text-1-4">
<p>
Reshaping occurs in-place and the pointer to the data is copied.
</p>
</div>

<div id="outline-container-orga022b1c" class="outline-4">
<h4 id="orga022b1c"><span class="section-number-4">1.4.1</span> Vector -&gt; Matrix</h4>
<div class="outline-text-4" id="text-1-4-1">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #228b22;">qmckl_matrix</span>
<span style="color: #0000ff;">qmckl_matrix_of_vector</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">qmckl_vector</span> <span style="color: #a0522d;">vector</span>,
                       <span style="color: #a020f0;">const</span> <span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">size1</span>,
                       <span style="color: #a020f0;">const</span> <span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">size2</span>);
</pre>
</div>

<p>
Reshapes a vector into a matrix.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #228b22;">qmckl_matrix</span>
<span style="color: #0000ff;">qmckl_matrix_of_vector</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">qmckl_vector</span> <span style="color: #a0522d;">vector</span>,
                       <span style="color: #a020f0;">const</span> <span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">size1</span>,
                       <span style="color: #a020f0;">const</span> <span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">size2</span>)
{ 
  /* <span style="color: #b22222;">Always true </span>*/
  assert (size1 * size2 == vector.size);

  <span style="color: #228b22;">qmckl_matrix</span> <span style="color: #a0522d;">result</span>;

  result.size[0] = size1;
  result.size[1] = size2;
  result.data    = vector.data;

  <span style="color: #a020f0;">return</span> result;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orga8f445a" class="outline-4">
<h4 id="orga8f445a"><span class="section-number-4">1.4.2</span> Vector -&gt; Tensor</h4>
<div class="outline-text-4" id="text-1-4-2">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #228b22;">qmckl_tensor</span>
<span style="color: #0000ff;">qmckl_tensor_of_vector</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">qmckl_vector</span> <span style="color: #a0522d;">vector</span>,
                       <span style="color: #a020f0;">const</span> <span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">order</span>,
                       <span style="color: #a020f0;">const</span> <span style="color: #228b22;">int64_t</span>* <span style="color: #a0522d;">size</span>);
</pre>
</div>

<p>
Reshapes a vector into a tensor.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #228b22;">qmckl_tensor</span>
<span style="color: #0000ff;">qmckl_tensor_of_vector</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">qmckl_vector</span> <span style="color: #a0522d;">vector</span>,
                       <span style="color: #a020f0;">const</span> <span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">order</span>,
                       <span style="color: #a020f0;">const</span> <span style="color: #228b22;">int64_t</span>* <span style="color: #a0522d;">size</span>)
{ 
  <span style="color: #228b22;">qmckl_tensor</span> <span style="color: #a0522d;">result</span>;

  <span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">prod_size</span> = 1;
  <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">i</span>=0 ; i&lt;order ; ++i) {
    result.size[i] = size[i];
    prod_size *= size[i];
  }
  assert (prod_size == vector.size);

  result.data = vector.data;

  <span style="color: #a020f0;">return</span> result;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org82027a9" class="outline-4">
<h4 id="org82027a9"><span class="section-number-4">1.4.3</span> Matrix -&gt; Vector</h4>
<div class="outline-text-4" id="text-1-4-3">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #228b22;">qmckl_vector</span>
<span style="color: #0000ff;">qmckl_vector_of_matrix</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">qmckl_matrix</span> <span style="color: #a0522d;">matrix</span>);
</pre>
</div>

<p>
Reshapes a matrix into a vector.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #228b22;">qmckl_vector</span>
<span style="color: #0000ff;">qmckl_vector_of_matrix</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">qmckl_matrix</span> <span style="color: #a0522d;">matrix</span>)
{ 
  <span style="color: #228b22;">qmckl_vector</span> <span style="color: #a0522d;">result</span>;

  result.size = matrix.size[0] * matrix.size[1];
  result.data = matrix.data;

  <span style="color: #a020f0;">return</span> result;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org5f92732" class="outline-4">
<h4 id="org5f92732"><span class="section-number-4">1.4.4</span> Matrix -&gt; Tensor</h4>
<div class="outline-text-4" id="text-1-4-4">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #228b22;">qmckl_tensor</span>
<span style="color: #0000ff;">qmckl_tensor_of_matrix</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">qmckl_matrix</span> <span style="color: #a0522d;">matrix</span>,
                       <span style="color: #a020f0;">const</span> <span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">order</span>,
                       <span style="color: #a020f0;">const</span> <span style="color: #228b22;">int64_t</span>* <span style="color: #a0522d;">size</span>);
</pre>
</div>

<p>
Reshapes a matrix into a tensor.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #228b22;">qmckl_tensor</span>
<span style="color: #0000ff;">qmckl_tensor_of_matrix</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">qmckl_matrix</span> <span style="color: #a0522d;">matrix</span>,
                       <span style="color: #a020f0;">const</span> <span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">order</span>,
                       <span style="color: #a020f0;">const</span> <span style="color: #228b22;">int64_t</span>* <span style="color: #a0522d;">size</span>)
{ 
  <span style="color: #228b22;">qmckl_tensor</span> <span style="color: #a0522d;">result</span>;

  <span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">prod_size</span> = 1;
  <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">i</span>=0 ; i&lt;order ; ++i) {
    result.size[i] = size[i];
    prod_size *= size[i];
  }
  assert (prod_size == matrix.size[0] * matrix.size[1]);

  result.data = matrix.data;

  <span style="color: #a020f0;">return</span> result;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org02f19e5" class="outline-4">
<h4 id="org02f19e5"><span class="section-number-4">1.4.5</span> Tensor -&gt; Vector</h4>
<div class="outline-text-4" id="text-1-4-5">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #228b22;">qmckl_vector</span>
<span style="color: #0000ff;">qmckl_vector_of_tensor</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">qmckl_tensor</span> <span style="color: #a0522d;">tensor</span>);
</pre>
</div>

<p>
Reshapes a tensor into a vector.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #228b22;">qmckl_vector</span>
<span style="color: #0000ff;">qmckl_vector_of_tensor</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">qmckl_tensor</span> <span style="color: #a0522d;">tensor</span>)
{ 
  <span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">prod_size</span> = (<span style="color: #228b22;">int64_t</span>) tensor.size[0];
  <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">i</span>=1 ; i&lt;tensor.order ; i++) {
    prod_size *= tensor.size[i];
  }

  <span style="color: #228b22;">qmckl_vector</span> <span style="color: #a0522d;">result</span>;

  result.size = prod_size;
  result.data = tensor.data;

  <span style="color: #a020f0;">return</span> result;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgacdc60a" class="outline-4">
<h4 id="orgacdc60a"><span class="section-number-4">1.4.6</span> Tensor -&gt; Matrix</h4>
<div class="outline-text-4" id="text-1-4-6">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #228b22;">qmckl_matrix</span>
<span style="color: #0000ff;">qmckl_matrix_of_tensor</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">qmckl_tensor</span> <span style="color: #a0522d;">tensor</span>,
                       <span style="color: #a020f0;">const</span> <span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">size1</span>,
                       <span style="color: #a020f0;">const</span> <span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">size2</span>);
</pre>
</div>

<p>
Reshapes a tensor into a vector.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #228b22;">qmckl_matrix</span>
<span style="color: #0000ff;">qmckl_matrix_of_tensor</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">qmckl_tensor</span> <span style="color: #a0522d;">tensor</span>,
                       <span style="color: #a020f0;">const</span> <span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">size1</span>,
                       <span style="color: #a020f0;">const</span> <span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">size2</span>)
{ 
  /* <span style="color: #b22222;">Always true </span>*/
  <span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">prod_size</span> = (<span style="color: #228b22;">int64_t</span>) 1;
  <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">i</span>=0 ; i&lt;tensor.order ; i++) {
    prod_size *= tensor.size[i];
  }
  assert (prod_size == size1 * size2);

  <span style="color: #228b22;">qmckl_matrix</span> <span style="color: #a0522d;">result</span>;

  result.size[0] = size1;
  result.size[1] = size2;
  result.data = tensor.data;

  <span style="color: #a020f0;">return</span> result;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org3886373" class="outline-3">
<h3 id="org3886373"><span class="section-number-3">1.5</span> Access macros</h3>
<div class="outline-text-3" id="text-1-5">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #483d8b;">#define</span> <span style="color: #0000ff;">qmckl_vec</span>(<span style="color: #a0522d;">v</span>, <span style="color: #a0522d;">i</span>) v.data[i]
<span style="color: #483d8b;">#define</span> <span style="color: #0000ff;">qmckl_mat</span>(<span style="color: #a0522d;">m</span>, <span style="color: #a0522d;">i</span>, <span style="color: #a0522d;">j</span>) m.data[(i) + (j)*m.size[0]]

<span style="color: #483d8b;">#define</span> <span style="color: #0000ff;">qmckl_ten3</span>(<span style="color: #a0522d;">t</span>, <span style="color: #a0522d;">i</span>, <span style="color: #a0522d;">j</span>, <span style="color: #a0522d;">k</span>) t.data[(i) + m.size[0]*((j) + size[1]*(k))]
<span style="color: #483d8b;">#define</span> <span style="color: #0000ff;">qmckl_ten4</span>(<span style="color: #a0522d;">t</span>, <span style="color: #a0522d;">i</span>, <span style="color: #a0522d;">j</span>, <span style="color: #a0522d;">k</span>, <span style="color: #a0522d;">l</span>) t.data[(i) + m.size[0]*((j) + size[1]*((k) + size[2]*(l)))]
<span style="color: #483d8b;">#define</span> <span style="color: #0000ff;">qmckl_ten5</span>(<span style="color: #a0522d;">t</span>, <span style="color: #a0522d;">i</span>, <span style="color: #a0522d;">j</span>, <span style="color: #a0522d;">k</span>, <span style="color: #a0522d;">l</span>, <span style="color: #a0522d;">m</span>) t.data[(i) + m.size[0]*((j) + size[1]*((k) + size[2]*((l) + size[3]*(m))))]
</pre>
</div>
</div>
</div>

<div id="outline-container-orgdc75f7a" class="outline-3">
<h3 id="orgdc75f7a"><span class="section-number-3">1.6</span> Copy to/from to <code>double*</code></h3>
<div class="outline-text-3" id="text-1-6">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #228b22;">qmckl_exit_code</span>
<span style="color: #0000ff;">qmckl_double_of_vector</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">qmckl_context</span> <span style="color: #a0522d;">context</span>,
                       <span style="color: #a020f0;">const</span> <span style="color: #228b22;">qmckl_vector</span> <span style="color: #a0522d;">vector</span>,
                       <span style="color: #228b22;">double</span>* <span style="color: #a020f0;">const</span> <span style="color: #a0522d;">target</span>,
                       <span style="color: #a020f0;">const</span> <span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">size_max</span>);
</pre>
</div>

<p>
Converts a vector to a <code>double*</code>.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #228b22;">qmckl_exit_code</span>
<span style="color: #0000ff;">qmckl_double_of_vector</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">qmckl_context</span> <span style="color: #a0522d;">context</span>,
                       <span style="color: #a020f0;">const</span> <span style="color: #228b22;">qmckl_vector</span> <span style="color: #a0522d;">vector</span>,
                       <span style="color: #228b22;">double</span>* <span style="color: #a020f0;">const</span> <span style="color: #a0522d;">target</span>,
                       <span style="color: #a020f0;">const</span> <span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">size_max</span>)
{
  /* <span style="color: #b22222;">Always true by construction </span>*/
  assert (qmckl_context_check(context) != QMCKL_NULL_CONTEXT);
  assert (vector.size &gt; (<span style="color: #228b22;">int64_t</span>) 0);
  assert (target != <span style="color: #008b8b;">NULL</span>);
  assert (size_max &gt; (<span style="color: #228b22;">int64_t</span>) 0);
  assert (size_max &gt;= vector.size);
  <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">i</span>=0 ; i&lt;vector.size ; ++i) {
    target[i] = vector.data[i];
  }
  <span style="color: #a020f0;">return</span> QMCKL_SUCCESS;

}
</pre>
</div>


<div class="org-src-container">
<pre class="src src-c"><span style="color: #228b22;">qmckl_exit_code</span>
<span style="color: #0000ff;">qmckl_double_of_matrix</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">qmckl_context</span> <span style="color: #a0522d;">context</span>,
                       <span style="color: #a020f0;">const</span> <span style="color: #228b22;">qmckl_matrix</span> <span style="color: #a0522d;">matrix</span>,
                       <span style="color: #228b22;">double</span>* <span style="color: #a020f0;">const</span> <span style="color: #a0522d;">target</span>,
                       <span style="color: #a020f0;">const</span> <span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">size_max</span>);
</pre>
</div>

<p>
Converts a matrix to a <code>double*</code>.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #228b22;">qmckl_exit_code</span>
<span style="color: #0000ff;">qmckl_double_of_matrix</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">qmckl_context</span> <span style="color: #a0522d;">context</span>,
                       <span style="color: #a020f0;">const</span> <span style="color: #228b22;">qmckl_matrix</span> <span style="color: #a0522d;">matrix</span>,
                       <span style="color: #228b22;">double</span>* <span style="color: #a020f0;">const</span> <span style="color: #a0522d;">target</span>,
                       <span style="color: #a020f0;">const</span> <span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">size_max</span>)
{
  <span style="color: #228b22;">qmckl_vector</span> <span style="color: #a0522d;">vector</span> = qmckl_vector_of_matrix(matrix);
  <span style="color: #a020f0;">return</span> qmckl_double_of_vector(context, vector, target, size_max);
}
</pre>
</div>


<div class="org-src-container">
<pre class="src src-c"><span style="color: #228b22;">qmckl_exit_code</span>
<span style="color: #0000ff;">qmckl_double_of_tensor</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">qmckl_context</span> <span style="color: #a0522d;">context</span>,
                       <span style="color: #a020f0;">const</span> <span style="color: #228b22;">qmckl_tensor</span> <span style="color: #a0522d;">tensor</span>,
                       <span style="color: #228b22;">double</span>* <span style="color: #a020f0;">const</span> <span style="color: #a0522d;">target</span>,
                       <span style="color: #a020f0;">const</span> <span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">size_max</span>);
</pre>
</div>

<p>
Converts a tensor to a <code>double*</code>.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #228b22;">qmckl_exit_code</span>
<span style="color: #0000ff;">qmckl_double_of_tensor</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">qmckl_context</span> <span style="color: #a0522d;">context</span>,
                       <span style="color: #a020f0;">const</span> <span style="color: #228b22;">qmckl_tensor</span> <span style="color: #a0522d;">tensor</span>,
                       <span style="color: #228b22;">double</span>* <span style="color: #a020f0;">const</span> <span style="color: #a0522d;">target</span>,
                       <span style="color: #a020f0;">const</span> <span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">size_max</span>)
{
  <span style="color: #228b22;">qmckl_vector</span> <span style="color: #a0522d;">vector</span> = qmckl_vector_of_tensor(tensor);
  <span style="color: #a020f0;">return</span> qmckl_double_of_vector(context, vector, target, size_max);
}
</pre>
</div>


<div class="org-src-container">
<pre class="src src-c"><span style="color: #228b22;">qmckl_exit_code</span>
<span style="color: #0000ff;">qmckl_vector_of_double</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">qmckl_context</span> <span style="color: #a0522d;">context</span>,
                       <span style="color: #a020f0;">const</span> <span style="color: #228b22;">double</span>* <span style="color: #a0522d;">target</span>,
                       <span style="color: #a020f0;">const</span> <span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">size_max</span>,
                       <span style="color: #228b22;">qmckl_vector</span>* <span style="color: #a0522d;">vector</span>);
</pre>
</div>

<p>
Converts a <code>double*</code> to a vector.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #228b22;">qmckl_exit_code</span>
<span style="color: #0000ff;">qmckl_vector_of_double</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">qmckl_context</span> <span style="color: #a0522d;">context</span>,
                       <span style="color: #a020f0;">const</span> <span style="color: #228b22;">double</span>* <span style="color: #a0522d;">target</span>,
                       <span style="color: #a020f0;">const</span> <span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">size_max</span>,
                       <span style="color: #228b22;">qmckl_vector</span>* <span style="color: #a0522d;">vector_out</span>)
{
  <span style="color: #228b22;">qmckl_vector</span> <span style="color: #a0522d;">vector</span> = *vector_out;
  /* <span style="color: #b22222;">Always true by construction </span>*/
  assert (qmckl_context_check(context) != QMCKL_NULL_CONTEXT);

  <span style="color: #a020f0;">if</span> (vector.size == 0) {
    <span style="color: #a020f0;">return</span> qmckl_failwith( context,
                           QMCKL_INVALID_ARG_4,
                           <span style="color: #8b2252;">"qmckl_double_of_vector"</span>,
                           <span style="color: #8b2252;">"Vector not allocated"</span>);
  }

  <span style="color: #a020f0;">if</span> (vector.size != size_max) {
      <span style="color: #a020f0;">return</span> qmckl_failwith( context,
                             QMCKL_INVALID_ARG_4,
                             <span style="color: #8b2252;">"qmckl_double_of_vector"</span>,
                             <span style="color: #8b2252;">"Wrong vector size"</span>);
  }

  <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">i</span>=0 ; i&lt;vector.size ; ++i) {
    vector.data[i] = target[i];
  }

  *vector_out = vector;
  <span style="color: #a020f0;">return</span> QMCKL_SUCCESS;

}
</pre>
</div>


<div class="org-src-container">
<pre class="src src-c"><span style="color: #228b22;">qmckl_exit_code</span>
<span style="color: #0000ff;">qmckl_matrix_of_double</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">qmckl_context</span> <span style="color: #a0522d;">context</span>,
                       <span style="color: #a020f0;">const</span> <span style="color: #228b22;">double</span>* <span style="color: #a0522d;">target</span>,
                       <span style="color: #a020f0;">const</span> <span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">size_max</span>,
                       <span style="color: #228b22;">qmckl_matrix</span>* <span style="color: #a0522d;">matrix</span>);
</pre>
</div>

<p>
Converts a matrix to a <code>double*</code>.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #228b22;">qmckl_exit_code</span>
<span style="color: #0000ff;">qmckl_matrix_of_double</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">qmckl_context</span> <span style="color: #a0522d;">context</span>,
                       <span style="color: #a020f0;">const</span> <span style="color: #228b22;">double</span>* <span style="color: #a0522d;">target</span>,
                       <span style="color: #a020f0;">const</span> <span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">size_max</span>,
                       <span style="color: #228b22;">qmckl_matrix</span>* <span style="color: #a0522d;">matrix</span>)
{
  <span style="color: #228b22;">qmckl_vector</span> <span style="color: #a0522d;">vector</span> = qmckl_vector_of_matrix(*matrix);
  <span style="color: #228b22;">qmckl_exit_code</span> <span style="color: #a0522d;">rc</span> =
    qmckl_vector_of_double(context, target, size_max, &amp;vector);
  *matrix = qmckl_matrix_of_vector(vector, matrix-&gt;size[0], matrix-&gt;size[1]);
  <span style="color: #a020f0;">return</span> rc;
}
</pre>
</div>


<div class="org-src-container">
<pre class="src src-c"><span style="color: #228b22;">qmckl_exit_code</span>
<span style="color: #0000ff;">qmckl_tensor_of_double</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">qmckl_context</span> <span style="color: #a0522d;">context</span>,
                       <span style="color: #a020f0;">const</span> <span style="color: #228b22;">double</span>* <span style="color: #a0522d;">target</span>,
                       <span style="color: #a020f0;">const</span> <span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">size_max</span>,
                       <span style="color: #228b22;">qmckl_tensor</span>* <span style="color: #a0522d;">tensor</span>);
</pre>
</div>

<p>
Converts a matrix to a <code>double*</code>.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #228b22;">qmckl_exit_code</span>
<span style="color: #0000ff;">qmckl_tensor_of_double</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">qmckl_context</span> <span style="color: #a0522d;">context</span>,
                       <span style="color: #a020f0;">const</span> <span style="color: #228b22;">double</span>* <span style="color: #a0522d;">target</span>,
                       <span style="color: #a020f0;">const</span> <span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">size_max</span>,
                       <span style="color: #228b22;">qmckl_tensor</span>* <span style="color: #a0522d;">tensor</span>)
{
  <span style="color: #228b22;">qmckl_vector</span> <span style="color: #a0522d;">vector</span> = qmckl_vector_of_tensor(*tensor);
  <span style="color: #228b22;">qmckl_exit_code</span> <span style="color: #a0522d;">rc</span> =
    qmckl_vector_of_double(context, target, size_max, &amp;vector);
  *tensor = qmckl_tensor_of_vector(vector, tensor-&gt;order, tensor-&gt;size);
  <span style="color: #a020f0;">return</span> rc;
}
</pre>
</div>
</div>
</div>




<div id="outline-container-orge357b0a" class="outline-3">
<h3 id="orge357b0a"><span class="section-number-3">1.7</span> Tests</h3>
<div class="outline-text-3" id="text-1-7">
<div class="org-src-container">
<pre class="src src-c">{
  <span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">m</span> = 3;
  <span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">n</span> = 4;
  <span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">p</span> = m*n;
  <span style="color: #228b22;">qmckl_vector</span> <span style="color: #a0522d;">vec</span> = qmckl_vector_alloc(context, p);

  <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">i</span>=0 ; i&lt;p ; ++i) 
    qmckl_vec(vec, i) = (<span style="color: #228b22;">double</span>) i;

  <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">i</span>=0 ; i&lt;p ; ++i) 
    assert( vec.data[i] == (<span style="color: #228b22;">double</span>) i );

  <span style="color: #228b22;">qmckl_matrix</span> <span style="color: #a0522d;">mat</span> = qmckl_matrix_of_vector(vec, m, n);
  assert (mat.size[0] == m);
  assert (mat.size[1] == n);
  assert (mat.data == vec.data);

  <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">j</span>=0 ; j&lt;n ; ++j)
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">i</span>=0 ; i&lt;m ; ++i)
      assert ( qmckl_mat(mat, i, j) == qmckl_vec(vec, i+j*m)) ;

  <span style="color: #228b22;">qmckl_vector</span> <span style="color: #a0522d;">vec2</span> = qmckl_vector_of_matrix(mat);
  assert (vec2.size == p);
  assert (vec2.data == vec.data);
  <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">i</span>=0 ; i&lt;p ; ++i) 
      assert ( qmckl_vec(vec2, i) == qmckl_vec(vec, i) ) ;

  qmckl_vector_free(context, vec);

}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orged24ee9" class="outline-2">
<h2 id="orged24ee9"><span class="section-number-2">2</span> Matrix operations</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-org3e1c790" class="outline-3">
<h3 id="org3e1c790"><span class="section-number-3">2.1</span> <code>qmckl_dgemm</code></h3>
<div class="outline-text-3" id="text-2-1">
<p>
Matrix multiplication:
</p>

<p>
\[
   C_{ij} = \beta C_{ij} + \alpha \sum_{k} A_{ik} \cdot B_{kj}
   \]
</p>

<table id="orgbda55cc" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Variable</th>
<th scope="col" class="org-left">Type</th>
<th scope="col" class="org-left">In/Out</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>context</code></td>
<td class="org-left"><code>qmckl_context</code></td>
<td class="org-left">in</td>
<td class="org-left">Global state</td>
</tr>

<tr>
<td class="org-left"><code>TransA</code></td>
<td class="org-left"><code>char</code></td>
<td class="org-left">in</td>
<td class="org-left">'T' is transposed</td>
</tr>

<tr>
<td class="org-left"><code>TransB</code></td>
<td class="org-left"><code>char</code></td>
<td class="org-left">in</td>
<td class="org-left">'T' is transposed</td>
</tr>

<tr>
<td class="org-left"><code>m</code></td>
<td class="org-left"><code>int64_t</code></td>
<td class="org-left">in</td>
<td class="org-left">Number of rows of the input matrix</td>
</tr>

<tr>
<td class="org-left"><code>n</code></td>
<td class="org-left"><code>int64_t</code></td>
<td class="org-left">in</td>
<td class="org-left">Number of columns of the input matrix</td>
</tr>

<tr>
<td class="org-left"><code>k</code></td>
<td class="org-left"><code>int64_t</code></td>
<td class="org-left">in</td>
<td class="org-left">Number of columns of the input matrix</td>
</tr>

<tr>
<td class="org-left"><code>alpha</code></td>
<td class="org-left"><code>double</code></td>
<td class="org-left">in</td>
<td class="org-left">&alpha;</td>
</tr>

<tr>
<td class="org-left"><code>A</code></td>
<td class="org-left"><code>double[][lda]</code></td>
<td class="org-left">in</td>
<td class="org-left">Array containing the matrix \(A\)</td>
</tr>

<tr>
<td class="org-left"><code>lda</code></td>
<td class="org-left"><code>int64_t</code></td>
<td class="org-left">in</td>
<td class="org-left">Leading dimension of array <code>A</code></td>
</tr>

<tr>
<td class="org-left"><code>B</code></td>
<td class="org-left"><code>double[][ldb]</code></td>
<td class="org-left">in</td>
<td class="org-left">Array containing the matrix \(B\)</td>
</tr>

<tr>
<td class="org-left"><code>ldb</code></td>
<td class="org-left"><code>int64_t</code></td>
<td class="org-left">in</td>
<td class="org-left">Leading dimension of array <code>B</code></td>
</tr>

<tr>
<td class="org-left"><code>beta</code></td>
<td class="org-left"><code>double</code></td>
<td class="org-left">in</td>
<td class="org-left">&beta;</td>
</tr>

<tr>
<td class="org-left"><code>C</code></td>
<td class="org-left"><code>double[][ldc]</code></td>
<td class="org-left">out</td>
<td class="org-left">Array containing the matrix \(C\)</td>
</tr>

<tr>
<td class="org-left"><code>ldc</code></td>
<td class="org-left"><code>int64_t</code></td>
<td class="org-left">in</td>
<td class="org-left">Leading dimension of array <code>C</code></td>
</tr>
</tbody>
</table>

<p>
Requirements:
</p>

<ul class="org-ul">
<li><code>context</code> is not <code>QMCKL_NULL_CONTEXT</code></li>
<li><code>m &gt; 0</code></li>
<li><code>n &gt; 0</code></li>
<li><code>k &gt; 0</code></li>
<li><code>lda &gt;= m</code></li>
<li><code>ldb &gt;= n</code></li>
<li><code>ldc &gt;= n</code></li>
<li><code>A</code> is allocated with at least \(m \times k \times 8\) bytes</li>
<li><code>B</code> is allocated with at least \(k \times n \times 8\) bytes</li>
<li><code>C</code> is allocated with at least \(m \times n \times 8\) bytes</li>
</ul>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #228b22;">qmckl_exit_code</span> <span style="color: #0000ff;">qmckl_dgemm</span> (
      <span style="color: #a020f0;">const</span> <span style="color: #228b22;">qmckl_context</span> <span style="color: #a0522d;">context</span>,
      <span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span> <span style="color: #a0522d;">TransA</span>,
      <span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span> <span style="color: #a0522d;">TransB</span>,
      <span style="color: #a020f0;">const</span> <span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">m</span>,
      <span style="color: #a020f0;">const</span> <span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">n</span>,
      <span style="color: #a020f0;">const</span> <span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">k</span>,
      <span style="color: #a020f0;">const</span> <span style="color: #228b22;">double</span> <span style="color: #a0522d;">alpha</span>,
      <span style="color: #a020f0;">const</span> <span style="color: #228b22;">double</span>* <span style="color: #a0522d;">A</span>,
      <span style="color: #a020f0;">const</span> <span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">lda</span>,
      <span style="color: #a020f0;">const</span> <span style="color: #228b22;">double</span>* <span style="color: #a0522d;">B</span>,
      <span style="color: #a020f0;">const</span> <span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">ldb</span>,
      <span style="color: #a020f0;">const</span> <span style="color: #228b22;">double</span> <span style="color: #a0522d;">beta</span>,
      <span style="color: #228b22;">double</span>* <span style="color: #a020f0;">const</span> <span style="color: #a0522d;">C</span>,
      <span style="color: #a020f0;">const</span> <span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">ldc</span> ); 
</pre>
</div>

<div class="org-src-container">
<pre class="src src-f90"><span style="color: #228b22;">integer</span><span style="color: #a0522d;"> function qmckl_dgemm_f(context, TransA, TransB, </span><span style="color: #a020f0;">&amp;</span>
     m, n, k, alpha, A, LDA, B, LDB, beta, C, LDC) <span style="color: #a020f0;">&amp;</span>
     <span style="color: #a020f0;">result</span>(info)
  <span style="color: #a020f0;">use</span> <span style="color: #0000ff;">qmckl</span>
  <span style="color: #a020f0;">implicit</span> <span style="color: #228b22;">none</span>
  <span style="color: #228b22;">integer</span>(qmckl_context), <span style="color: #a020f0;">intent</span>(in)  ::<span style="color: #a0522d;"> context</span>
  <span style="color: #228b22;">character</span>             , <span style="color: #a020f0;">intent</span>(in)  ::<span style="color: #a0522d;"> TransA, TransB</span>
  <span style="color: #228b22;">integer</span>*8             , <span style="color: #a020f0;">intent</span>(in)  ::<span style="color: #a0522d;"> m, n, k</span>
  <span style="color: #228b22;">double precision</span>      , <span style="color: #a020f0;">intent</span>(in)  ::<span style="color: #a0522d;"> alpha, beta</span>
  <span style="color: #228b22;">integer</span>*8             , <span style="color: #a020f0;">intent</span>(in)  ::<span style="color: #a0522d;"> lda</span>
  <span style="color: #228b22;">double precision</span>      , <span style="color: #a020f0;">intent</span>(in)  ::<span style="color: #a0522d;"> A(lda,*)</span>
  <span style="color: #228b22;">integer</span>*8             , <span style="color: #a020f0;">intent</span>(in)  ::<span style="color: #a0522d;"> ldb</span>
  <span style="color: #228b22;">double precision</span>      , <span style="color: #a020f0;">intent</span>(in)  ::<span style="color: #a0522d;"> B(ldb,*)</span>
  <span style="color: #228b22;">integer</span>*8             , <span style="color: #a020f0;">intent</span>(in)  ::<span style="color: #a0522d;"> ldc</span>
  <span style="color: #228b22;">double precision</span>      , <span style="color: #a020f0;">intent</span>(out) ::<span style="color: #a0522d;"> C(ldc,*)</span>

  info = QMCKL_SUCCESS

  <span style="color: #a020f0;">if</span> (context == QMCKL_NULL_CONTEXT) <span style="color: #a020f0;">then</span>
     info = QMCKL_INVALID_CONTEXT
     <span style="color: #a020f0;">return</span>
  <span style="color: #a020f0;">endif</span>

  <span style="color: #a020f0;">if</span> (m &lt;= 0_8) <span style="color: #a020f0;">then</span>
     info = QMCKL_INVALID_ARG_4
     <span style="color: #a020f0;">return</span>
  <span style="color: #a020f0;">endif</span>

  <span style="color: #a020f0;">if</span> (n &lt;= 0_8) <span style="color: #a020f0;">then</span>
     info = QMCKL_INVALID_ARG_5
     <span style="color: #a020f0;">return</span>
  <span style="color: #a020f0;">endif</span>

  <span style="color: #a020f0;">if</span> (k &lt;= 0_8) <span style="color: #a020f0;">then</span>
     info = QMCKL_INVALID_ARG_6
     <span style="color: #a020f0;">return</span>
  <span style="color: #a020f0;">endif</span>

  <span style="color: #a020f0;">if</span> (LDA &lt;= 0) <span style="color: #a020f0;">then</span>
     info = QMCKL_INVALID_ARG_9
     <span style="color: #a020f0;">return</span>
  <span style="color: #a020f0;">endif</span>

  <span style="color: #a020f0;">if</span> (LDB &lt;= 0) <span style="color: #a020f0;">then</span>
     info = QMCKL_INVALID_ARG_11
     <span style="color: #a020f0;">return</span>
  <span style="color: #a020f0;">endif</span>

  <span style="color: #a020f0;">if</span> (LDC &lt;= 0) <span style="color: #a020f0;">then</span>
     info = QMCKL_INVALID_ARG_14
     <span style="color: #a020f0;">return</span>
  <span style="color: #a020f0;">endif</span>

  <span style="color: #a020f0;">call</span> <span style="color: #0000ff;">dgemm</span>(transA, transB, <span style="color: #a020f0;">int</span>(m,4), <span style="color: #a020f0;">int</span>(n,4), <span style="color: #a020f0;">int</span>(k,4), <span style="color: #a020f0;">&amp;</span>
       alpha, A, <span style="color: #a020f0;">int</span>(LDA,4), B, <span style="color: #a020f0;">int</span>(LDB,4), beta, C, <span style="color: #a020f0;">int</span>(LDC,4))

<span style="color: #a020f0;">end function</span> <span style="color: #0000ff;">qmckl_dgemm_f</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org22e8c11" class="outline-3">
<h3 id="org22e8c11"><span class="section-number-3">2.2</span> <code>qmckl_matmul</code></h3>
<div class="outline-text-3" id="text-2-2">
<p>
Matrix multiplication:
</p>

<p>
\[
   C_{ij} = \beta C_{ij} + \alpha \sum_{k} A_{ik} \cdot B_{kj}
   \]
</p>

<table id="org7c56633" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Variable</th>
<th scope="col" class="org-left">Type</th>
<th scope="col" class="org-left">In/Out</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>context</code></td>
<td class="org-left"><code>qmckl_context</code></td>
<td class="org-left">in</td>
<td class="org-left">Global state</td>
</tr>

<tr>
<td class="org-left"><code>TransA</code></td>
<td class="org-left"><code>char</code></td>
<td class="org-left">in</td>
<td class="org-left">'T' is transposed</td>
</tr>

<tr>
<td class="org-left"><code>TransB</code></td>
<td class="org-left"><code>char</code></td>
<td class="org-left">in</td>
<td class="org-left">'T' is transposed</td>
</tr>

<tr>
<td class="org-left"><code>alpha</code></td>
<td class="org-left"><code>double</code></td>
<td class="org-left">in</td>
<td class="org-left">&alpha;</td>
</tr>

<tr>
<td class="org-left"><code>A</code></td>
<td class="org-left"><code>qmckl_matrix</code></td>
<td class="org-left">in</td>
<td class="org-left">Matrix \(A\)</td>
</tr>

<tr>
<td class="org-left"><code>B</code></td>
<td class="org-left"><code>qmckl_matrix</code></td>
<td class="org-left">in</td>
<td class="org-left">Matrix \(B\)</td>
</tr>

<tr>
<td class="org-left"><code>beta</code></td>
<td class="org-left"><code>double</code></td>
<td class="org-left">in</td>
<td class="org-left">&beta;</td>
</tr>

<tr>
<td class="org-left"><code>C</code></td>
<td class="org-left"><code>qmckl_matrix</code></td>
<td class="org-left">out</td>
<td class="org-left">Matrix \(C\)</td>
</tr>
</tbody>
</table>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #228b22;">qmckl_exit_code</span> <span style="color: #0000ff;">qmckl_matmul</span> (
      <span style="color: #a020f0;">const</span> <span style="color: #228b22;">qmckl_context</span> <span style="color: #a0522d;">context</span>,
      <span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span> <span style="color: #a0522d;">TransA</span>,
      <span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span> <span style="color: #a0522d;">TransB</span>,
      <span style="color: #a020f0;">const</span> <span style="color: #228b22;">double</span> <span style="color: #a0522d;">alpha</span>,
      <span style="color: #a020f0;">const</span> <span style="color: #228b22;">qmckl_matrix</span> <span style="color: #a0522d;">A</span>,
      <span style="color: #a020f0;">const</span> <span style="color: #228b22;">qmckl_matrix</span> <span style="color: #a0522d;">B</span>,
      <span style="color: #a020f0;">const</span> <span style="color: #228b22;">double</span> <span style="color: #a0522d;">beta</span>,
      <span style="color: #228b22;">qmckl_matrix</span>* <span style="color: #a020f0;">const</span> <span style="color: #a0522d;">C</span> ); 
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #228b22;">qmckl_exit_code</span>
<span style="color: #0000ff;">qmckl_matmul</span> (<span style="color: #a020f0;">const</span> <span style="color: #228b22;">qmckl_context</span> <span style="color: #a0522d;">context</span>,
              <span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span> <span style="color: #a0522d;">TransA</span>,
              <span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span> <span style="color: #a0522d;">TransB</span>,
              <span style="color: #a020f0;">const</span> <span style="color: #228b22;">double</span> <span style="color: #a0522d;">alpha</span>,
              <span style="color: #a020f0;">const</span> <span style="color: #228b22;">qmckl_matrix</span> <span style="color: #a0522d;">A</span>,
              <span style="color: #a020f0;">const</span> <span style="color: #228b22;">qmckl_matrix</span> <span style="color: #a0522d;">B</span>,
              <span style="color: #a020f0;">const</span> <span style="color: #228b22;">double</span> <span style="color: #a0522d;">beta</span>,
              <span style="color: #228b22;">qmckl_matrix</span>* <span style="color: #a020f0;">const</span> <span style="color: #a0522d;">C</span> )
{
  <span style="color: #a020f0;">if</span> (qmckl_context_check(context) == QMCKL_NULL_CONTEXT) {
    <span style="color: #a020f0;">return</span> QMCKL_INVALID_CONTEXT;
  }

  <span style="color: #228b22;">qmckl_exit_code</span> <span style="color: #a0522d;">rc</span> = QMCKL_SUCCESS;

  <span style="color: #a020f0;">if</span> (TransA != <span style="color: #8b2252;">'N'</span> &amp;&amp; TransA != <span style="color: #8b2252;">'T'</span>) {
    <span style="color: #a020f0;">return</span> qmckl_failwith( context,
                           QMCKL_INVALID_ARG_2,
                           <span style="color: #8b2252;">"qmckl_matmul"</span>,
                           <span style="color: #8b2252;">"TransA should be 'N' or 'T'"</span>);
  }

  <span style="color: #a020f0;">if</span> (TransB != <span style="color: #8b2252;">'N'</span> &amp;&amp; TransB != <span style="color: #8b2252;">'T'</span>) {
    <span style="color: #a020f0;">return</span> qmckl_failwith( context,
                           QMCKL_INVALID_ARG_3,
                           <span style="color: #8b2252;">"qmckl_matmul"</span>,
                           <span style="color: #8b2252;">"TransB should be 'N' or 'T'"</span>);
  }

  <span style="color: #a020f0;">if</span> (A.size[0] &lt; 1) {
    <span style="color: #a020f0;">return</span> qmckl_failwith( context,
                           QMCKL_INVALID_ARG_5,
                           <span style="color: #8b2252;">"qmckl_matmul"</span>,
                           <span style="color: #8b2252;">"Invalid size for A"</span>);
  }

  <span style="color: #a020f0;">if</span> (B.size[0] &lt; 1) {
    <span style="color: #a020f0;">return</span> qmckl_failwith( context,
                           QMCKL_INVALID_ARG_6,
                           <span style="color: #8b2252;">"qmckl_matmul"</span>,
                           <span style="color: #8b2252;">"Invalid size for B"</span>);
  }

  <span style="color: #a020f0;">if</span> (C == <span style="color: #008b8b;">NULL</span>) {
    <span style="color: #a020f0;">return</span> qmckl_failwith( context,
                           QMCKL_INVALID_ARG_8,
                           <span style="color: #8b2252;">"qmckl_matmul"</span>,
                           <span style="color: #8b2252;">"Null pointer"</span>);
  }

  <span style="color: #228b22;">int</span> <span style="color: #a0522d;">t</span> = 0;
  <span style="color: #a020f0;">if</span> (TransA == <span style="color: #8b2252;">'T'</span>) t +=1;
  <span style="color: #a020f0;">if</span> (TransB == <span style="color: #8b2252;">'T'</span>) t +=2;
  /*
<span style="color: #b22222;">    | t | TransA | TransB |</span>
<span style="color: #b22222;">    +---+--------+--------+</span>
<span style="color: #b22222;">    | 0 | N      | N      |</span>
<span style="color: #b22222;">    | 1 | T      | N      |</span>
<span style="color: #b22222;">    | 2 | N      | T      |</span>
<span style="color: #b22222;">    | 3 | T      | T      |</span>
<span style="color: #b22222;">  </span>*/

  <span style="color: #a020f0;">switch</span> (t) {
  <span style="color: #a020f0;">case</span> 0:
    <span style="color: #a020f0;">if</span> (A.size[1] != B.size[0]) {
      <span style="color: #a020f0;">return</span> qmckl_failwith( context,
                             QMCKL_INVALID_ARG_2,
                             <span style="color: #8b2252;">"qmckl_matmul"</span>,
                             <span style="color: #8b2252;">"A and B have incompatible dimensions"</span>);
    }
    C-&gt;size[0] = A.size[0];
    C-&gt;size[1] = B.size[1];
    rc = qmckl_dgemm (context, <span style="color: #8b2252;">'N'</span>, <span style="color: #8b2252;">'N'</span>,
                      C-&gt;size[0], C-&gt;size[1], A.size[1],
                      alpha,
                      A.data, A.size[0],
                      B.data, B.size[0],
                      beta,
                      C-&gt;data, C-&gt;size[0]);
    <span style="color: #a020f0;">break</span>;
  <span style="color: #a020f0;">case</span> 1:
    <span style="color: #a020f0;">if</span> (A.size[0] != B.size[0]) { 
      <span style="color: #a020f0;">return</span> qmckl_failwith( context,
                             QMCKL_INVALID_ARG_2,
                             <span style="color: #8b2252;">"qmckl_matmul"</span>,
                             <span style="color: #8b2252;">"A and B have incompatible dimensions"</span>);
    }
    C-&gt;size[0] = A.size[1];
    C-&gt;size[1] = B.size[1];
    rc = qmckl_dgemm (context, <span style="color: #8b2252;">'T'</span>, <span style="color: #8b2252;">'N'</span>,
                      C-&gt;size[0], C-&gt;size[1], A.size[0],
                      alpha,
                      A.data, A.size[0],
                      B.data, B.size[0],
                      beta,
                      C-&gt;data, C-&gt;size[0]);
    <span style="color: #a020f0;">break</span>;
  <span style="color: #a020f0;">case</span> 2:
    <span style="color: #a020f0;">if</span> (A.size[1] != B.size[1]) {
      <span style="color: #a020f0;">return</span> qmckl_failwith( context,
                             QMCKL_INVALID_ARG_2,
                             <span style="color: #8b2252;">"qmckl_matmul"</span>,
                             <span style="color: #8b2252;">"A and B have incompatible dimensions"</span>);
    }
    C-&gt;size[0] = A.size[0];
    C-&gt;size[1] = B.size[0];
    rc = qmckl_dgemm (context, <span style="color: #8b2252;">'N'</span>, <span style="color: #8b2252;">'T'</span>,
                      C-&gt;size[0], C-&gt;size[1], A.size[1],
                      alpha,
                      A.data, A.size[0],
                      B.data, B.size[0],
                      beta,
                      C-&gt;data, C-&gt;size[0]);
    <span style="color: #a020f0;">break</span>;
  <span style="color: #a020f0;">case</span> 3:
    <span style="color: #a020f0;">if</span> (A.size[0] != B.size[1]) {
      <span style="color: #a020f0;">return</span> qmckl_failwith( context,
                             QMCKL_INVALID_ARG_2,
                             <span style="color: #8b2252;">"qmckl_matmul"</span>,
                             <span style="color: #8b2252;">"A and B have incompatible dimensions"</span>);
    }
    C-&gt;size[0] = A.size[1];
    C-&gt;size[1] = B.size[0];
    rc = qmckl_dgemm (context, <span style="color: #8b2252;">'T'</span>, <span style="color: #8b2252;">'T'</span>,
                      C-&gt;size[0], C-&gt;size[1], A.size[0],
                      alpha,
                      A.data, A.size[0],
                      B.data, B.size[0],
                      beta,
                      C-&gt;data, C-&gt;size[0]);
    <span style="color: #a020f0;">break</span>;
  }
  <span style="color: #a020f0;">return</span> rc;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org3bfeb4a" class="outline-3">
<h3 id="org3bfeb4a"><span class="section-number-3">2.3</span> <code>qmckl_adjugate</code></h3>
<div class="outline-text-3" id="text-2-3">
<p>
Given a matrix \(\mathbf{A}\), the adjugate matrix
\(\text{adj}(\mathbf{A})\) is the transpose of the cofactors matrix
of \(\mathbf{A}\).
</p>

<p>
\[
   \mathbf{B} = \text{adj}(\mathbf{A}) = \text{det}(\mathbf{A}) \, \mathbf{A}^{-1}
   \]
</p>

<p>
See also: <a href="https://en.wikipedia.org/wiki/Adjugate_matrix">https://en.wikipedia.org/wiki/Adjugate_matrix</a>
</p>

<table id="orga29d084" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Variable</th>
<th scope="col" class="org-left">Type</th>
<th scope="col" class="org-left">In/Out</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>context</code></td>
<td class="org-left"><code>qmckl_context</code></td>
<td class="org-left">in</td>
<td class="org-left">Global state</td>
</tr>

<tr>
<td class="org-left"><code>n</code></td>
<td class="org-left"><code>int64_t</code></td>
<td class="org-left">in</td>
<td class="org-left">Number of rows and columns of the input matrix</td>
</tr>

<tr>
<td class="org-left"><code>A</code></td>
<td class="org-left"><code>double[][lda]</code></td>
<td class="org-left">in</td>
<td class="org-left">Array containing the \(n \times n\) matrix \(A\)</td>
</tr>

<tr>
<td class="org-left"><code>lda</code></td>
<td class="org-left"><code>int64_t</code></td>
<td class="org-left">in</td>
<td class="org-left">Leading dimension of array <code>A</code></td>
</tr>

<tr>
<td class="org-left"><code>B</code></td>
<td class="org-left"><code>double[][ldb]</code></td>
<td class="org-left">out</td>
<td class="org-left">Adjugate of \(A\)</td>
</tr>

<tr>
<td class="org-left"><code>ldb</code></td>
<td class="org-left"><code>int64_t</code></td>
<td class="org-left">in</td>
<td class="org-left">Leading dimension of array <code>B</code></td>
</tr>

<tr>
<td class="org-left"><code>det_l</code></td>
<td class="org-left"><code>double</code></td>
<td class="org-left">inout</td>
<td class="org-left">determinant of \(A\)</td>
</tr>
</tbody>
</table>

<p>
Requirements:
</p>

<ul class="org-ul">
<li><code>context</code> is not <code>QMCKL_NULL_CONTEXT</code></li>
<li><code>n &gt; 0</code></li>
<li><code>lda &gt;= m</code></li>
<li><code>A</code> is allocated with at least \(m \times m \times 8\) bytes</li>
<li><code>ldb &gt;= m</code></li>
<li><code>B</code> is allocated with at least \(m \times m \times 8\) bytes</li>
</ul>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #228b22;">qmckl_exit_code</span> <span style="color: #0000ff;">qmckl_adjugate</span> (
      <span style="color: #a020f0;">const</span> <span style="color: #228b22;">qmckl_context</span> <span style="color: #a0522d;">context</span>,
      <span style="color: #a020f0;">const</span> <span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">n</span>,
      <span style="color: #a020f0;">const</span> <span style="color: #228b22;">double</span>* <span style="color: #a0522d;">A</span>,
      <span style="color: #a020f0;">const</span> <span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">lda</span>,
      <span style="color: #228b22;">double</span>* <span style="color: #a020f0;">const</span> <span style="color: #a0522d;">B</span>,
      <span style="color: #a020f0;">const</span> <span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">ldb</span>,
      <span style="color: #228b22;">double</span>* <span style="color: #a0522d;">det_l</span> ); 
</pre>
</div>

<p>
For small matrices (&le; 5&times; 5), we use specialized routines
for performance motivations. For larger sizes, we rely on the
LAPACK library.
</p>

<div class="org-src-container">
<pre class="src src-f90"><span style="color: #228b22;">integer </span><span style="color: #a020f0;">function</span><span style="color: #a0522d;"> </span><span style="color: #0000ff;">qmckl_adjugate_f</span><span style="color: #000000; background-color: #ffffff;">(context, na, A, LDA, B, ldb, det_l)</span><span style="color: #a0522d;"> </span><span style="color: #a020f0;">&amp;</span>
     <span style="color: #a020f0;">result</span>(info)
  <span style="color: #a020f0;">use</span> <span style="color: #0000ff;">qmckl</span>
  <span style="color: #a020f0;">implicit</span> <span style="color: #228b22;">none</span>
  <span style="color: #228b22;">integer</span>(qmckl_context)  , <span style="color: #a020f0;">intent</span>(in)  ::<span style="color: #a0522d;"> context</span>
  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">intent</span>(in)          ::<span style="color: #a0522d;"> A (LDA,*)</span>
  <span style="color: #228b22;">integer</span>*8, <span style="color: #a020f0;">intent</span>(in)                 ::<span style="color: #a0522d;"> LDA</span>
  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">intent</span>(out)         ::<span style="color: #a0522d;"> B (LDB,*)</span>
  <span style="color: #228b22;">integer</span>*8, <span style="color: #a020f0;">intent</span>(in)                 ::<span style="color: #a0522d;"> LDB</span>
  <span style="color: #228b22;">integer</span>*8, <span style="color: #a020f0;">intent</span>(in)                 ::<span style="color: #a0522d;"> na</span>
  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">intent</span>(inout)       ::<span style="color: #a0522d;"> det_l</span>

  <span style="color: #228b22;">integer</span>    ::<span style="color: #a0522d;"> i,j</span>

  info = QMCKL_SUCCESS

  <span style="color: #a020f0;">if</span> (context == QMCKL_NULL_CONTEXT) <span style="color: #a020f0;">then</span>
     info = QMCKL_INVALID_CONTEXT
     <span style="color: #a020f0;">return</span>
  <span style="color: #a020f0;">endif</span>

  <span style="color: #a020f0;">if</span> (na &lt;= 0_8) <span style="color: #a020f0;">then</span>
     info = QMCKL_INVALID_ARG_2
     <span style="color: #a020f0;">return</span>
  <span style="color: #a020f0;">endif</span>

  <span style="color: #a020f0;">if</span> (LDA &lt;= 0_8) <span style="color: #a020f0;">then</span>
     info = QMCKL_INVALID_ARG_4
     <span style="color: #a020f0;">return</span>
  <span style="color: #a020f0;">endif</span>

  <span style="color: #a020f0;">if</span> (LDA &lt; na) <span style="color: #a020f0;">then</span>
     info = QMCKL_INVALID_ARG_4
     <span style="color: #a020f0;">return</span>
  <span style="color: #a020f0;">endif</span>

  <span style="color: #a020f0;">select case</span> (na)
  <span style="color: #a020f0;">case</span> (5)
     <span style="color: #a020f0;">call</span> <span style="color: #0000ff;">adjugate5</span>(A,LDA,B,LDB,na,det_l)
  <span style="color: #a020f0;">case</span> (4)
     <span style="color: #a020f0;">call</span> <span style="color: #0000ff;">adjugate4</span>(A,LDA,B,LDB,na,det_l)
  <span style="color: #a020f0;">case</span> (3)
     <span style="color: #a020f0;">call</span> <span style="color: #0000ff;">adjugate3</span>(A,LDA,B,LDB,na,det_l)
  <span style="color: #a020f0;">case</span> (2)
     <span style="color: #a020f0;">call</span> <span style="color: #0000ff;">adjugate2</span>(A,LDA,B,LDB,na,det_l)
  <span style="color: #a020f0;">case</span> (1)
    det_l = a(1,1)
    b(1,1) = 1.d0
  <span style="color: #a020f0;">case</span> default
     <span style="color: #a020f0;">call</span> <span style="color: #0000ff;">adjugate_general</span>(context, na, A, LDA, B, LDB, det_l)
  <span style="color: #a020f0;">end select</span>

<span style="color: #a020f0;">end function</span> <span style="color: #0000ff;">qmckl_adjugate_f</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-f90"><span style="color: #a020f0;">subroutine</span> <span style="color: #0000ff;">adjugate_general</span>(context, na, A, LDA, B, LDB, det_l)
  <span style="color: #a020f0;">use</span> <span style="color: #0000ff;">qmckl</span>
  <span style="color: #a020f0;">implicit</span> <span style="color: #228b22;">none</span>
  <span style="color: #228b22;">integer</span>(qmckl_context), <span style="color: #a020f0;">intent</span>(in) ::<span style="color: #a0522d;"> context</span>
  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">intent</span>(in)       ::<span style="color: #a0522d;"> A (LDA,na)</span>
  <span style="color: #228b22;">integer</span>*8, <span style="color: #a020f0;">intent</span>(in)              ::<span style="color: #a0522d;"> LDA</span>
  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">intent</span>(out)      ::<span style="color: #a0522d;"> B (LDB,na)</span>
  <span style="color: #228b22;">integer</span>*8, <span style="color: #a020f0;">intent</span>(in)              ::<span style="color: #a0522d;"> LDB</span>
  <span style="color: #228b22;">integer</span>*8, <span style="color: #a020f0;">intent</span>(in)              ::<span style="color: #a0522d;"> na</span>
  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">intent</span>(inout)    ::<span style="color: #a0522d;"> det_l</span>

  <span style="color: #228b22;">double precision</span> ::<span style="color: #a0522d;"> work(LDA*max(na,64))</span>
  <span style="color: #228b22;">integer</span>          ::<span style="color: #a0522d;"> inf</span>
  <span style="color: #228b22;">integer</span>          ::<span style="color: #a0522d;"> ipiv(LDA)</span>
  <span style="color: #228b22;">integer</span>          ::<span style="color: #a0522d;"> lwork</span>
  <span style="color: #228b22;">integer</span>(8)       ::<span style="color: #a0522d;"> i, j</span>

</pre>
</div>

<p>
We first copy the array <code>A</code> into array <code>B</code>.
</p>

<div class="org-src-container">
<pre class="src src-f90">B(1:na,1:na) = A(1:na,1:na)
</pre>
</div>

<p>
Then, we compute the LU factorization \(LU=A\)
using the <code>dgetrf</code> routine.
</p>

<div class="org-src-container">
<pre class="src src-f90"><span style="color: #a020f0;">call</span> <span style="color: #0000ff;">dgetrf</span>(na, na, B, LDB, ipiv, inf )
</pre>
</div>

<p>
By convention, the determinant of \(L\) is equal to one, so the
determinant of \(A\) is equal to the determinant of \(U\), which is
simply computed as the product of its diagonal elements.
</p>

<div class="org-src-container">
<pre class="src src-f90">det_l = 1.d0
j=0_8
<span style="color: #a020f0;">do</span> i=1,na
 j = j+<span style="color: #a020f0;">min</span>(<span style="color: #a020f0;">abs</span>(ipiv(i)-i),1)
 det_l = det_l*B(i,i)
<span style="color: #a020f0;">enddo</span>
</pre>
</div>

<p>
As <code>dgetrf</code> returns \(PLU=A\) where \(P\) is a permutation matrix, the
sign of the determinant is computed as \(-1^m\) where \(m\) is the
number of permutations.
</p>

<div class="org-src-container">
<pre class="src src-f90"><span style="color: #a020f0;">if</span> (<span style="color: #a020f0;">iand</span>(j,1_8) /= 0_8)  <span style="color: #a020f0;">then</span>
  det_l = -det_l
<span style="color: #a020f0;">endif</span>
</pre>
</div>

<p>
Then, the inverse of \(A\) is computed using <code>dgetri</code>:
</p>

<div class="org-src-container">
<pre class="src src-f90">lwork = <span style="color: #a020f0;">SIZE</span>(work)
<span style="color: #a020f0;">call</span> <span style="color: #0000ff;">dgetri</span>(na, B, LDB, ipiv, work, lwork, inf )
</pre>
</div>

<p>
and the adjugate matrix is computed as the product of the
determinant with the inverse:
</p>

<div class="org-src-container">
<pre class="src src-f90">  B(:,:) = B(:,:)*det_l

<span style="color: #a020f0;">end subroutine</span> <span style="color: #0000ff;">adjugate_general</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org7983580" class="outline-3">
<h3 id="org7983580"><span class="section-number-3">2.4</span> <code>qmckl_transpose</code></h3>
<div class="outline-text-3" id="text-2-4">
<p>
Transposes a matrix: \(A^\dagger_{ji} = A_{ij}\).
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Variable</th>
<th scope="col" class="org-left">Type</th>
<th scope="col" class="org-left">In/Out</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">context</td>
<td class="org-left">qmckl<sub>context</sub></td>
<td class="org-left">in</td>
<td class="org-left">Global state</td>
</tr>

<tr>
<td class="org-left">A</td>
<td class="org-left">qmckl<sub>matrix</sub></td>
<td class="org-left">in</td>
<td class="org-left">Input matrix</td>
</tr>

<tr>
<td class="org-left">At</td>
<td class="org-left">qmckl<sub>matrix</sub></td>
<td class="org-left">out</td>
<td class="org-left">Transposed matrix</td>
</tr>
</tbody>
</table>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #228b22;">qmckl_exit_code</span>
<span style="color: #0000ff;">qmckl_transpose</span> (<span style="color: #228b22;">qmckl_context</span> <span style="color: #a0522d;">context</span>,
                 <span style="color: #a020f0;">const</span> <span style="color: #228b22;">qmckl_matrix</span> <span style="color: #a0522d;">A</span>,
                 <span style="color: #228b22;">qmckl_matrix</span> <span style="color: #a0522d;">At</span> ); 
</pre>
</div>


<div class="org-src-container">
<pre class="src src-c"><span style="color: #228b22;">qmckl_exit_code</span>
<span style="color: #0000ff;">qmckl_transpose</span> (<span style="color: #228b22;">qmckl_context</span> <span style="color: #a0522d;">context</span>,
                 <span style="color: #a020f0;">const</span> <span style="color: #228b22;">qmckl_matrix</span> <span style="color: #a0522d;">A</span>,
                 <span style="color: #228b22;">qmckl_matrix</span> <span style="color: #a0522d;">At</span> )
{
  <span style="color: #a020f0;">if</span> (qmckl_context_check(context) == QMCKL_NULL_CONTEXT) {
    <span style="color: #a020f0;">return</span> QMCKL_INVALID_CONTEXT;
  }

  <span style="color: #a020f0;">if</span> (A.size[0] &lt; 1) {
    <span style="color: #a020f0;">return</span> qmckl_failwith( context,
                           QMCKL_INVALID_ARG_2,
                           <span style="color: #8b2252;">"qmckl_transpose"</span>,
                           <span style="color: #8b2252;">"Invalid size for A"</span>);
  }

  <span style="color: #a020f0;">if</span> (At.data == <span style="color: #008b8b;">NULL</span>) {
    <span style="color: #a020f0;">return</span> qmckl_failwith( context,
                           QMCKL_INVALID_ARG_3,
                           <span style="color: #8b2252;">"qmckl_transpose"</span>,
                           <span style="color: #8b2252;">"Output matrix not allocated"</span>);
  }

  <span style="color: #a020f0;">if</span> (At.size[0] != A.size[1] || At.size[1] != A.size[0]) {
    <span style="color: #a020f0;">return</span> qmckl_failwith( context,
                           QMCKL_INVALID_ARG_3,
                           <span style="color: #8b2252;">"qmckl_transpose"</span>,
                           <span style="color: #8b2252;">"Invalid size for At"</span>);
  }

  <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">j</span>=0 ; j&lt;At.size[1] ; ++j) 
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">i</span>=0 ; i&lt;At.size[0] ; ++i) 
      qmckl_mat(At, i, j) = qmckl_mat(A, j, i);

  <span style="color: #a020f0;">return</span> QMCKL_SUCCESS;
}
</pre>
</div>
</div>

<div id="outline-container-org7b3ed34" class="outline-4">
<h4 id="org7b3ed34"><span class="section-number-4">2.4.1</span> Test</h4>
<div class="outline-text-4" id="text-2-4-1">
<div class="org-src-container">
<pre class="src src-c">{
  <span style="color: #228b22;">qmckl_matrix</span> <span style="color: #a0522d;">A</span>;
  <span style="color: #228b22;">qmckl_matrix</span> <span style="color: #a0522d;">At</span>;
  A  = qmckl_matrix_alloc(context, 2, 3);
  At = qmckl_matrix_alloc(context, 3, 2);
  <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">j</span>=0 ; j&lt;3 ; ++j)
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span>=0 ; i&lt;2 ; ++i)
      qmckl_mat(A, i, j) = (<span style="color: #228b22;">double</span>) 10*i+j;

  <span style="color: #228b22;">qmckl_exit_code</span> <span style="color: #a0522d;">rc</span> = qmckl_transpose(context, A, At);
  assert(rc == QMCKL_SUCCESS);

  assert(A.size[0] == At.size[1]);
  assert(A.size[1] == At.size[0]);
  <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">j</span>=0 ; j&lt;3 ; ++j)
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span>=0 ; i&lt;2 ; ++i)
      assert (qmckl_mat(A, i, j) == qmckl_mat(At, j, i));

  qmckl_matrix_free(context, A);
  qmckl_matrix_free(context, At);
}

</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: TREX CoE</p>
<p class="date">Created: 2022-02-11 Fri 15:00</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
